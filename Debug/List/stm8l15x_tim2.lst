###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             11/Mar/2014  17:31:40 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_t #
#                    im2.c                                                    #
#    Command line =  "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_t #
#                    im2.c" -e -Ol --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model small --data_model medium -o                #
#                    "F:\Skydrive\Final Design\Servo Motor STM8L\Debug\Obj\"  #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.0\stm8\LIB\dlstm8smn.h" -D STM8L15X_MD -lCN            #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Debug\List\" --diag_suppress Pe177,Pe550 -I        #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Project\Discover\inc\" -I "F:\Skydrive\Final       #
#                    Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Dr #
#                    iver\inc\" --vregs 16                                    #
#    List file    =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\List\stm8l15x_tim2.lst                       #
#    Object file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\Obj\stm8l15x_tim2.o                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\Skydrive\Final Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim2.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim2.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the TIM2 firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_tim2.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          static void TI1_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
     34                                 TIM2_ICSelection_TypeDef TIM2_ICSelection,
     35                                 uint8_t TIM2_ICFilter);
     36          static void TI2_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
     37                                 TIM2_ICSelection_TypeDef TIM2_ICSelection,
     38                                 uint8_t TIM2_ICFilter);
     39          
     40          
     41          /**
     42            * @addtogroup TIM2_Public_Functions
     43            * @{
     44            */
     45          
     46          /**
     47            * @brief  Deinitializes the TIM2 peripheral registers to their default reset values.
     48            * @param  None
     49            * @retval None
     50            */

   \                                 In section .near_func.text, align 1
     51          void TIM2_DeInit(void)
     52          {
     53            TIM2->CR1 = TIM_CR1_RESET_VALUE;
   \                     TIM2_DeInit:
   \   000000 35005250              MOV       L:0x5250, #0x0
     54            TIM2->CR2 = TIM_CR2_RESET_VALUE;
   \   000004 35005251              MOV       L:0x5251, #0x0
     55            TIM2->SMCR = TIM_SMCR_RESET_VALUE;
   \   000008 35005252              MOV       L:0x5252, #0x0
     56            TIM2->ETR = TIM_ETR_RESET_VALUE;
   \   00000C 35005253              MOV       L:0x5253, #0x0
     57            TIM2->IER = TIM_IER_RESET_VALUE;
   \   000010 35005255              MOV       L:0x5255, #0x0
     58            TIM2->SR2 = TIM_SR2_RESET_VALUE;
   \   000014 35005257              MOV       L:0x5257, #0x0
     59          
     60            /* Disable channels */
     61            TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000018 3500525B              MOV       L:0x525b, #0x0
     62            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
     63            TIM2->CCMR1 = 0x01;/*TIM2_ICxSource_TIxFPx */
   \   00001C 35015259              MOV       L:0x5259, #0x1
     64            TIM2->CCMR2 = 0x01;/*TIM2_ICxSource_TIxFPx */
   \   000020 3501525A              MOV       L:0x525a, #0x1
     65          
     66            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     67            TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000024 3500525B              MOV       L:0x525b, #0x0
     68            TIM2->CCMR1 = TIM_CCMR1_RESET_VALUE;
   \   000028 35005259              MOV       L:0x5259, #0x0
     69            TIM2->CCMR2 = TIM_CCMR2_RESET_VALUE;
   \   00002C 3500525A              MOV       L:0x525a, #0x0
     70          
     71            TIM2->CNTRH = TIM_CNTRH_RESET_VALUE;
   \   000030 3500525C              MOV       L:0x525c, #0x0
     72            TIM2->CNTRL = TIM_CNTRL_RESET_VALUE;
   \   000034 3500525D              MOV       L:0x525d, #0x0
     73          
     74            TIM2->PSCR = TIM_PSCR_RESET_VALUE;
   \   000038 3500525E              MOV       L:0x525e, #0x0
     75          
     76            TIM2->ARRH = TIM_ARRH_RESET_VALUE;
   \   00003C 35FF525F              MOV       L:0x525f, #0xff
     77            TIM2->ARRL = TIM_ARRL_RESET_VALUE;
   \   000040 35FF5260              MOV       L:0x5260, #0xff
     78          
     79            TIM2->CCR1H = TIM_CCR1H_RESET_VALUE;
   \   000044 35005261              MOV       L:0x5261, #0x0
     80            TIM2->CCR1L = TIM_CCR1L_RESET_VALUE;
   \   000048 35005262              MOV       L:0x5262, #0x0
     81            TIM2->CCR2H = TIM_CCR2H_RESET_VALUE;
   \   00004C 35005263              MOV       L:0x5263, #0x0
     82            TIM2->CCR2L = TIM_CCR2L_RESET_VALUE;
   \   000050 35005264              MOV       L:0x5264, #0x0
     83          
     84          
     85            TIM2->OISR = TIM_OISR_RESET_VALUE;
   \   000054 35005266              MOV       L:0x5266, #0x0
     86            TIM2->EGR = 0x01;/* TIM_EGR_UG */
   \   000058 35015258              MOV       L:0x5258, #0x1
     87            TIM2->BKR = TIM_BKR_RESET_VALUE;
   \   00005C 35005265              MOV       L:0x5265, #0x0
     88            TIM2->SR1 = TIM_SR1_RESET_VALUE;
   \   000060 35005256              MOV       L:0x5256, #0x0
     89          }
   \   000064 81                    RET
     90          
     91          /**
     92            * @brief  Initializes the TIM2 Time Base Unit according to the specified  parameters.
     93            * @param  TIM2_Prescaler : This parameter can be any member of the @Ref TIM2_Prescaler_TypeDef enumeration.
     94            * @param  TIM2_CounterMode : This parameter can be any member of the @Ref TIM2_CounterMode_TypeDef enumeration.
     95            * @param  TIM2_Period : This parameter must be a value between 0x0000 and 0xFFFF.
     96            * @retval None
     97            */
     98          

   \                                 In section .near_func.text, align 1
     99          void TIM2_TimeBaseInit(TIM2_Prescaler_TypeDef TIM2_Prescaler,
    100                                 TIM2_CounterMode_TypeDef TIM2_CounterMode,
    101                                 uint16_t TIM2_Period)
    102          {
   \                     TIM2_TimeBaseInit:
   \   000000 B700                  LD        S:?b1, A
   \   000002 9093                  LDW       Y, X
    103          
    104            assert_param(IS_TIM2_PRESCALER(TIM2_Prescaler));
    105            assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
    106          
    107          
    108          
    109            /* Set the Autoreload value */
    110            TIM2->ARRH = (uint8_t)(TIM2_Period >> 8) ;
   \   000004 93                    LDW       X, Y
   \   000005 4F                    CLR       A
   \   000006 01                    RRWA      X, A
   \   000007 9F                    LD        A, XL
   \   000008 C7525F                LD        L:0x525f, A
    111            TIM2->ARRL = (uint8_t)(TIM2_Period);
   \   00000B 909F                  LD        A, YL
   \   00000D C75260                LD        L:0x5260, A
    112          
    113            /* Set the Prescaler value */
    114            TIM2->PSCR = (uint8_t)(TIM2_Prescaler);
   \   000010 B600                  LD        A, S:?b1
   \   000012 C7525E                LD        L:0x525e, A
    115          
    116            /* Select the Counter Mode */
    117            TIM2->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
   \   000015 C65250                LD        A, L:0x5250
   \   000018 A48F                  AND       A, #0x8f
   \   00001A C75250                LD        L:0x5250, A
    118            TIM2->CR1 |= (uint8_t)(TIM2_CounterMode);
   \   00001D B600                  LD        A, S:?b0
   \   00001F CA5250                OR        A, L:0x5250
   \   000022 C75250                LD        L:0x5250, A
    119          
    120            /* Generate an update event to reload the Prescaler value immediately */
    121            TIM2->EGR = TIM2_EventSource_Update;
   \   000025 35015258              MOV       L:0x5258, #0x1
    122          }
   \   000029 81                    RET
    123          
    124          /**
    125            * @brief  Initializes the TIM2 Channel1 according to the specified parameters.
    126            * @param  TIM2_OCMode : This parameter can be any member of the @Ref TIM2_OCMode_TypeDef enumeration.
    127            * @param  TIM2_OutputState : This parameter can be any member of the @Ref TIM2_OutputState_TypeDef enumeration.
    128            * @param  TIM2_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    129            * @param  TIM2_OCPolarity : This parameter can be any member of the @Ref TIM2_OCPolarity_TypeDef enumeration.
    130            * @param  TIM2_OCIdleState : This parameter can be any member of the @Ref TIM2_OCIdleState_TypeDef  enumeration.
    131            * @retval None
    132            */

   \                                 In section .near_func.text, align 1
    133          void TIM2_OC1Init(TIM2_OCMode_TypeDef TIM2_OCMode,
    134                            TIM2_OutputState_TypeDef TIM2_OutputState,
    135                            uint16_t TIM2_Pulse,
    136                            TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
    137                            TIM2_OCIdleState_TypeDef TIM2_OCIdleState)
    138          {
   \                     TIM2_OC1Init:
   \   000000 B700                  LD        S:?b3, A
   \   000002 9093                  LDW       Y, X
    139            uint8_t tmpccmr1 = 0;
   \   000004 3F00                  CLR       S:?b4
    140          
    141            /* Check the parameters */
    142            assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
    143            assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
    144            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
    145            assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
    146          
    147            tmpccmr1 = TIM2->CCMR1;
   \   000006 C65259                LD        A, L:0x5259
   \   000009 B700                  LD        S:?b4, A
    148          
    149            /* Disable the Channel 1: Reset the CCE Bit */
    150            TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   00000B 7211525B              BRES      L:0x525b, #0x0
    151            /* Reset the Output Compare Bits */
    152            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B600                  LD        A, S:?b4
   \   000011 A48F                  AND       A, #0x8f
   \   000013 B700                  LD        S:?b4, A
    153          
    154            /* Set the Ouput Compare Mode */
    155            tmpccmr1 |= (uint8_t)TIM2_OCMode;
   \   000015 B600                  LD        A, S:?b3
   \   000017 BA00                  OR        A, S:?b4
   \   000019 B700                  LD        S:?b4, A
    156          
    157            TIM2->CCMR1 = tmpccmr1;
   \   00001B B600                  LD        A, S:?b4
   \   00001D C75259                LD        L:0x5259, A
    158          
    159            /* Set the Output State */
    160            if (TIM2_OutputState == TIM2_OutputState_Enable)
   \   000020 B600                  LD        A, S:?b0
   \   000022 A101                  CP        A, #0x1
   \   000024 2606                  JRNE      L:??TIM2_OC1Init_0
    161            {
    162              TIM2->CCER1 |= TIM_CCER1_CC1E;
   \   000026 7210525B              BSET      L:0x525b, #0x0
   \   00002A 2004                  JRA       L:??TIM2_OC1Init_1
    163            }
    164            else
    165            {
    166              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \                     ??TIM2_OC1Init_0:
   \   00002C 7211525B              BRES      L:0x525b, #0x0
    167            }
    168          
    169            /* Set the Output Polarity */
    170            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     ??TIM2_OC1Init_1:
   \   000030 B600                  LD        A, S:?b1
   \   000032 A101                  CP        A, #0x1
   \   000034 2606                  JRNE      L:??TIM2_OC1Init_2
    171            {
    172              TIM2->CCER1 |= TIM_CCER1_CC1P;
   \   000036 7212525B              BSET      L:0x525b, #0x1
   \   00003A 2004                  JRA       L:??TIM2_OC1Init_3
    173            }
    174            else
    175            {
    176              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TIM2_OC1Init_2:
   \   00003C 7213525B              BRES      L:0x525b, #0x1
    177            }
    178          
    179            /* Set the Output Idle state */
    180            if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
   \                     ??TIM2_OC1Init_3:
   \   000040 B600                  LD        A, S:?b2
   \   000042 A101                  CP        A, #0x1
   \   000044 2606                  JRNE      L:??TIM2_OC1Init_4
    181            {
    182              TIM2->OISR |= TIM_OISR_OIS1;
   \   000046 72105266              BSET      L:0x5266, #0x0
   \   00004A 2004                  JRA       L:??TIM2_OC1Init_5
    183            }
    184            else
    185            {
    186              TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS1);
   \                     ??TIM2_OC1Init_4:
   \   00004C 72115266              BRES      L:0x5266, #0x0
    187            }
    188          
    189            /* Set the Pulse value */
    190            TIM2->CCR1H = (uint8_t)(TIM2_Pulse >> 8);
   \                     ??TIM2_OC1Init_5:
   \   000050 93                    LDW       X, Y
   \   000051 4F                    CLR       A
   \   000052 01                    RRWA      X, A
   \   000053 9F                    LD        A, XL
   \   000054 C75261                LD        L:0x5261, A
    191            TIM2->CCR1L = (uint8_t)(TIM2_Pulse);
   \   000057 909F                  LD        A, YL
   \   000059 C75262                LD        L:0x5262, A
    192          }
   \   00005C 81                    RET
    193          
    194          /**
    195            * @brief  Initializes the TIM2 Channel2 according to the specified parameters.
    196            * @param  TIM2_OCMode : This parameter can be any member of the @Ref TIM2_OCMode_TypeDef enumeration.
    197            * @param  TIM2_OutputState : This parameter can be any member of the @Ref TIM2_OutputState_TypeDef enumeration.
    198            * @param  TIM2_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    199            * @param  TIM2_OCPolarity : This parameter can be any member of the @Ref TIM2_OCPolarity_TypeDef enumeration.
    200            * @param  TIM2_OCIdleState : This parameter can be any member of the @Ref TIM2_OCIdleState_TypeDef  enumeration.
    201            * @retval None
    202            */

   \                                 In section .near_func.text, align 1
    203          void TIM2_OC2Init(TIM2_OCMode_TypeDef TIM2_OCMode,
    204                            TIM2_OutputState_TypeDef TIM2_OutputState,
    205                            uint16_t TIM2_Pulse,
    206                            TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
    207                            TIM2_OCIdleState_TypeDef TIM2_OCIdleState)
    208          {
   \                     TIM2_OC2Init:
   \   000000 B700                  LD        S:?b3, A
   \   000002 9093                  LDW       Y, X
    209            uint8_t tmpccmr2 = 0;
   \   000004 3F00                  CLR       S:?b4
    210          
    211            /* Check the parameters */
    212            assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
    213            assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
    214            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
    215            assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
    216          
    217            tmpccmr2 = TIM2->CCMR2;
   \   000006 C6525A                LD        A, L:0x525a
   \   000009 B700                  LD        S:?b4, A
    218          
    219            /* Disable the Channel 2: Reset the CCE Bit */
    220            TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \   00000B 7219525B              BRES      L:0x525b, #0x4
    221          
    222            /* Reset the Output Compare Bits */
    223            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B600                  LD        A, S:?b4
   \   000011 A48F                  AND       A, #0x8f
   \   000013 B700                  LD        S:?b4, A
    224          
    225            /* Set the Ouput Compare Mode */
    226            tmpccmr2 |= (uint8_t)TIM2_OCMode;
   \   000015 B600                  LD        A, S:?b3
   \   000017 BA00                  OR        A, S:?b4
   \   000019 B700                  LD        S:?b4, A
    227          
    228            TIM2->CCMR2 = tmpccmr2;
   \   00001B B600                  LD        A, S:?b4
   \   00001D C7525A                LD        L:0x525a, A
    229          
    230            /* Set the Output State */
    231            if (TIM2_OutputState == TIM2_OutputState_Enable)
   \   000020 B600                  LD        A, S:?b0
   \   000022 A101                  CP        A, #0x1
   \   000024 2606                  JRNE      L:??TIM2_OC2Init_0
    232            {
    233              TIM2->CCER1 |= TIM_CCER1_CC2E;
   \   000026 7218525B              BSET      L:0x525b, #0x4
   \   00002A 2004                  JRA       L:??TIM2_OC2Init_1
    234            }
    235            else
    236            {
    237              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM2_OC2Init_0:
   \   00002C 7219525B              BRES      L:0x525b, #0x4
    238            }
    239          
    240            /* Set the Output Polarity */
    241            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     ??TIM2_OC2Init_1:
   \   000030 B600                  LD        A, S:?b1
   \   000032 A101                  CP        A, #0x1
   \   000034 2606                  JRNE      L:??TIM2_OC2Init_2
    242            {
    243              TIM2->CCER1 |= TIM_CCER1_CC2P;
   \   000036 721A525B              BSET      L:0x525b, #0x5
   \   00003A 2004                  JRA       L:??TIM2_OC2Init_3
    244            }
    245            else
    246            {
    247              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
   \                     ??TIM2_OC2Init_2:
   \   00003C 721B525B              BRES      L:0x525b, #0x5
    248            }
    249          
    250          
    251            /* Set the Output Idle state */
    252            if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
   \                     ??TIM2_OC2Init_3:
   \   000040 B600                  LD        A, S:?b2
   \   000042 A101                  CP        A, #0x1
   \   000044 2606                  JRNE      L:??TIM2_OC2Init_4
    253            {
    254              TIM2->OISR |= TIM_OISR_OIS2;
   \   000046 72145266              BSET      L:0x5266, #0x2
   \   00004A 2004                  JRA       L:??TIM2_OC2Init_5
    255            }
    256            else
    257            {
    258              TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS2);
   \                     ??TIM2_OC2Init_4:
   \   00004C 72155266              BRES      L:0x5266, #0x2
    259            }
    260          
    261            /* Set the Pulse value */
    262            TIM2->CCR2H = (uint8_t)(TIM2_Pulse >> 8);
   \                     ??TIM2_OC2Init_5:
   \   000050 93                    LDW       X, Y
   \   000051 4F                    CLR       A
   \   000052 01                    RRWA      X, A
   \   000053 9F                    LD        A, XL
   \   000054 C75263                LD        L:0x5263, A
    263            TIM2->CCR2L = (uint8_t)(TIM2_Pulse);
   \   000057 909F                  LD        A, YL
   \   000059 C75264                LD        L:0x5264, A
    264          }
   \   00005C 81                    RET
    265          
    266          /**
    267            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    268            * and the AOE(automatic output enable).
    269            * @param  TIM2_OSSIState : Off-State Selection for Idle mode states.
    270            *   This parameter can be any member of the @Ref TIM2_OSSIState_TypeDef enumeration.
    271            * @param  TIM2_LockLevel : Lock level.
    272            *   This parameter can be any member of the @Ref TIM2_LockLevel_TypeDef enumeration.
    273            * @param  TIM2_BreakState : Break Input enable/disable .
    274            *   This parameter can be any member of the @Ref TIM2_BreakState_TypeDef enumeration.
    275            * @param  TIM2_BreakPolarity : Break Polarity.
    276            *   This parameter can be any member of the @Ref TIM2_BreakPolarity_TypeDef enumeration.
    277            * @param  TIM2_AutomaticOutput : TIM2 AOE Bit Set/Reset .
    278            *   This parameter can be anymember  of the @Ref TIM2_AutomaticOutput_TypeDef enumeration.
    279            * @retval None
    280            */

   \                                 In section .near_func.text, align 1
    281          void TIM2_BKRConfig(TIM2_OSSIState_TypeDef TIM2_OSSIState,
    282                              TIM2_LockLevel_TypeDef TIM2_LockLevel,
    283                              TIM2_BreakState_TypeDef TIM2_BreakState,
    284                              TIM2_BreakPolarity_TypeDef TIM2_BreakPolarity,
    285                              TIM2_AutomaticOutput_TypeDef TIM2_AutomaticOutput)
    286          
    287          {
   \                     TIM2_BKRConfig:
   \   000000 B700                  LD        S:?b4, A
   \   000002 B600                  LD        A, S:?b2
    288            /* Check the parameters */
    289            assert_param(IS_TIM2_OSSI_STATE(TIM2_OSSIState));
    290            assert_param(IS_TIM2_LOCK_LEVEL(TIM2_LockLevel));
    291            assert_param(IS_TIM2_BREAK_STATE(TIM2_BreakState));
    292            assert_param(IS_TIM2_BREAK_POLARITY(TIM2_BreakPolarity));
    293            assert_param(IS_TIM2_AUTOMATIC_OUTPUT_STATE(TIM2_AutomaticOutput));
    294          
    295          
    296          
    297            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSI State,
    298            the dead time value and the Automatic Output Enable Bit */
    299          
    300            TIM2->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM2_OSSIState | (uint8_t)TIM2_LockLevel) | \
    301                                            (uint8_t)((uint8_t)TIM2_BreakState | TIM2_BreakPolarity)) | \
    302                                  (uint8_t)TIM2_AutomaticOutput);
   \   000004 BA00                  OR        A, S:?b1
   \   000006 88                    PUSH      A
   \   000007 B600                  LD        A, S:?b0
   \   000009 BA00                  OR        A, S:?b4
   \   00000B B700                  LD        S:?b0, A
   \   00000D 84                    POP       A
   \   00000E BA00                  OR        A, S:?b0
   \   000010 BA00                  OR        A, S:?b3
   \   000012 C75265                LD        L:0x5265, A
    303          }
   \   000015 81                    RET
    304          
    305          /**
    306            * @brief  Initializes the TIM2 peripheral according to the specified parameters.
    307            * @param  TIM2_Channel : This parameter can be any member of the @Ref TIM2_Channel_TypeDef enumeration.
    308            * @param  TIM2_ICPolarity : This parameter can be any member of the @Ref TIM2_ICPolarity_TypeDef enumeration.
    309            * @param  TIM2_ICSelection : This parameter can be any member of the @Ref TIM2_ICSelection_TypeDef enumeration.
    310            * @param  TIM2_ICPrescaler : This parameter can be any member of the @Ref TIM2_ICPSC_TypeDef enumeration.
    311            * @param  TIM2_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    312            * @retval None
    313            */

   \                                 In section .near_func.text, align 1
    314          void TIM2_ICInit(TIM2_Channel_TypeDef TIM2_Channel,
    315                           TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
    316                           TIM2_ICSelection_TypeDef TIM2_ICSelection,
    317                           TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
    318                           uint8_t TIM2_ICFilter)
    319          {
   \                     TIM2_ICInit:
   \   000000 450000                MOV       S:?b4, S:?b0
   \   000003 450000                MOV       S:?b0, S:?b1
   \   000006 450000                MOV       S:?b5, S:?b2
   \   000009 450000                MOV       S:?b1, S:?b3
    320            /* Check the parameters */
    321            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
    322          
    323            if (TIM2_Channel == TIM2_Channel_1)
   \   00000C 4D                    TNZ       A
   \   00000D 260A                  JRNE      L:??TIM2_ICInit_0
    324            {
    325              /* TI1 Configuration */
    326              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection, TIM2_ICFilter);
   \   00000F B600                  LD        A, S:?b4
   \   000011 CD0000                CALL      L:TI1_Config
    327          
    328              /* Set the Input Capture Prescaler value */
    329              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   \   000014 B600                  LD        A, S:?b5
   \   000016 CC0000                JP        L:TIM2_SetIC1Prescaler
    330            }
    331            else /* if (TIM2_Channel == TIM2_Channel_2) */
    332            {
    333              /* TI2 Configuration */
    334              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection, TIM2_ICFilter);
   \                     ??TIM2_ICInit_0:
   \   000019 B600                  LD        A, S:?b4
   \   00001B CD0000                CALL      L:TI2_Config
    335          
    336              /* Set the Input Capture Prescaler value */
    337              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   \   00001E B600                  LD        A, S:?b5
   \   000020 CC0000                JP        L:TIM2_SetIC2Prescaler
    338            }
    339          }
    340          
    341          /**
    342            * @brief  Configures the TIM2 peripheral in PWM Input Mode according to the
    343            * specified parameters.
    344            * @param  TIM2_Channel : This parameter can be any member of the @Ref TIM2_Channel_TypeDef enumeration.
    345            * @param  TIM2_ICPolarity : This parameter can be any member of the @Ref TIM2_ICPolarity_TypeDef enumeration.
    346            * @param  TIM2_ICSelection : This parameter can be any member of the @Ref TIM2_ICSelection_TypeDef enumeration.
    347            * @param  TIM2_ICPrescaler : This parameter can be any member of the @Ref TIM2_ICPSC_TypeDef enumeration.
    348            * @param  TIM2_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    349            * @retval None
    350            */

   \                                 In section .near_func.text, align 1, keep-with-next
    351          void TIM2_PWMIConfig(TIM2_Channel_TypeDef TIM2_Channel,
    352                               TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
    353                               TIM2_ICSelection_TypeDef TIM2_ICSelection,
    354                               TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
    355                               uint8_t TIM2_ICFilter)
    356          {
   \                     TIM2_PWMIConfig:
   \   000000 CD0000                CALL      L:?push_w4
   \   000003 B700                  LD        S:?b6, A
   \   000005 450000                MOV       S:?b7, S:?b0
   \   000008 B600                  LD        A, S:?b1
   \   00000A 450000                MOV       S:?b8, S:?b2
   \   00000D 450000                MOV       S:?b9, S:?b3
    357            uint8_t icpolarity = TIM2_ICPolarity_Rising;
   \   000010 3F00                  CLR       S:?b5
    358            uint8_t icselection = TIM2_ICSelection_DirectTI;
   \   000012 35010000              MOV       S:?b4, #0x1
    359          
    360            /* Check the parameters */
    361            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
    362          
    363            /* Select the Opposite Input Polarity */
    364            if (TIM2_ICPolarity == TIM2_ICPolarity_Rising)
   \   000016 3D00                  TNZ       S:?b7
   \   000018 2606                  JRNE      L:??TIM2_PWMIConfig_0
    365            {
    366              icpolarity = TIM2_ICPolarity_Falling;
   \   00001A 35010000              MOV       S:?b5, #0x1
   \   00001E 2002                  JRA       L:??TIM2_PWMIConfig_1
    367            }
    368            else
    369            {
    370              icpolarity = TIM2_ICPolarity_Rising;
   \                     ??TIM2_PWMIConfig_0:
   \   000020 3F00                  CLR       S:?b5
    371            }
    372          
    373            /* Select the Opposite Input */
    374            if (TIM2_ICSelection == TIM2_ICSelection_DirectTI)
   \                     ??TIM2_PWMIConfig_1:
   \   000022 A101                  CP        A, #0x1
   \   000024 2606                  JRNE      L:??TIM2_PWMIConfig_2
    375            {
    376              icselection = TIM2_ICSelection_IndirectTI;
   \   000026 35020000              MOV       S:?b4, #0x2
   \   00002A 2004                  JRA       L:??TIM2_PWMIConfig_3
    377            }
    378            else
    379            {
    380              icselection = TIM2_ICSelection_DirectTI;
   \                     ??TIM2_PWMIConfig_2:
   \   00002C 35010000              MOV       S:?b4, #0x1
    381            }
    382          
    383            if (TIM2_Channel == TIM2_Channel_1)
   \                     ??TIM2_PWMIConfig_3:
   \   000030 3D00                  TNZ       S:?b6
   \   000032 2622                  JRNE      L:??TIM2_PWMIConfig_4
    384            {
    385              /* TI1 Configuration */
    386              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection,
    387                         TIM2_ICFilter);
   \   000034 450000                MOV       S:?b1, S:?b9
   \   000037 B700                  LD        S:?b0, A
   \   000039 B600                  LD        A, S:?b7
   \   00003B CD0000                CALL      L:TI1_Config
    388          
    389              /* Set the Input Capture Prescaler value */
    390              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   \   00003E B600                  LD        A, S:?b8
   \   000040 CD0000                CALL      L:TIM2_SetIC1Prescaler
    391          
    392              /* TI2 Configuration */
    393              TI2_Config((TIM2_ICPolarity_TypeDef)icpolarity, (TIM2_ICSelection_TypeDef)icselection, TIM2_ICFilter);
   \   000043 450000                MOV       S:?b1, S:?b9
   \   000046 450000                MOV       S:?b0, S:?b4
   \   000049 B600                  LD        A, S:?b5
   \   00004B CD0000                CALL      L:TI2_Config
    394          
    395              /* Set the Input Capture Prescaler value */
    396              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   \   00004E B600                  LD        A, S:?b8
   \   000050 CD0000                CALL      L:TIM2_SetIC2Prescaler
   \   000053 CC0000                JP        L:?epilogue_w4
    397            }
    398            else
    399            {
    400              /* TI2 Configuration */
    401              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection,
    402                         TIM2_ICFilter);
   \                     ??TIM2_PWMIConfig_4:
   \   000056 450000                MOV       S:?b1, S:?b9
   \   000059 B700                  LD        S:?b0, A
   \   00005B B600                  LD        A, S:?b7
   \   00005D CD0000                CALL      L:TI2_Config
    403          
    404              /* Set the Input Capture Prescaler value */
    405              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   \   000060 B600                  LD        A, S:?b8
   \   000062 CD0000                CALL      L:TIM2_SetIC2Prescaler
    406          
    407              /* TI1 Configuration */
    408              TI1_Config((TIM2_ICPolarity_TypeDef)icpolarity, (TIM2_ICSelection_TypeDef)icselection, TIM2_ICFilter);
   \   000065 450000                MOV       S:?b1, S:?b9
   \   000068 450000                MOV       S:?b0, S:?b4
   \   00006B B600                  LD        A, S:?b5
   \   00006D CD0000                CALL      L:TI1_Config
    409          
    410              /* Set the Input Capture Prescaler value */
    411              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   \   000070 B600                  LD        A, S:?b8
   \   000072 CD0000                CALL      L:TIM2_SetIC1Prescaler
    412            }
    413          }
   \   000075 CC0000                JP        L:?epilogue_w4
    414          
    415          /**
    416            * @brief  Enables or disables the TIM2 peripheral.
    417            * @param  NewState : The new state of the TIM2 peripheral.
    418            *   This parameter can be any of the @ref FunctionalState enumeration.
    419            * @retval None
    420            */

   \                                 In section .near_func.text, align 1, keep-with-next
    421          void TIM2_Cmd(FunctionalState NewState)
    422          {
    423            /* Check the parameters */
    424            assert_param(IS_FUNCTIONAL_STATE(NewState));
    425          
    426            /* set or Reset the CEN Bit */
    427            if (NewState != DISABLE)
   \                     TIM2_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_Cmd_0
    428            {
    429              TIM2->CR1 |= TIM_CR1_CEN;
   \   000003 72105250              BSET      L:0x5250, #0x0
   \   000007 81                    RET
    430            }
    431            else
    432            {
    433              TIM2->CR1 &= (uint8_t)(~TIM_CR1_CEN);
   \                     ??TIM2_Cmd_0:
   \   000008 72115250              BRES      L:0x5250, #0x0
    434            }
    435          }
   \   00000C 81                    RET
    436          
    437          /**
    438            * @brief  Enables or disables the TIM2 peripheral Main Outputs.
    439            * @param  NewState : The new state of the TIM2 peripheral.
    440            *   This parameter can be any of the @ref FunctionalState enumeration.
    441            * @retval None
    442            */

   \                                 In section .near_func.text, align 1, keep-with-next
    443          void TIM2_CtrlPWMOutputs(FunctionalState NewState)
    444          {
    445            /* Check the parameters */
    446            assert_param(IS_FUNCTIONAL_STATE(NewState));
    447          
    448            /* Set or Reset the MOE Bit */
    449          
    450            if (NewState != DISABLE)
   \                     TIM2_CtrlPWMOutputs:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_CtrlPWMOutputs_0
    451            {
    452              TIM2->BKR |= TIM_BKR_MOE ;
   \   000003 721E5265              BSET      L:0x5265, #0x7
   \   000007 81                    RET
    453            }
    454            else
    455            {
    456              TIM2->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
   \                     ??TIM2_CtrlPWMOutputs_0:
   \   000008 721F5265              BRES      L:0x5265, #0x7
    457            }
    458          }
   \   00000C 81                    RET
    459          
    460          /**
    461            * @brief  Enables or disables the specified TIM2 interrupts.
    462            * @param  TIM2_IT : Specifies the TIM2 interrupts sources to be enabled or disabled.
    463            *   This parameter can be any combination of the @ref TIM2_IT_TypeDef enumeration.
    464            * @param  NewState : The new state of the TIM2 peripheral.
    465            *   This parameter can be any of the @ref FunctionalState enumeration.
    466            * @retval None
    467            */

   \                                 In section .near_func.text, align 1, keep-with-next
    468          void TIM2_ITConfig(TIM2_IT_TypeDef TIM2_IT, FunctionalState NewState)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_TIM2_IT(TIM2_IT));
    472            assert_param(IS_FUNCTIONAL_STATE(NewState));
    473          
    474            if (NewState != DISABLE)
   \                     TIM2_ITConfig:
   \   000000 3D00                  TNZ       S:?b0
   \   000002 2707                  JREQ      L:??TIM2_ITConfig_0
    475            {
    476              /* Enable the Interrupt sources */
    477              TIM2->IER |= (uint8_t)TIM2_IT;
   \   000004 CA5255                OR        A, L:0x5255
   \   000007 C75255                LD        L:0x5255, A
   \   00000A 81                    RET
    478            }
    479            else
    480            {
    481              /* Disable the Interrupt sources */
    482              TIM2->IER &= (uint8_t)(~(uint8_t)TIM2_IT);
   \                     ??TIM2_ITConfig_0:
   \   00000B 43                    CPL       A
   \   00000C C45255                AND       A, L:0x5255
   \   00000F C75255                LD        L:0x5255, A
    483            }
    484          }
   \   000012 81                    RET
    485          
    486          /**
    487            * @brief  Enables or disables the TIM2 DMA Requests.
    488            * @param  TIM2_DMASources: specifies the DMA Request sources.
    489            *   This parameter can be any combination of  @ref TIM2_DMASource_TypeDef enumeration.
    490            * @param  NewState: new state of the DMA Request sources.
    491            *   This parameter can be: ENABLE or DISABLE.
    492            * @retval None
    493            */

   \                                 In section .near_func.text, align 1, keep-with-next
    494          void TIM2_DMACmd( TIM2_DMASource_TypeDef TIM2_DMASource, FunctionalState NewState)
    495          {
    496            /* Check the parameters */
    497            assert_param(IS_FUNCTIONAL_STATE(NewState));
    498            assert_param(IS_TIM2_DMA_SOURCE(TIM2_DMASource));
    499          
    500            if (NewState != DISABLE)
   \                     TIM2_DMACmd:
   \   000000 3D00                  TNZ       S:?b0
   \   000002 2707                  JREQ      L:??TIM2_DMACmd_0
    501            {
    502              /* Enable the DMA sources */
    503              TIM2->DER |= (uint8_t)TIM2_DMASource;
   \   000004 CA5254                OR        A, L:0x5254
   \   000007 C75254                LD        L:0x5254, A
   \   00000A 81                    RET
    504            }
    505            else
    506            {
    507              /* Disable the DMA sources */
    508              TIM2->DER &= (uint8_t)(~TIM2_DMASource);
   \                     ??TIM2_DMACmd_0:
   \   00000B 43                    CPL       A
   \   00000C C45254                AND       A, L:0x5254
   \   00000F C75254                LD        L:0x5254, A
    509            }
    510          }
   \   000012 81                    RET
    511          
    512          /**
    513            * @brief  Enables the TIM2 internal Clock.
    514            * @par Parameters:
    515            * None
    516            * @retval None
    517            */

   \                                 In section .near_func.text, align 1, keep-with-next
    518          void TIM2_InternalClockConfig(void)
    519          {
    520            /* Disable slave mode to clock the prescaler directly with the internal clock */
    521            TIM2->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
   \                     TIM2_InternalClockConfig:
   \   000000 C65252                LD        A, L:0x5252
   \   000003 A4F8                  AND       A, #0xf8
   \   000005 C75252                LD        L:0x5252, A
    522          }
   \   000008 81                    RET
    523          
    524          /**
    525            * @brief  Configures the TIM2 External clock Mode1.
    526            * @param  TIM2_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    527            *   This parameter can be one of @ref TIM2_ExtTRGPSC_TypeDef enumeration.
    528            * @param  TIM2_ExtTRGPolarity : Specifies the external Trigger Polarity.
    529            *   This parameter can be one of @ref TIM2_ExtTRGPolarity_TypeDef enumeration.
    530            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    531            *   This parameter must be a value between 0x00 and 0x0F
    532            * @retval None
    533            */

   \                                 In section .near_func.text, align 1, keep-with-next
    534          void TIM2_ETRClockMode1Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
    535                                        TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
    536                                        uint8_t ExtTRGFilter)
    537          {
    538            /* Configure the ETR Clock source */
    539            TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM2_ETRClockMode1Config:
   \   000000 CD0000                CALL      L:TIM2_ETRConfig
    540          
    541            /* Select the External clock mode1 */
    542            TIM2->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
   \   000003 C65252                LD        A, L:0x5252
   \   000006 A4F8                  AND       A, #0xf8
   \   000008 C75252                LD        L:0x5252, A
    543            TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
   \   00000B C65252                LD        A, L:0x5252
   \   00000E AA07                  OR        A, #0x7
   \   000010 C75252                LD        L:0x5252, A
    544          
    545            /* Select the Trigger selection : ETRF */
    546            TIM2->SMCR &= (uint8_t)(~TIM_SMCR_TS);
   \   000013 C65252                LD        A, L:0x5252
   \   000016 A48F                  AND       A, #0x8f
   \   000018 C75252                LD        L:0x5252, A
    547            TIM2->SMCR |= (uint8_t)((TIM2_TRGSelection_TypeDef)TIM2_TRGSelection_ETRF);
   \   00001B C65252                LD        A, L:0x5252
   \   00001E AA70                  OR        A, #0x70
   \   000020 C75252                LD        L:0x5252, A
    548          }
   \   000023 81                    RET
    549          
    550          /**
    551            * @brief  Configures the TIM2 External clock Mode2.
    552            * @param  TIM2_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    553            *   This parameter can be one of the @ref TIM2_ExtTRGPSC_TypeDef enumeration.
    554            * @param  TIM2_ExtTRGPolarity : Specifies the external Trigger Polarity.
    555            *   This parameter can be one of the @ref TIM2_ExtTRGPolarity_TypeDef enumeration.
    556            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    557            *   This parameter must be a value between 0x00 and 0x0F
    558            * @retval None
    559            */

   \                                 In section .near_func.text, align 1, keep-with-next
    560          void TIM2_ETRClockMode2Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
    561                                        TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
    562                                        uint8_t ExtTRGFilter)
    563          {
    564            /* Configure the ETR Clock source */
    565            TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM2_ETRClockMode2Config:
   \   000000 CD0000                CALL      L:TIM2_ETRConfig
    566          
    567            /* Enable the External clock mode2 */
    568            TIM2->ETR |= TIM_ETR_ECE ;
   \   000003 721C5253              BSET      L:0x5253, #0x6
    569          }
   \   000007 81                    RET
    570          
    571          /**
    572            * @brief  Configures the TIM2 External Trigger.
    573            * @param  TIM2_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    574            *   This parameter can be one of the @ref TIM2_ExtTRGPSC_TypeDef enumeration.
    575            * @param  TIM2_ExtTRGPolarity : Specifies the external Trigger Polarity.
    576            *   This parameter can be one of the @ref TIM2_ExtTRGPolarity_TypeDef enumeration.
    577            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    578            *   This parameter must be a value between 0x00 and 0x0F
    579            * @retval None
    580            */

   \                                 In section .near_func.text, align 1, keep-with-next
    581          void TIM2_ETRConfig(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
    582                              TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
    583                              uint8_t ExtTRGFilter)
    584          {
   \                     TIM2_ETRConfig:
   \   000000 B700                  LD        S:?b2, A
   \   000002 B600                  LD        A, S:?b0
    585            /* Check the parameters */
    586            assert_param(IS_TIM2_EXT_PRESCALER(TIM2_ExtTRGPrescaler));
    587            assert_param(IS_TIM2_EXT_POLARITY(TIM2_ExtTRGPolarity));
    588            assert_param(IS_TIM2_EXT_FILTER(ExtTRGFilter));
    589            /* Set the Prescaler, the Filter value and the Polarity */
    590            TIM2->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM2_ExtTRGPrescaler | \
    591                                             (uint8_t)TIM2_ExtTRGPolarity ) | (uint8_t)ExtTRGFilter);
   \   000004 BA00                  OR        A, S:?b2
   \   000006 BA00                  OR        A, S:?b1
   \   000008 CA5253                OR        A, L:0x5253
   \   00000B C75253                LD        L:0x5253, A
    592          }
   \   00000E 81                    RET
    593          
    594          /**
    595            * @brief  Configures the TIM2 Trigger as External Clock.
    596            * @param  TIM2_TIxExternalCLKSource : Specifies Trigger source.
    597            *   This parameter can be one of the @ref TIM2_TIxExternalCLK1Source_TypeDef enumeration.
    598            * @param  TIM2_ICPolarity : Specifies the TIx Polarity.
    599            *   This parameter can be @ref TIM2_ICPolarity_TypeDef enumeration.
    600            * @param  ICFilter : Specifies the filter value.
    601            *   This parameter must be a value between 0x00 and 0x0F
    602            * @retval None
    603            */

   \                                 In section .near_func.text, align 1, keep-with-next
    604          void TIM2_TIxExternalClockConfig(TIM2_TIxExternalCLK1Source_TypeDef TIM2_TIxExternalCLKSource,
    605                                           TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
    606                                           uint8_t ICFilter)
    607          {
   \                     TIM2_TIxExternalClockConfig:
   \   000000 B700                  LD        S:?b4, A
   \   000002 450000                MOV       S:?b2, S:?b0
    608            /* Check the parameters */
    609            assert_param(IS_TIM2_TIXCLK_SOURCE(TIM2_TIxExternalCLKSource));
    610            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
    611            assert_param(IS_TIM2_IC_FILTER(ICFilter));
    612          
    613            /* Configure the TIM2 Input Clock Source */
    614            if (TIM2_TIxExternalCLKSource == TIM2_TIxExternalCLK1Source_TI2)
   \   000005 B600                  LD        A, S:?b4
   \   000007 A160                  CP        A, #0x60
   \   000009 260B                  JRNE      L:??TIM2_TIxExternalClockConfig_0
    615            {
    616              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, ICFilter);
   \   00000B 35010000              MOV       S:?b0, #0x1
   \   00000F B600                  LD        A, S:?b2
   \   000011 CD0000                CALL      L:TI2_Config
   \   000014 2009                  JRA       L:??TIM2_TIxExternalClockConfig_1
    617            }
    618            else
    619            {
    620              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, ICFilter);
   \                     ??TIM2_TIxExternalClockConfig_0:
   \   000016 35010000              MOV       S:?b0, #0x1
   \   00001A B600                  LD        A, S:?b2
   \   00001C CD0000                CALL      L:TI1_Config
    621            }
    622          
    623            /* Select the Trigger source */
    624            TIM2_SelectInputTrigger((TIM2_TRGSelection_TypeDef)TIM2_TIxExternalCLKSource);
   \                     ??TIM2_TIxExternalClockConfig_1:
   \   00001F B600                  LD        A, S:?b4
   \   000021 CD0000                CALL      L:TIM2_SelectInputTrigger
    625          
    626            /* Select the External clock mode1 */
    627            TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
   \   000024 C65252                LD        A, L:0x5252
   \   000027 AA07                  OR        A, #0x7
   \   000029 C75252                LD        L:0x5252, A
    628          }
   \   00002C 81                    RET
    629          
    630          /**
    631            * @brief  Selects the TIM2 Input Trigger source.
    632            * @param  TIM2_InputTriggerSource : Specifies Input Trigger source.
    633            *   This parameter can be one of the @ref TIM2_TRGSelection_TypeDef enumeration.
    634            * @retval None
    635            */

   \                                 In section .near_func.text, align 1, keep-with-next
    636          void TIM2_SelectInputTrigger(TIM2_TRGSelection_TypeDef TIM2_InputTriggerSource)
    637          {
   \                     TIM2_SelectInputTrigger:
   \   000000 B700                  LD        S:?b0, A
    638            uint8_t tmpsmcr = 0;
   \   000002 3F00                  CLR       S:?b1
    639          
    640            /* Check the parameters */
    641            assert_param(IS_TIM2_TRIGGER_SELECTION(TIM2_InputTriggerSource));
    642          
    643            tmpsmcr = TIM2->SMCR;
   \   000004 C65252                LD        A, L:0x5252
   \   000007 B700                  LD        S:?b1, A
    644          
    645            /* Select the Tgigger Source */
    646            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    647            tmpsmcr |= (uint8_t)TIM2_InputTriggerSource;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    648          
    649            TIM2->SMCR = (uint8_t)tmpsmcr;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75252                LD        L:0x5252, A
    650          }
   \   00001A 81                    RET
    651          
    652          /**
    653            * @brief  Enables or Disables the TIM2 Update event.
    654            * @param  NewState : The new state of the TIM2 peripheral Preload register.
    655            *   This parameter can be any of the @ref FunctionalState enumeration.
    656            * @retval None
    657            */
    658          

   \                                 In section .near_func.text, align 1, keep-with-next
    659          void TIM2_UpdateDisableConfig(FunctionalState NewState)
    660          {
    661            /* Check the parameters */
    662            assert_param(IS_FUNCTIONAL_STATE(NewState));
    663          
    664            /* Set or Reset the UDIS Bit */
    665            if (NewState != DISABLE)
   \                     TIM2_UpdateDisableConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_UpdateDisableConfig_0
    666            {
    667              TIM2->CR1 |= TIM_CR1_UDIS;
   \   000003 72125250              BSET      L:0x5250, #0x1
   \   000007 81                    RET
    668            }
    669            else
    670            {
    671              TIM2->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
   \                     ??TIM2_UpdateDisableConfig_0:
   \   000008 72135250              BRES      L:0x5250, #0x1
    672            }
    673          }
   \   00000C 81                    RET
    674          
    675          /**
    676            * @brief  Selects the TIM2 Update Request Interrupt source.
    677            * @param  TIM2_UpdateSource : Specifies the Update source.
    678            *   This parameter can be one of the @ref TIM2_UpdateSource_TypeDef enumeration.
    679            * @retval None
    680            */

   \                                 In section .near_func.text, align 1, keep-with-next
    681          void TIM2_UpdateRequestConfig(TIM2_UpdateSource_TypeDef TIM2_UpdateSource)
    682          {
    683            /* Check the parameters */
    684            assert_param(IS_TIM2_UPDATE_SOURCE(TIM2_UpdateSource));
    685          
    686            /* Set or Reset the URS Bit */
    687            if (TIM2_UpdateSource == TIM2_UpdateSource_Regular)
   \                     TIM2_UpdateRequestConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM2_UpdateRequestConfig_0
    688            {
    689              TIM2->CR1 |= TIM_CR1_URS ;
   \   000004 72145250              BSET      L:0x5250, #0x2
   \   000008 81                    RET
    690            }
    691            else
    692            {
    693              TIM2->CR1 &= (uint8_t)(~TIM_CR1_URS);
   \                     ??TIM2_UpdateRequestConfig_0:
   \   000009 72155250              BRES      L:0x5250, #0x2
    694            }
    695          }
   \   00000D 81                    RET
    696          
    697          /**
    698            * @brief  Enables or Disables the TIMs Hall sensor interface.
    699            * @param  NewState : The new state of the TIM2 Hall sensor interface.
    700            *   This parameter can be any of the @ref FunctionalState enumeration.
    701            * @retval None
    702            */

   \                                 In section .near_func.text, align 1, keep-with-next
    703          void TIM2_SelectHallSensor(FunctionalState NewState)
    704          {
    705            /* Check the parameters */
    706            assert_param(IS_FUNCTIONAL_STATE(NewState));
    707          
    708            /* Set or Reset the TI1S Bit */
    709            if (NewState != DISABLE)
   \                     TIM2_SelectHallSensor:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_SelectHallSensor_0
    710            {
    711              TIM2->CR2 |= TIM_CR2_TI1S;
   \   000003 721E5251              BSET      L:0x5251, #0x7
   \   000007 81                    RET
    712            }
    713            else
    714            {
    715              TIM2->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
   \                     ??TIM2_SelectHallSensor_0:
   \   000008 721F5251              BRES      L:0x5251, #0x7
    716            }
    717          }
   \   00000C 81                    RET
    718          
    719          /**
    720            * @brief  Selects the TIMs One Pulse Mode.
    721            * @param  TIM2_OPMode : Specifies the OPM Mode to be used.
    722            *   This parameter can be one of the @ref TIM2_OPMode_TypeDef enumeration.
    723            * @retval None
    724            */

   \                                 In section .near_func.text, align 1, keep-with-next
    725          void TIM2_SelectOnePulseMode(TIM2_OPMode_TypeDef TIM2_OPMode)
    726          {
    727            /* Check the parameters */
    728            assert_param(IS_TIM2_OPM_MODE(TIM2_OPMode));
    729          
    730            /* Set or Reset the OPM Bit */
    731            if (TIM2_OPMode == TIM2_OPMode_Single)
   \                     TIM2_SelectOnePulseMode:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM2_SelectOnePulseMode_0
    732            {
    733              TIM2->CR1 |= TIM_CR1_OPM ;
   \   000004 72165250              BSET      L:0x5250, #0x3
   \   000008 81                    RET
    734            }
    735            else
    736            {
    737              TIM2->CR1 &= (uint8_t)(~TIM_CR1_OPM);
   \                     ??TIM2_SelectOnePulseMode_0:
   \   000009 72175250              BRES      L:0x5250, #0x3
    738            }
    739          }
   \   00000D 81                    RET
    740          
    741          /**
    742            * @brief  Selects the TIM2 Trigger Output Mode.
    743            * @param  TIM2_TRGOSource : Specifies the Trigger Output source.
    744            *   This parameter can be one of the @ref TIM2_TRGOSource_TypeDef enumeration.
    745            * @retval None
    746            */

   \                                 In section .near_func.text, align 1, keep-with-next
    747          void TIM2_SelectOutputTrigger(TIM2_TRGOSource_TypeDef TIM2_TRGOSource)
    748          {
   \                     TIM2_SelectOutputTrigger:
   \   000000 B700                  LD        S:?b0, A
    749            uint8_t tmpcr2 = 0;
   \   000002 3F00                  CLR       S:?b1
    750          
    751            /* Check the parameters */
    752            assert_param(IS_TIM2_TRGO_SOURCE(TIM2_TRGOSource));
    753          
    754            tmpcr2 = TIM2->CR2;
   \   000004 C65251                LD        A, L:0x5251
   \   000007 B700                  LD        S:?b1, A
    755          
    756            /* Reset the MMS Bits */
    757            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    758          
    759            /* Select the TRGO source */
    760            tmpcr2 |=  (uint8_t)TIM2_TRGOSource;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    761          
    762            TIM2->CR2 = tmpcr2;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75251                LD        L:0x5251, A
    763          }
   \   00001A 81                    RET
    764          
    765          /**
    766            * @brief  Selects the TIM2 Slave Mode.
    767            * @param  TIM2_SlaveMode : Specifies the TIM2 Slave Mode.
    768            *   This parameter can be one of the @ref TIM2_SlaveMode_TypeDef enumeration.
    769            * @retval None
    770            */

   \                                 In section .near_func.text, align 1, keep-with-next
    771          void TIM2_SelectSlaveMode(TIM2_SlaveMode_TypeDef TIM2_SlaveMode)
    772          {
   \                     TIM2_SelectSlaveMode:
   \   000000 B700                  LD        S:?b0, A
    773            uint8_t tmpsmcr = 0;
   \   000002 3F00                  CLR       S:?b1
    774          
    775            /* Check the parameters */
    776            assert_param(IS_TIM2_SLAVE_MODE(TIM2_SlaveMode));
    777          
    778            tmpsmcr = TIM2->SMCR;
   \   000004 C65252                LD        A, L:0x5252
   \   000007 B700                  LD        S:?b1, A
    779          
    780            /* Reset the SMS Bits */
    781            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A4F8                  AND       A, #0xf8
   \   00000D B700                  LD        S:?b1, A
    782          
    783            /* Select the Slave Mode */
    784            tmpsmcr |= (uint8_t)TIM2_SlaveMode;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    785          
    786            TIM2->SMCR = tmpsmcr;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75252                LD        L:0x5252, A
    787          }
   \   00001A 81                    RET
    788          
    789          /**
    790            * @brief  Sets or Resets the TIM2 Master/Slave Mode.
    791            * @param  NewState : The new state of the synchronization between TIM2 and its slaves (through TRGO).
    792            *   This parameter can be any of the @ref FunctionalState enumeration.
    793            * @retval None
    794            */

   \                                 In section .near_func.text, align 1, keep-with-next
    795          void TIM2_SelectMasterSlaveMode(FunctionalState NewState)
    796          {
    797            /* Check the parameters */
    798            assert_param(IS_FUNCTIONAL_STATE(NewState));
    799          
    800            /* Set or Reset the MSM Bit */
    801            if (NewState != DISABLE)
   \                     TIM2_SelectMasterSlaveMode:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_SelectMasterSlaveMode_0
    802            {
    803              TIM2->SMCR |= TIM_SMCR_MSM;
   \   000003 721E5252              BSET      L:0x5252, #0x7
   \   000007 81                    RET
    804            }
    805            else
    806            {
    807              TIM2->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
   \                     ??TIM2_SelectMasterSlaveMode_0:
   \   000008 721F5252              BRES      L:0x5252, #0x7
    808            }
    809          }
   \   00000C 81                    RET
    810          
    811          /**
    812            * @brief  Configures the TIM2 Encoder Interface.
    813            * @param  TIM2_EncoderMode : Specifies the TIM2 Encoder Mode.
    814            *   This parameter can be one of the @ref TIM2_EncoderMode_TypeDef enumeration.
    815            * @param  TIM2_IC1Polarity : Specifies the IC1 Polarity.
    816            *   This parameter can be one of the @ref TIM2_ICPolarity_TypeDef enumeration.
    817            * @param  TIM2_IC2Polarity : Specifies the IC2 Polarity.
    818            *   This parameter can be one of the @ref TIM2_ICPolarity_TypeDef enumeration.
    819            * @retval None
    820            */

   \                                 In section .near_func.text, align 1, keep-with-next
    821          void TIM2_EncoderInterfaceConfig(TIM2_EncoderMode_TypeDef TIM2_EncoderMode,
    822                                           TIM2_ICPolarity_TypeDef TIM2_IC1Polarity,
    823                                           TIM2_ICPolarity_TypeDef TIM2_IC2Polarity)
    824          {
   \                     TIM2_EncoderInterfaceConfig:
   \   000000 B700                  LD        S:?b4, A
    825            uint8_t tmpsmcr = 0;
   \   000002 3F00                  CLR       S:?b5
    826            uint8_t tmpccmr1 = 0;
   \   000004 3F00                  CLR       S:?b2
    827            uint8_t tmpccmr2 = 0;
   \   000006 3F00                  CLR       S:?b3
    828          
    829            /* Check the parameters */
    830            assert_param(IS_TIM2_ENCODER_MODE(TIM2_EncoderMode));
    831            assert_param(IS_TIM2_IC_POLARITY(TIM2_IC1Polarity));
    832            assert_param(IS_TIM2_IC_POLARITY(TIM2_IC2Polarity));
    833          
    834            tmpsmcr = TIM2->SMCR;
   \   000008 C65252                LD        A, L:0x5252
   \   00000B B700                  LD        S:?b5, A
    835            tmpccmr1 = TIM2->CCMR1;
   \   00000D C65259                LD        A, L:0x5259
   \   000010 B700                  LD        S:?b2, A
    836            tmpccmr2 = TIM2->CCMR2;
   \   000012 C6525A                LD        A, L:0x525a
   \   000015 B700                  LD        S:?b3, A
    837          
    838            /* Set the encoder Mode */
    839            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
   \   000017 B600                  LD        A, S:?b5
   \   000019 A4F0                  AND       A, #0xf0
   \   00001B B700                  LD        S:?b5, A
    840            tmpsmcr |= (uint8_t)TIM2_EncoderMode;
   \   00001D B600                  LD        A, S:?b4
   \   00001F BA00                  OR        A, S:?b5
   \   000021 B700                  LD        S:?b5, A
    841          
    842            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
    843            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000023 B600                  LD        A, S:?b2
   \   000025 A4FC                  AND       A, #0xfc
   \   000027 B700                  LD        S:?b2, A
    844            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000029 B600                  LD        A, S:?b3
   \   00002B A4FC                  AND       A, #0xfc
   \   00002D B700                  LD        S:?b3, A
    845            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
   \   00002F B600                  LD        A, S:?b2
   \   000031 AA01                  OR        A, #0x1
   \   000033 B700                  LD        S:?b2, A
    846            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
   \   000035 B600                  LD        A, S:?b3
   \   000037 AA01                  OR        A, #0x1
   \   000039 B700                  LD        S:?b3, A
    847          
    848            /* Set the TI1 and the TI2 Polarities */
    849            if (TIM2_IC1Polarity == TIM2_ICPolarity_Falling)
   \   00003B B600                  LD        A, S:?b0
   \   00003D A101                  CP        A, #0x1
   \   00003F 2606                  JRNE      L:??TIM2_EncoderInterfaceConfig_0
    850            {
    851              TIM2->CCER1 |= TIM_CCER1_CC1P ;
   \   000041 7212525B              BSET      L:0x525b, #0x1
   \   000045 2004                  JRA       L:??TIM2_EncoderInterfaceConfig_1
    852            }
    853            else
    854            {
    855              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM2_EncoderInterfaceConfig_0:
   \   000047 7213525B              BRES      L:0x525b, #0x1
    856            }
    857          
    858            if (TIM2_IC2Polarity == TIM2_ICPolarity_Falling)
   \                     ??TIM2_EncoderInterfaceConfig_1:
   \   00004B B600                  LD        A, S:?b1
   \   00004D A101                  CP        A, #0x1
   \   00004F 2606                  JRNE      L:??TIM2_EncoderInterfaceConfig_2
    859            {
    860              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   \   000051 721A525B              BSET      L:0x525b, #0x5
   \   000055 2004                  JRA       L:??TIM2_EncoderInterfaceConfig_3
    861            }
    862            else
    863            {
    864              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM2_EncoderInterfaceConfig_2:
   \   000057 721B525B              BRES      L:0x525b, #0x5
    865            }
    866          
    867            TIM2->SMCR = tmpsmcr;
   \                     ??TIM2_EncoderInterfaceConfig_3:
   \   00005B B600                  LD        A, S:?b5
   \   00005D C75252                LD        L:0x5252, A
    868            TIM2->CCMR1 = tmpccmr1;
   \   000060 B600                  LD        A, S:?b2
   \   000062 C75259                LD        L:0x5259, A
    869            TIM2->CCMR2 = tmpccmr2;
   \   000065 B600                  LD        A, S:?b3
   \   000067 C7525A                LD        L:0x525a, A
    870          }
   \   00006A 81                    RET
    871          
    872          /**
    873            * @brief  Configures the TIM2 Prescaler.
    874            * @param  Prescaler : Specifies the Prescaler Register value
    875            *   This parameter can be one of the @ref TIM2_Prescaler_TypeDef enumeration.
    876            * @param  TIM2_PSCReloadMode : Specifies the TIM2 Prescaler Reload mode.
    877            *   This parameter can be one of the @ref TIM2_PSCReloadMode_TypeDef enumeration.
    878            * @retval None
    879            */

   \                                 In section .near_func.text, align 1, keep-with-next
    880          void TIM2_PrescalerConfig(TIM2_Prescaler_TypeDef Prescaler,
    881                                    TIM2_PSCReloadMode_TypeDef TIM2_PSCReloadMode)
    882          {
    883            /* Check the parameters */
    884            assert_param(IS_TIM2_PRESCALER(Prescaler));
    885            assert_param(IS_TIM2_PRESCALER_RELOAD(TIM2_PSCReloadMode));
    886          
    887            /* Set the Prescaler value */
    888            TIM2->PSCR = (uint8_t)(Prescaler);
   \                     TIM2_PrescalerConfig:
   \   000000 C7525E                LD        L:0x525e, A
    889          
    890            /* Set or reset the UG Bit */
    891            if (TIM2_PSCReloadMode == TIM2_PSCReloadMode_Immediate)
   \   000003 B600                  LD        A, S:?b0
   \   000005 A101                  CP        A, #0x1
   \   000007 2605                  JRNE      L:??TIM2_PrescalerConfig_0
    892            {
    893              TIM2->EGR |= TIM_EGR_UG ;
   \   000009 72105258              BSET      L:0x5258, #0x0
   \   00000D 81                    RET
    894            }
    895            else
    896            {
    897              TIM2->EGR &= (uint8_t)(~TIM_EGR_UG) ;
   \                     ??TIM2_PrescalerConfig_0:
   \   00000E 72115258              BRES      L:0x5258, #0x0
    898            }
    899          }
   \   000012 81                    RET
    900          
    901          /**
    902            * @brief  Specifies the TIM2 Counter Mode to be used.
    903            * @param  TIM2_CounterMode : Specifies the Counter Mode to be used
    904            *   This parameter can be one of the @ref TIM2_CounterMode_TypeDef enumeration.
    905            * @retval None
    906            */

   \                                 In section .near_func.text, align 1, keep-with-next
    907          void TIM2_CounterModeConfig(TIM2_CounterMode_TypeDef TIM2_CounterMode)
    908          {
   \                     TIM2_CounterModeConfig:
   \   000000 B700                  LD        S:?b0, A
    909            uint8_t tmpcr1 = 0;
   \   000002 3F00                  CLR       S:?b1
    910          
    911            /* Check the parameters */
    912            assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
    913          
    914            tmpcr1 = TIM2->CR1;
   \   000004 C65250                LD        A, L:0x5250
   \   000007 B700                  LD        S:?b1, A
    915          
    916            /* Reset the CMS and DIR Bits */
    917            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    918          
    919            /* Set the Counter Mode */
    920            tmpcr1 |= (uint8_t)TIM2_CounterMode;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    921          
    922            TIM2->CR1 = tmpcr1;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75250                LD        L:0x5250, A
    923          }
   \   00001A 81                    RET
    924          
    925          /**
    926            * @brief  Forces the TIM2 Channel1 output waveform to active or inactive level.
    927            * @param  TIM2_ForcedAction : Specifies the forced Action to be set to the output waveform.
    928            *   This parameter can be one of the @ref TIM2_ForcedAction_TypeDef enumeration.
    929            * @retval None
    930            */

   \                                 In section .near_func.text, align 1, keep-with-next
    931          void TIM2_ForcedOC1Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction)
    932          {
   \                     TIM2_ForcedOC1Config:
   \   000000 B700                  LD        S:?b0, A
    933            uint8_t tmpccmr1 = 0;
   \   000002 3F00                  CLR       S:?b1
    934          
    935            /* Check the parameters */
    936            assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
    937          
    938            tmpccmr1 = TIM2->CCMR1;
   \   000004 C65259                LD        A, L:0x5259
   \   000007 B700                  LD        S:?b1, A
    939          
    940            /* Reset the OCM Bits */
    941            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    942          
    943            /* Configure The Forced output Mode */
    944            tmpccmr1 |= (uint8_t)TIM2_ForcedAction;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    945          
    946            TIM2->CCMR1 = tmpccmr1;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75259                LD        L:0x5259, A
    947          }
   \   00001A 81                    RET
    948          
    949          /**
    950            * @brief  Forces the TIM2 Channel2 output waveform to active or inactive level.
    951            * @param  TIM2_ForcedAction : Specifies the forced Action to be set to the output waveform.
    952            *   This parameter can be one of the @ref TIM2_ForcedAction_TypeDef enumeration.
    953            * @retval None
    954            */

   \                                 In section .near_func.text, align 1, keep-with-next
    955          void TIM2_ForcedOC2Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction)
    956          {
   \                     TIM2_ForcedOC2Config:
   \   000000 B700                  LD        S:?b0, A
    957            uint8_t tmpccmr2 = 0;
   \   000002 3F00                  CLR       S:?b1
    958          
    959            /* Check the parameters */
    960            assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
    961          
    962            tmpccmr2 = TIM2->CCMR2;
   \   000004 C6525A                LD        A, L:0x525a
   \   000007 B700                  LD        S:?b1, A
    963          
    964            /* Reset the OCM Bits */
    965            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    966          
    967            /* Configure The Forced output Mode */
    968            tmpccmr2 |= (uint8_t)TIM2_ForcedAction;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    969          
    970            TIM2->CCMR2 = tmpccmr2;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C7525A                LD        L:0x525a, A
    971          }
   \   00001A 81                    RET
    972          
    973          /**
    974            * @brief  Enables or disables TIM2 peripheral Preload register on ARR.
    975            * @param  NewState : The new state of the TIM2 peripheral Preload register.
    976            *   This parameter can be any of the @ref FunctionalState enumeration.
    977            * @retval None
    978            */

   \                                 In section .near_func.text, align 1, keep-with-next
    979          void TIM2_ARRPreloadConfig(FunctionalState NewState)
    980          {
    981            /* Check the parameters */
    982            assert_param(IS_FUNCTIONAL_STATE(NewState));
    983          
    984            /* Set or Reset the ARPE Bit */
    985            if (NewState != DISABLE)
   \                     TIM2_ARRPreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_ARRPreloadConfig_0
    986            {
    987              TIM2->CR1 |= TIM_CR1_ARPE;
   \   000003 721E5250              BSET      L:0x5250, #0x7
   \   000007 81                    RET
    988            }
    989            else
    990            {
    991              TIM2->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
   \                     ??TIM2_ARRPreloadConfig_0:
   \   000008 721F5250              BRES      L:0x5250, #0x7
    992            }
    993          }
   \   00000C 81                    RET
    994          
    995          /**
    996            * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR1.
    997            * @param  NewState : The new state of the Capture Compare Preload register.
    998            *   This parameter can be any of the @ref FunctionalState enumeration.
    999            * @retval None
   1000            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1001          void TIM2_OC1PreloadConfig(FunctionalState NewState)
   1002          {
   1003            /* Check the parameters */
   1004            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1005          
   1006            /* Set or Reset the OC1PE Bit */
   1007            if (NewState != DISABLE)
   \                     TIM2_OC1PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_OC1PreloadConfig_0
   1008            {
   1009              TIM2->CCMR1 |= TIM_CCMR_OCxPE ;
   \   000003 72165259              BSET      L:0x5259, #0x3
   \   000007 81                    RET
   1010            }
   1011            else
   1012            {
   1013              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM2_OC1PreloadConfig_0:
   \   000008 72175259              BRES      L:0x5259, #0x3
   1014            }
   1015          }
   \   00000C 81                    RET
   1016          
   1017          /**
   1018            * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR2.
   1019            * @param  NewState : The new state of the Capture Compare Preload register.
   1020            *   This parameter can be any of the @ref FunctionalState enumeration.
   1021            * @retval None
   1022            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1023          void TIM2_OC2PreloadConfig(FunctionalState NewState)
   1024          {
   1025            /* Check the parameters */
   1026            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1027          
   1028            /* Set or Reset the OC2PE Bit */
   1029            if (NewState != DISABLE)
   \                     TIM2_OC2PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_OC2PreloadConfig_0
   1030            {
   1031              TIM2->CCMR2 |= TIM_CCMR_OCxPE ;
   \   000003 7216525A              BSET      L:0x525a, #0x3
   \   000007 81                    RET
   1032            }
   1033            else
   1034            {
   1035              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM2_OC2PreloadConfig_0:
   \   000008 7217525A              BRES      L:0x525a, #0x3
   1036            }
   1037          }
   \   00000C 81                    RET
   1038          
   1039          /**
   1040            * @brief  Configures the TIM2 Capture Compare 1 Fast feature.
   1041            * @param  NewState : The new state of the Output Compare Fast Enable bit.
   1042            *   This parameter can be any of the @ref FunctionalState enumeration.
   1043            * @retval None
   1044            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1045          void TIM2_OC1FastCmd(FunctionalState NewState)
   1046          {
   1047            /* Check the parameters */
   1048            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1049          
   1050            /* Set or Reset the OC1FE Bit */
   1051            if (NewState != DISABLE)
   \                     TIM2_OC1FastCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_OC1FastCmd_0
   1052            {
   1053              TIM2->CCMR1 |= TIM_CCMR_OCxFE ;
   \   000003 72145259              BSET      L:0x5259, #0x2
   \   000007 81                    RET
   1054            }
   1055            else
   1056            {
   1057              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM2_OC1FastCmd_0:
   \   000008 72155259              BRES      L:0x5259, #0x2
   1058            }
   1059          }
   \   00000C 81                    RET
   1060          
   1061          /**
   1062            * @brief  Configures the TIM2 Capture Compare 2 Fast feature.
   1063            * @param  NewState : The new state of the Output Compare Fast Enable bit.
   1064            *   This parameter can be any of the @ref FunctionalState enumeration.
   1065            * @retval None
   1066            */
   1067          

   \                                 In section .near_func.text, align 1, keep-with-next
   1068          void TIM2_OC2FastCmd(FunctionalState NewState)
   1069          {
   1070            /* Check the parameters */
   1071            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1072          
   1073            /* Set or Reset the OC2FE Bit */
   1074            if (NewState != DISABLE)
   \                     TIM2_OC2FastCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_OC2FastCmd_0
   1075            {
   1076              TIM2->CCMR2 |= TIM_CCMR_OCxFE ;
   \   000003 7214525A              BSET      L:0x525a, #0x2
   \   000007 81                    RET
   1077            }
   1078            else
   1079            {
   1080              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM2_OC2FastCmd_0:
   \   000008 7215525A              BRES      L:0x525a, #0x2
   1081            }
   1082          }
   \   00000C 81                    RET
   1083          
   1084          /**
   1085            * @brief  Configures the TIM2 event to be generated by software.
   1086            * @param  TIM2_EventSource : Specifies the event source.
   1087            *   This parameter can be one of the @ref TIM2_EventSource_TypeDef enumeration.
   1088            * @retval None
   1089            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1090          void TIM2_GenerateEvent(TIM2_EventSource_TypeDef TIM2_EventSource)
   1091          {
   1092            /* Check the parameters */
   1093            assert_param(IS_TIM2_EVENT_SOURCE((uint8_t)TIM2_EventSource));
   1094          
   1095            /* Set the event sources */
   1096            TIM2->EGR |= (uint8_t)TIM2_EventSource;
   \                     TIM2_GenerateEvent:
   \   000000 CA5258                OR        A, L:0x5258
   \   000003 C75258                LD        L:0x5258, A
   1097          }
   \   000006 81                    RET
   1098          
   1099          /**
   1100            * @brief  Configures the TIM2 Channel 1 polarity.
   1101            * @param  TIM2_OCPolarity : Specifies the OC1 Polarity.
   1102            *   This parameter can be one of the @ref TIM2_OCPolarity_TypeDef enumeration.
   1103            * @retval None
   1104            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1105          void TIM2_OC1PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity)
   1106          {
   1107            /* Check the parameters */
   1108            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
   1109          
   1110            /* Set or Reset the CC1P Bit */
   1111            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     TIM2_OC1PolarityConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM2_OC1PolarityConfig_0
   1112            {
   1113              TIM2->CCER1 |= TIM_CCER1_CC1P ;
   \   000004 7212525B              BSET      L:0x525b, #0x1
   \   000008 81                    RET
   1114            }
   1115            else
   1116            {
   1117              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM2_OC1PolarityConfig_0:
   \   000009 7213525B              BRES      L:0x525b, #0x1
   1118            }
   1119          }
   \   00000D 81                    RET
   1120          
   1121          /**
   1122            * @brief  Configures the TIM2 Channel 2 polarity.
   1123            * @param  TIM2_OCPolarity : Specifies the OC2 Polarity.
   1124            *   This parameter can be one of the @ref TIM2_OCPolarity_TypeDef enumeration.
   1125            * @retval None
   1126            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1127          void TIM2_OC2PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity)
   1128          {
   1129            /* Check the parameters */
   1130            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
   1131          
   1132            /* Set or Reset the CC2P Bit */
   1133            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   \                     TIM2_OC2PolarityConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM2_OC2PolarityConfig_0
   1134            {
   1135              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   \   000004 721A525B              BSET      L:0x525b, #0x5
   \   000008 81                    RET
   1136            }
   1137            else
   1138            {
   1139              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM2_OC2PolarityConfig_0:
   \   000009 721B525B              BRES      L:0x525b, #0x5
   1140            }
   1141          }
   \   00000D 81                    RET
   1142          
   1143          /**
   1144            * @brief  Enables or disables the TIM2 Capture Compare Channel x.
   1145            * @param  TIM2_Channel : Specifies the TIM2 Channel.
   1146            *   This parameter can be one of @ref TIM2_Channel_TypeDef enumeration.
   1147            * @param  NewState : Specifies the TIM2 Channel CCxE bit new state.
   1148            *   This parameter can be any of the @ref FunctionalState enumeration.
   1149            * @retval None
   1150            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1151          void TIM2_CCxCmd(TIM2_Channel_TypeDef TIM2_Channel,
   1152                           FunctionalState NewState)
   1153          {
   1154            /* Check the parameters */
   1155            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1156            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1157          
   1158            if (TIM2_Channel == TIM2_Channel_1)
   \                     TIM2_CCxCmd:
   \   000000 4D                    TNZ       A
   \   000001 260E                  JRNE      L:??TIM2_CCxCmd_0
   1159            {
   1160              /* Set or Reset the CC1E Bit */
   1161              if (NewState != DISABLE)
   \   000003 3D00                  TNZ       S:?b0
   \   000005 2705                  JREQ      L:??TIM2_CCxCmd_1
   1162              {
   1163                TIM2->CCER1 |= TIM_CCER1_CC1E ;
   \   000007 7210525B              BSET      L:0x525b, #0x0
   \   00000B 81                    RET
   1164              }
   1165              else
   1166              {
   1167                TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   \                     ??TIM2_CCxCmd_1:
   \   00000C 7211525B              BRES      L:0x525b, #0x0
   \   000010 81                    RET
   1168              }
   1169          
   1170            }
   1171            else /* if (TIM2_Channel == TIM2_Channel_2) */
   1172            {
   1173              /* Set or Reset the CC2E Bit */
   1174              if (NewState != DISABLE)
   \                     ??TIM2_CCxCmd_0:
   \   000011 3D00                  TNZ       S:?b0
   \   000013 2705                  JREQ      L:??TIM2_CCxCmd_2
   1175              {
   1176                TIM2->CCER1 |= TIM_CCER1_CC2E;
   \   000015 7218525B              BSET      L:0x525b, #0x4
   \   000019 81                    RET
   1177              }
   1178              else
   1179              {
   1180                TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   \                     ??TIM2_CCxCmd_2:
   \   00001A 7219525B              BRES      L:0x525b, #0x4
   1181              }
   1182            }
   1183          }
   \   00001E 81                    RET
   1184          
   1185          /**
   1186            * @brief  Selects the TIM2 Ouput Compare Mode. This function disables the
   1187            * selected channel before changing the Ouput Compare Mode. User has to
   1188            * enable this channel using TIM2_CCxCmd and TIM2_CCxNCmd functions.
   1189            * @param  TIM2_Channel : Specifies the TIM2 Channel.
   1190            *   This parameter can be one of the @ref TIM2_Channel_TypeDef enumeration
   1191            * @param  TIM2_OCMode : Specifies the TIM2 Output Compare Mode.
   1192            *   This parameter can be one of the @ref TIM2_OCMode_TypeDef enumeration.
   1193            * @retval None
   1194            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1195          void TIM2_SelectOCxM(TIM2_Channel_TypeDef TIM2_Channel,
   1196                               TIM2_OCMode_TypeDef TIM2_OCMode)
   1197          {
   1198            /* Check the parameters */
   1199            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1200            assert_param(IS_TIM2_OCM(TIM2_OCMode));
   1201          
   1202            if (TIM2_Channel == TIM2_Channel_1)
   \                     TIM2_SelectOCxM:
   \   000000 4D                    TNZ       A
   \   000001 2615                  JRNE      L:??TIM2_SelectOCxM_0
   1203            {
   1204              /* Disable the Channel 1: Reset the CCE Bit */
   1205              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   000003 7211525B              BRES      L:0x525b, #0x0
   1206          
   1207              /* Reset the Output Compare Bits */
   1208              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000007 C65259                LD        A, L:0x5259
   \   00000A A48F                  AND       A, #0x8f
   \   00000C C75259                LD        L:0x5259, A
   1209          
   1210              /* Set the Ouput Compare Mode */
   1211              TIM2->CCMR1 |= (uint8_t)TIM2_OCMode;
   \   00000F B600                  LD        A, S:?b0
   \   000011 CA5259                OR        A, L:0x5259
   \   000014 C75259                LD        L:0x5259, A
   \   000017 81                    RET
   1212            }
   1213            else /* if (TIM2_Channel == TIM2_Channel_2) */
   1214            {
   1215              /* Disable the Channel 2: Reset the CCE Bit */
   1216              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM2_SelectOCxM_0:
   \   000018 7219525B              BRES      L:0x525b, #0x4
   1217          
   1218              /* Reset the Output Compare Bits */
   1219              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00001C C6525A                LD        A, L:0x525a
   \   00001F A48F                  AND       A, #0x8f
   \   000021 C7525A                LD        L:0x525a, A
   1220          
   1221              /* Set the Ouput Compare Mode */
   1222              TIM2->CCMR2 |= (uint8_t)TIM2_OCMode;
   \   000024 B600                  LD        A, S:?b0
   \   000026 CA525A                OR        A, L:0x525a
   \   000029 C7525A                LD        L:0x525a, A
   1223            }
   1224          }
   \   00002C 81                    RET
   1225          
   1226          /**
   1227            * @brief  Sets the TIM2 Counter Register value.
   1228            * @param  Counter : Specifies the Counter register new value.
   1229            *   This parameter is between 0x0000 and 0xFFFF.
   1230            * @retval None
   1231            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1232          void TIM2_SetCounter(uint16_t Counter)
   1233          {
   \                     TIM2_SetCounter:
   \   000000 9093                  LDW       Y, X
   1234          
   1235            /* Set the Counter Register value */
   1236            TIM2->CNTRH = (uint8_t)(Counter >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C7525C                LD        L:0x525c, A
   1237            TIM2->CNTRL = (uint8_t)(Counter);
   \   000009 909F                  LD        A, YL
   \   00000B C7525D                LD        L:0x525d, A
   1238          }
   \   00000E 81                    RET
   1239          
   1240          /**
   1241            * @brief  Sets the TIM2 Autoreload Register value.
   1242            * @param  Autoreload : Specifies the Autoreload register new value.
   1243            *   This parameter is between 0x0000 and 0xFFFF.
   1244            * @retval None
   1245            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1246          void TIM2_SetAutoreload(uint16_t Autoreload)
   1247          {
   \                     TIM2_SetAutoreload:
   \   000000 9093                  LDW       Y, X
   1248            /* Set the Autoreload Register value */
   1249            TIM2->ARRH = (uint8_t)(Autoreload >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C7525F                LD        L:0x525f, A
   1250            TIM2->ARRL = (uint8_t)(Autoreload);
   \   000009 909F                  LD        A, YL
   \   00000B C75260                LD        L:0x5260, A
   1251          }
   \   00000E 81                    RET
   1252          
   1253          /**
   1254            * @brief  Sets the TIM2 Capture Compare1 Register value.
   1255            * @param  Compare : Specifies the Capture Compare1 register new value.
   1256            *   This parameter is between 0x0000 and 0xFFFF.
   1257            * @retval None
   1258            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1259          void TIM2_SetCompare1(uint16_t Compare)
   1260          {
   \                     TIM2_SetCompare1:
   \   000000 9093                  LDW       Y, X
   1261            /* Set the Capture Compare1 Register value */
   1262            TIM2->CCR1H = (uint8_t)(Compare >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C75261                LD        L:0x5261, A
   1263            TIM2->CCR1L = (uint8_t)(Compare);
   \   000009 909F                  LD        A, YL
   \   00000B C75262                LD        L:0x5262, A
   1264          }
   \   00000E 81                    RET
   1265          
   1266          /**
   1267            * @brief  Sets the TIM2 Capture Compare2 Register value.
   1268            * @param  Compare : Specifies the Capture Compare2 register new value.
   1269            *   This parameter is between 0x0000 and 0xFFFF.
   1270            * @retval None
   1271            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1272          void TIM2_SetCompare2(uint16_t Compare)
   1273          {
   \                     TIM2_SetCompare2:
   \   000000 9093                  LDW       Y, X
   1274            /* Set the Capture Compare2 Register value */
   1275            TIM2->CCR2H = (uint8_t)(Compare >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C75263                LD        L:0x5263, A
   1276            TIM2->CCR2L = (uint8_t)(Compare);
   \   000009 909F                  LD        A, YL
   \   00000B C75264                LD        L:0x5264, A
   1277          }
   \   00000E 81                    RET
   1278          
   1279          /**
   1280            * @brief  Sets the TIM2 Input Capture 1 prescaler.
   1281            * @param  TIM2_IC1Prescaler : Specifies the Input Capture prescaler new value
   1282            *   This parameter can be one of the @ref TIM2_ICPSC_TypeDef enumeration.
   1283            * @retval None
   1284            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1285          void TIM2_SetIC1Prescaler(TIM2_ICPSC_TypeDef TIM2_IC1Prescaler)
   1286          {
   \                     TIM2_SetIC1Prescaler:
   \   000000 B700                  LD        S:?b0, A
   1287            uint8_t tmpccmr1 = 0;
   \   000002 3F00                  CLR       S:?b1
   1288          
   1289            /* Check the parameters */
   1290            assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC1Prescaler));
   1291          
   1292            tmpccmr1 = TIM2->CCMR1;
   \   000004 C65259                LD        A, L:0x5259
   \   000007 B700                  LD        S:?b1, A
   1293          
   1294            /* Reset the IC1PSC Bits */
   1295            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A4F3                  AND       A, #0xf3
   \   00000D B700                  LD        S:?b1, A
   1296          
   1297            /* Set the IC1PSC value */
   1298            tmpccmr1 |= (uint8_t)TIM2_IC1Prescaler;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
   1299          
   1300            TIM2->CCMR1 = tmpccmr1;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75259                LD        L:0x5259, A
   1301          }
   \   00001A 81                    RET
   1302          
   1303          /**
   1304            * @brief  Sets the TIM2 Input Capture 2 prescaler.
   1305            * @param  TIM2_IC2Prescaler : Specifies the Input Capture prescaler new value
   1306            *   This parameter can be one of the @ref TIM2_ICPSC_TypeDef enumeration.
   1307            * @retval None
   1308            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1309          void TIM2_SetIC2Prescaler(TIM2_ICPSC_TypeDef TIM2_IC2Prescaler)
   1310          {
   \                     TIM2_SetIC2Prescaler:
   \   000000 B700                  LD        S:?b0, A
   1311            uint8_t tmpccmr2 = 0;
   \   000002 3F00                  CLR       S:?b1
   1312          
   1313            /* Check the parameters */
   1314            assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC2Prescaler));
   1315          
   1316            tmpccmr2 = TIM2->CCMR2;
   \   000004 C6525A                LD        A, L:0x525a
   \   000007 B700                  LD        S:?b1, A
   1317          
   1318            /* Reset the IC2PSC Bits */
   1319            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A4F3                  AND       A, #0xf3
   \   00000D B700                  LD        S:?b1, A
   1320          
   1321            /* Set the IC2PSC value */
   1322            tmpccmr2 |= (uint8_t)TIM2_IC2Prescaler;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
   1323          
   1324            TIM2->CCMR2 = tmpccmr2;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C7525A                LD        L:0x525a, A
   1325          }
   \   00001A 81                    RET
   1326          
   1327          /**
   1328            * @brief  Gets the TIM2 Input Capture 1 value.
   1329            * @param  None
   1330            * @retval Capture Compare 1 Register value.
   1331            */

   \                                 In section .near_func.text, align 1
   1332          uint16_t TIM2_GetCapture1(void)
   1333          {
   1334            uint16_t tmpccr1 = 0;
   \                     TIM2_GetCapture1:
   \   000000 905F                  CLRW      Y
   1335            uint8_t tmpccr1l, tmpccr1h;
   1336          
   1337            tmpccr1h = TIM2->CCR1H;
   \   000002 C65261                LD        A, L:0x5261
   \   000005 B700                  LD        S:?b0, A
   1338            tmpccr1l = TIM2->CCR1L;
   \   000007 C65262                LD        A, L:0x5262
   1339          
   1340            tmpccr1 = (uint16_t)(tmpccr1l);
   \   00000A 5F                    CLRW      X
   \   00000B 97                    LD        XL, A
   \   00000C 9093                  LDW       Y, X
   1341            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   \   00000E 5F                    CLRW      X
   \   00000F 41                    EXG       A, XL
   \   000010 B600                  LD        A, S:?b0
   \   000012 41                    EXG       A, XL
   \   000013 4F                    CLR       A
   \   000014 02                    RLWA      X, A
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 51                    EXGW      X, Y
   \   000018 01                    RRWA      X, A
   \   000019 BA00                  OR        A, S:?b1
   \   00001B 01                    RRWA      X, A
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 01                    RRWA      X, A
   \   00001F 51                    EXGW      X, Y
   1342            /* Get the Capture 1 Register value */
   1343            return ((uint16_t)tmpccr1);
   \   000020 93                    LDW       X, Y
   \   000021 81                    RET
   1344          }
   1345          
   1346          /**
   1347            * @brief  Gets the TIM2 Input Capture 2 value.
   1348            * @param  None
   1349            * @retval Capture Compare 2 Register value.
   1350            */

   \                                 In section .near_func.text, align 1
   1351          uint16_t TIM2_GetCapture2(void)
   1352          {
   1353            uint16_t tmpccr2 = 0;
   \                     TIM2_GetCapture2:
   \   000000 905F                  CLRW      Y
   1354            uint8_t tmpccr2l, tmpccr2h;
   1355          
   1356            tmpccr2h = TIM2->CCR2H;
   \   000002 C65263                LD        A, L:0x5263
   \   000005 B700                  LD        S:?b0, A
   1357            tmpccr2l = TIM2->CCR2L;
   \   000007 C65264                LD        A, L:0x5264
   1358          
   1359            tmpccr2 = (uint16_t)(tmpccr2l);
   \   00000A 5F                    CLRW      X
   \   00000B 97                    LD        XL, A
   \   00000C 9093                  LDW       Y, X
   1360            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   \   00000E 5F                    CLRW      X
   \   00000F 41                    EXG       A, XL
   \   000010 B600                  LD        A, S:?b0
   \   000012 41                    EXG       A, XL
   \   000013 4F                    CLR       A
   \   000014 02                    RLWA      X, A
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 51                    EXGW      X, Y
   \   000018 01                    RRWA      X, A
   \   000019 BA00                  OR        A, S:?b1
   \   00001B 01                    RRWA      X, A
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 01                    RRWA      X, A
   \   00001F 51                    EXGW      X, Y
   1361            /* Get the Capture 2 Register value */
   1362            return ((uint16_t)tmpccr2);
   \   000020 93                    LDW       X, Y
   \   000021 81                    RET
   1363          }
   1364          
   1365          /**
   1366            * @brief  Gets the TIM2 Counter value.
   1367            * @param  None
   1368            * @retval Counter Register value.
   1369            */

   \                                 In section .near_func.text, align 1
   1370          uint16_t TIM2_GetCounter(void)
   1371          {
   1372            uint16_t tmpcnt = 0;
   \                     TIM2_GetCounter:
   \   000000 905F                  CLRW      Y
   1373            uint8_t tmpcntrl, tmpcntrh;
   1374          
   1375            tmpcntrh = TIM2->CNTRH;
   \   000002 C6525C                LD        A, L:0x525c
   \   000005 B700                  LD        S:?b0, A
   1376            tmpcntrl = TIM2->CNTRL;
   \   000007 C6525D                LD        A, L:0x525d
   1377          
   1378            tmpcnt = (uint16_t)(tmpcntrl);
   \   00000A 5F                    CLRW      X
   \   00000B 97                    LD        XL, A
   \   00000C 9093                  LDW       Y, X
   1379            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
   \   00000E 5F                    CLRW      X
   \   00000F 41                    EXG       A, XL
   \   000010 B600                  LD        A, S:?b0
   \   000012 41                    EXG       A, XL
   \   000013 4F                    CLR       A
   \   000014 02                    RLWA      X, A
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 51                    EXGW      X, Y
   \   000018 01                    RRWA      X, A
   \   000019 BA00                  OR        A, S:?b1
   \   00001B 01                    RRWA      X, A
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 01                    RRWA      X, A
   \   00001F 51                    EXGW      X, Y
   1380            /* Get the Counter Register value */
   1381            return ((uint16_t)tmpcnt);
   \   000020 93                    LDW       X, Y
   \   000021 81                    RET
   1382          }
   1383          
   1384          /**
   1385            * @brief  Gets the TIM2 Prescaler value.
   1386            * @param  None
   1387            * @retval TIM2_Prescaler_TypeDef : Prescaler Register value.
   1388            */

   \                                 In section .near_func.text, align 1
   1389          TIM2_Prescaler_TypeDef TIM2_GetPrescaler(void)
   1390          {
   1391            /* Get the Prescaler Register value */
   1392            return ((TIM2_Prescaler_TypeDef)TIM2->PSCR);
   \                     TIM2_GetPrescaler:
   \   000000 C6525E                LD        A, L:0x525e
   \   000003 81                    RET
   1393          }
   1394          
   1395          /**
   1396            * @brief  Selects the TIM2 peripheral Capture Compare DMA source.
   1397            * @param   NewState: new state of the Capture Compare DMA source.
   1398            *   This parameter can be: ENABLE or DISABLE.
   1399            * @retval None
   1400            */

   \                                 In section .near_func.text, align 1
   1401          void TIM2_SelectCCDMA(FunctionalState NewState)
   1402          {
   1403            /* Check the parameters */
   1404            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1405          
   1406            if (NewState != DISABLE)
   \                     TIM2_SelectCCDMA:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM2_SelectCCDMA_0
   1407            {
   1408              /* Set the CCDS Bit */
   1409              TIM2->CR2 |= TIM_CR2_CCDS;
   \   000003 72165251              BSET      L:0x5251, #0x3
   \   000007 81                    RET
   1410            }
   1411            else
   1412            {
   1413              /* Reset the CCDS Bit */
   1414              TIM2->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   \                     ??TIM2_SelectCCDMA_0:
   \   000008 72175251              BRES      L:0x5251, #0x3
   1415            }
   1416          }
   \   00000C 81                    RET
   1417          
   1418          /**
   1419            * @brief  Checks whether the specified TIM2 flag is set or not.
   1420            * @param  TIM2_FLAG : Specifies the flag to check.
   1421            *   This parameter can be one of the @ref TIM2_FLAG_TypeDef enumeration.
   1422            * @retval FlagStatus : The new state of TIM2_FLAG.
   1423            *   This parameter can be any of the @ref FlagStatus enumeration.
   1424            */

   \                                 In section .near_func.text, align 1
   1425          FlagStatus TIM2_GetFlagStatus(TIM2_FLAG_TypeDef TIM2_FLAG)
   1426          {
   1427            FlagStatus bitstatus = RESET;
   \                     TIM2_GetFlagStatus:
   \   000000 3F00                  CLR       S:?b0
   1428            uint8_t tim2_flag_l = 0, tim2_flag_h = 0;
   \   000002 3F00                  CLR       S:?b2
   \   000004 3F00                  CLR       S:?b1
   1429          
   1430            /* Check the parameters */
   1431            assert_param(IS_TIM2_GET_FLAG(TIM2_FLAG));
   1432          
   1433            tim2_flag_l = (uint8_t)(TIM2->SR1 & (uint8_t)(TIM2_FLAG));
   \   000006 9F                    LD        A, XL
   \   000007 C45256                AND       A, L:0x5256
   \   00000A B700                  LD        S:?b2, A
   1434            tim2_flag_h = (uint8_t)(TIM2->SR2 & (uint8_t)((uint16_t)TIM2_FLAG >> 8));
   \   00000C 4F                    CLR       A
   \   00000D 01                    RRWA      X, A
   \   00000E 9F                    LD        A, XL
   \   00000F C45257                AND       A, L:0x5257
   \   000012 B700                  LD        S:?b1, A
   1435          
   1436            if ((uint8_t)(tim2_flag_l | tim2_flag_h) != 0)
   \   000014 B600                  LD        A, S:?b1
   \   000016 BA00                  OR        A, S:?b2
   \   000018 A100                  CP        A, #0x0
   \   00001A 2706                  JREQ      L:??TIM2_GetFlagStatus_0
   1437            {
   1438              bitstatus = SET;
   \   00001C 35010000              MOV       S:?b0, #0x1
   \   000020 2002                  JRA       L:??TIM2_GetFlagStatus_1
   1439            }
   1440            else
   1441            {
   1442              bitstatus = RESET;
   \                     ??TIM2_GetFlagStatus_0:
   \   000022 3F00                  CLR       S:?b0
   1443            }
   1444            return ((FlagStatus)bitstatus);
   \                     ??TIM2_GetFlagStatus_1:
   \   000024 B600                  LD        A, S:?b0
   \   000026 81                    RET
   1445          }
   1446          
   1447          /**
   1448            * @brief  Clears the TIMs pending flags.
   1449            * @param  TIM2_FLAG : Specifies the flag to clear.
   1450            *   This parameter can be one of the @ref TIM2_FLAG_TypeDef enumeration.
   1451            * @retval None
   1452            */

   \                                 In section .near_func.text, align 1
   1453          void TIM2_ClearFlag(TIM2_FLAG_TypeDef TIM2_FLAG)
   1454          {
   1455            /* Check the parameters */
   1456            assert_param(IS_TIM2_CLEAR_FLAG((uint16_t)TIM2_FLAG));
   1457            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing 1 has no effect*/
   1458            TIM2->SR1 = (uint8_t)(~(uint8_t)(TIM2_FLAG));
   \                     TIM2_ClearFlag:
   \   000000 9F                    LD        A, XL
   \   000001 43                    CPL       A
   \   000002 C75256                LD        L:0x5256, A
   1459            TIM2->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM2_FLAG >> 8));
   \   000005 4F                    CLR       A
   \   000006 01                    RRWA      X, A
   \   000007 9F                    LD        A, XL
   \   000008 43                    CPL       A
   \   000009 C75257                LD        L:0x5257, A
   1460          }
   \   00000C 81                    RET
   1461          
   1462          /**
   1463            * @brief  Checks whether the TIM2 interrupt has occurred or not.
   1464            * @param  TIM2_IT : Specifies the TIM2 interrupt source to check.
   1465            *   This parameter can be one of the @ref TIM2_IT_TypeDef enumeration.
   1466            * @retval ITStatus : The new state of the TIM2_IT.
   1467            *   This parameter can be any of the @ref ITStatus enumeration.
   1468            */

   \                                 In section .near_func.text, align 1
   1469          ITStatus TIM2_GetITStatus(TIM2_IT_TypeDef TIM2_IT)
   1470          {
   \                     TIM2_GetITStatus:
   \   000000 B700                  LD        S:?b3, A
   1471            ITStatus bitstatus = RESET;
   \   000002 3F00                  CLR       S:?b0
   1472          
   1473            uint8_t TIM2_itStatus = 0x0, TIM2_itEnable = 0x0;
   \   000004 3F00                  CLR       S:?b2
   \   000006 3F00                  CLR       S:?b1
   1474          
   1475            /* Check the parameters */
   1476            assert_param(IS_TIM2_GET_IT(TIM2_IT));
   1477          
   1478            TIM2_itStatus = (uint8_t)(TIM2->SR1 & (uint8_t)TIM2_IT);
   \   000008 B600                  LD        A, S:?b3
   \   00000A C45256                AND       A, L:0x5256
   \   00000D B700                  LD        S:?b2, A
   1479          
   1480            TIM2_itEnable = (uint8_t)(TIM2->IER & (uint8_t)TIM2_IT);
   \   00000F B600                  LD        A, S:?b3
   \   000011 C45255                AND       A, L:0x5255
   \   000014 B700                  LD        S:?b1, A
   1481          
   1482            if ((TIM2_itStatus != (uint8_t)RESET ) && (TIM2_itEnable != (uint8_t)RESET))
   \   000016 3D00                  TNZ       S:?b2
   \   000018 270A                  JREQ      L:??TIM2_GetITStatus_0
   \   00001A 3D00                  TNZ       S:?b1
   \   00001C 2706                  JREQ      L:??TIM2_GetITStatus_0
   1483            {
   1484              bitstatus = (ITStatus)SET;
   \   00001E 35010000              MOV       S:?b0, #0x1
   \   000022 2002                  JRA       L:??TIM2_GetITStatus_1
   1485            }
   1486            else
   1487            {
   1488              bitstatus = (ITStatus)RESET;
   \                     ??TIM2_GetITStatus_0:
   \   000024 3F00                  CLR       S:?b0
   1489            }
   1490            return ((ITStatus)bitstatus);
   \                     ??TIM2_GetITStatus_1:
   \   000026 B600                  LD        A, S:?b0
   \   000028 81                    RET
   1491          }
   1492          
   1493          /**
   1494            * @brief  Clears the TIM's interrupt pending bits.
   1495            * @param  TIM2_IT : Specifies the pending bit to clear.
   1496            *   This parameter can be one of the @ref TIM2_IT_TypeDef enumeration.
   1497            * @retval None
   1498            */

   \                                 In section .near_func.text, align 1
   1499          void TIM2_ClearITPendingBit(TIM2_IT_TypeDef TIM2_IT)
   1500          {
   1501            /* Check the parameters */
   1502            assert_param(IS_TIM2_IT(TIM2_IT));
   1503          
   1504            /* Clear the IT pending Bit */
   1505            TIM2->SR1 = (uint8_t)(~(uint8_t)TIM2_IT);
   \                     TIM2_ClearITPendingBit:
   \   000000 43                    CPL       A
   \   000001 C75256                LD        L:0x5256, A
   1506          }
   \   000004 81                    RET
   1507          
   1508          /**
   1509            * @brief  Configure the TI1 as Input.
   1510            * @param  TIM2_ICPolarity : The Input Polarity.
   1511            *   This parameter can be one of the @ref TIM2_ICPolarity_TypeDef enumeration.
   1512            * @param  TIM2_ICSelection : Specifies the input to be used.
   1513            *   This parameter can be one of the @ref TIM2_ICSelection_TypeDef enumeration.
   1514            * @param  TIM2_ICFilter : Specifies the Input Capture Filter.
   1515            *   This parameter must be a value between 0x00 and 0x0F.
   1516            * @retval None
   1517            */

   \                                 In section .near_func.text, align 1
   1518          static void TI1_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity, \
   1519                                 TIM2_ICSelection_TypeDef TIM2_ICSelection, \
   1520                                 uint8_t TIM2_ICFilter)
   1521          {
   \                     TI1_Config:
   \   000000 B700                  LD        S:?b2, A
   1522            uint8_t tmpccmr1 = 0;
   \   000002 3F00                  CLR       S:?b3
   1523            uint8_t tmpicpolarity = (uint8_t)TIM2_ICPolarity;
   1524            tmpccmr1 = TIM2->CCMR1;
   \   000004 C65259                LD        A, L:0x5259
   \   000007 B700                  LD        S:?b3, A
   1525          
   1526            /* Check the parameters */
   1527            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   1528            assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
   1529            assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
   1530          
   1531            /* Disable the Channel 1: Reset the CCE Bit */
   1532            TIM2->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   \   000009 7211525B              BRES      L:0x525b, #0x0
   1533          
   1534            /* Select the Input and set the filter */
   1535            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B600                  LD        A, S:?b3
   \   00000F A40C                  AND       A, #0xc
   \   000011 B700                  LD        S:?b3, A
   1536            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
   \   000013 B600                  LD        A, S:?b1
   \   000015 4E                    SWAP      A
   \   000016 A4F0                  AND       A, #0xf0
   \   000018 BA00                  OR        A, S:?b0
   \   00001A BA00                  OR        A, S:?b3
   \   00001C B700                  LD        S:?b3, A
   1537          
   1538            TIM2->CCMR1 = tmpccmr1;
   \   00001E B600                  LD        A, S:?b3
   \   000020 C75259                LD        L:0x5259, A
   1539          
   1540            /* Select the Polarity */
   1541            if (tmpicpolarity == (uint8_t)(TIM2_ICPolarity_Falling))
   \   000023 B600                  LD        A, S:?b2
   \   000025 A101                  CP        A, #0x1
   \   000027 2606                  JRNE      L:??TI1_Config_0
   1542            {
   1543              TIM2->CCER1 |= TIM_CCER1_CC1P;
   \   000029 7212525B              BSET      L:0x525b, #0x1
   \   00002D 2004                  JRA       L:??TI1_Config_1
   1544            }
   1545            else
   1546            {
   1547              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   00002F 7213525B              BRES      L:0x525b, #0x1
   1548            }
   1549          
   1550            /* Set the CCE Bit */
   1551            TIM2->CCER1 |=  TIM_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   000033 7210525B              BSET      L:0x525b, #0x0
   1552          }
   \   000037 81                    RET
   1553          
   1554          /**
   1555            * @brief  Configure the TI2 as Input.
   1556            * @param  TIM2_ICPolarity : The Input Polarity.
   1557            *   This parameter can be one of the @ref TIM2_ICPolarity_TypeDef enumeration.
   1558            * @param  TIM2_ICSelection : Specifies the input to be used.
   1559            *   This parameter can be one of the @ref TIM2_ICSelection_TypeDef enumeration.
   1560            * @param  TIM2_ICFilter : Specifies the Input Capture Filter.
   1561            *   This parameter must be a value between 0x00 and 0x0F.
   1562            * @retval None
   1563            */

   \                                 In section .near_func.text, align 1
   1564          static void TI2_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
   1565                                 TIM2_ICSelection_TypeDef TIM2_ICSelection,
   1566                                 uint8_t TIM2_ICFilter)
   1567          {
   \                     TI2_Config:
   \   000000 B700                  LD        S:?b2, A
   1568            uint8_t tmpccmr2 = 0;
   \   000002 3F00                  CLR       S:?b3
   1569            uint8_t tmpicpolarity = (uint8_t)TIM2_ICPolarity;
   1570          
   1571            /* Check the parameters */
   1572            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   1573            assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
   1574            assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
   1575          
   1576            tmpccmr2 = TIM2->CCMR2;
   \   000004 C6525A                LD        A, L:0x525a
   \   000007 B700                  LD        S:?b3, A
   1577          
   1578            /* Disable the Channel 2: Reset the CCE Bit */
   1579            TIM2->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   \   000009 7219525B              BRES      L:0x525b, #0x4
   1580          
   1581            /* Select the Input and set the filter */
   1582            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B600                  LD        A, S:?b3
   \   00000F A40C                  AND       A, #0xc
   \   000011 B700                  LD        S:?b3, A
   1583            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
   \   000013 B600                  LD        A, S:?b1
   \   000015 4E                    SWAP      A
   \   000016 A4F0                  AND       A, #0xf0
   \   000018 BA00                  OR        A, S:?b0
   \   00001A BA00                  OR        A, S:?b3
   \   00001C B700                  LD        S:?b3, A
   1584          
   1585            TIM2->CCMR2 = tmpccmr2;
   \   00001E B600                  LD        A, S:?b3
   \   000020 C7525A                LD        L:0x525a, A
   1586          
   1587            /* Select the Polarity */
   1588            if (tmpicpolarity == TIM2_ICPolarity_Falling)
   \   000023 B600                  LD        A, S:?b2
   \   000025 A101                  CP        A, #0x1
   \   000027 2606                  JRNE      L:??TI2_Config_0
   1589            {
   1590              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   \   000029 721A525B              BSET      L:0x525b, #0x5
   \   00002D 2004                  JRA       L:??TI2_Config_1
   1591            }
   1592            else
   1593            {
   1594              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TI2_Config_0:
   \   00002F 721B525B              BRES      L:0x525b, #0x5
   1595            }
   1596          
   1597            /* Set the CCE Bit */
   1598            TIM2->CCER1 |=  TIM_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   000033 7218525B              BSET      L:0x525b, #0x4
   1599          }
   \   000037 81                    RET
   1600          /**
   1601            * @}
   1602            */
   1603          
   1604          /**
   1605            * @}
   1606            */
   1607          
   1608          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label              Bytes
     --------------              -----
     TIM2_DeInit                  101
     TIM2_TimeBaseInit             42
     TIM2_OC1Init                  93
     TIM2_OC2Init                  93
     TIM2_BKRConfig                22
     TIM2_ICInit                   35
     TIM2_PWMIConfig              120
     TIM2_Cmd                      13
     TIM2_CtrlPWMOutputs           13
     TIM2_ITConfig                 19
     TIM2_DMACmd                   19
     TIM2_InternalClockConfig       9
     TIM2_ETRClockMode1Config      36
     TIM2_ETRClockMode2Config       8
     TIM2_ETRConfig                15
     TIM2_TIxExternalClockConfig   45
     TIM2_SelectInputTrigger       27
     TIM2_UpdateDisableConfig      13
     TIM2_UpdateRequestConfig      14
     TIM2_SelectHallSensor         13
     TIM2_SelectOnePulseMode       14
     TIM2_SelectOutputTrigger      27
     TIM2_SelectSlaveMode          27
     TIM2_SelectMasterSlaveMode    13
     TIM2_EncoderInterfaceConfig  107
     TIM2_PrescalerConfig          19
     TIM2_CounterModeConfig        27
     TIM2_ForcedOC1Config          27
     TIM2_ForcedOC2Config          27
     TIM2_ARRPreloadConfig         13
     TIM2_OC1PreloadConfig         13
     TIM2_OC2PreloadConfig         13
     TIM2_OC1FastCmd               13
     TIM2_OC2FastCmd               13
     TIM2_GenerateEvent             7
     TIM2_OC1PolarityConfig        14
     TIM2_OC2PolarityConfig        14
     TIM2_CCxCmd                   31
     TIM2_SelectOCxM               45
     TIM2_SetCounter               15
     TIM2_SetAutoreload            15
     TIM2_SetCompare1              15
     TIM2_SetCompare2              15
     TIM2_SetIC1Prescaler          27
     TIM2_SetIC2Prescaler          27
     TIM2_GetCapture1              34
     TIM2_GetCapture2              34
     TIM2_GetCounter               34
     TIM2_GetPrescaler              4
     TIM2_SelectCCDMA              13
     TIM2_GetFlagStatus            39
     TIM2_ClearFlag                13
     TIM2_GetITStatus              41
     TIM2_ClearITPendingBit         5
     TI1_Config                    56
     TI2_Config                    56

 
 1 657 bytes in section .near_func.text
 
 1 657 bytes of CODE memory

Errors: none
Warnings: none
