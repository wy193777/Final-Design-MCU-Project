###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             12/Mar/2014  19:56:52 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_t #
#                    im5.c                                                    #
#    Command line =  "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_t #
#                    im5.c" -e -Ol --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model small --data_model medium -o                #
#                    "F:\Skydrive\Final Design\Servo Motor STM8L\Debug\Obj\"  #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.0\stm8\LIB\dlstm8smn.h" -D STM8L15X_MD -lCN            #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Debug\List\" --diag_suppress Pe177,Pe550 -I        #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Project\Discover\inc\" -I "F:\Skydrive\Final       #
#                    Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Dr #
#                    iver\inc\" --vregs 16                                    #
#    List file    =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\List\stm8l15x_tim5.lst                       #
#    Object file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\Obj\stm8l15x_tim5.o                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\Skydrive\Final Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim5.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_TIM5.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the TIM5 firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_TIM5.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
     34                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
     35                                 uint8_t TIM5_ICFilter);
     36          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
     37                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
     38                                 uint8_t TIM5_ICFilter);
     39          
     40          
     41          /**
     42            * @addtogroup TIM5_Public_Functions
     43            * @{
     44            */
     45          
     46          /**
     47            * @brief  Deinitializes the TIM5 peripheral registers to their default reset values.
     48            * @param  None
     49            * @retval None
     50            */

   \                                 In section .near_func.text, align 1
     51          void TIM5_DeInit(void)
     52          {
     53            TIM5->CR1 = TIM_CR1_RESET_VALUE;
   \                     TIM5_DeInit:
   \   000000 35005300              MOV       L:0x5300, #0x0
     54            TIM5->CR2 = TIM_CR2_RESET_VALUE;
   \   000004 35005301              MOV       L:0x5301, #0x0
     55            TIM5->SMCR = TIM_SMCR_RESET_VALUE;
   \   000008 35005302              MOV       L:0x5302, #0x0
     56            TIM5->ETR = TIM_ETR_RESET_VALUE;
   \   00000C 35005303              MOV       L:0x5303, #0x0
     57            TIM5->IER = TIM_IER_RESET_VALUE;
   \   000010 35005305              MOV       L:0x5305, #0x0
     58            TIM5->SR2 = TIM_SR2_RESET_VALUE;
   \   000014 35005307              MOV       L:0x5307, #0x0
     59          
     60            /* Disable channels */
     61            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000018 3500530B              MOV       L:0x530b, #0x0
     62            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
     63            TIM5->CCMR1 = 0x01;/*TIM5_ICxSource_TIxFPx */
   \   00001C 35015309              MOV       L:0x5309, #0x1
     64            TIM5->CCMR2 = 0x01;/*TIM5_ICxSource_TIxFPx */
   \   000020 3501530A              MOV       L:0x530a, #0x1
     65          
     66            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     67            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
   \   000024 3500530B              MOV       L:0x530b, #0x0
     68            TIM5->CCMR1 = TIM_CCMR1_RESET_VALUE;
   \   000028 35005309              MOV       L:0x5309, #0x0
     69            TIM5->CCMR2 = TIM_CCMR2_RESET_VALUE;
   \   00002C 3500530A              MOV       L:0x530a, #0x0
     70          
     71            TIM5->CNTRH = TIM_CNTRH_RESET_VALUE;
   \   000030 3500530C              MOV       L:0x530c, #0x0
     72            TIM5->CNTRL = TIM_CNTRL_RESET_VALUE;
   \   000034 3500530D              MOV       L:0x530d, #0x0
     73          
     74            TIM5->PSCR = TIM_PSCR_RESET_VALUE;
   \   000038 3500530E              MOV       L:0x530e, #0x0
     75          
     76            TIM5->ARRH = TIM_ARRH_RESET_VALUE;
   \   00003C 35FF530F              MOV       L:0x530f, #0xff
     77            TIM5->ARRL = TIM_ARRL_RESET_VALUE;
   \   000040 35FF5310              MOV       L:0x5310, #0xff
     78          
     79            TIM5->CCR1H = TIM_CCR1H_RESET_VALUE;
   \   000044 35005311              MOV       L:0x5311, #0x0
     80            TIM5->CCR1L = TIM_CCR1L_RESET_VALUE;
   \   000048 35005312              MOV       L:0x5312, #0x0
     81            TIM5->CCR2H = TIM_CCR2H_RESET_VALUE;
   \   00004C 35005313              MOV       L:0x5313, #0x0
     82            TIM5->CCR2L = TIM_CCR2L_RESET_VALUE;
   \   000050 35005314              MOV       L:0x5314, #0x0
     83          
     84          
     85            TIM5->OISR = TIM_OISR_RESET_VALUE;
   \   000054 35005316              MOV       L:0x5316, #0x0
     86            TIM5->EGR = 0x01;/* TIM_EGR_UG */
   \   000058 35015308              MOV       L:0x5308, #0x1
     87            TIM5->BKR = TIM_BKR_RESET_VALUE;
   \   00005C 35005315              MOV       L:0x5315, #0x0
     88            TIM5->SR1 = TIM_SR1_RESET_VALUE;
   \   000060 35005306              MOV       L:0x5306, #0x0
     89          }
   \   000064 81                    RET
     90          
     91          /**
     92            * @brief  Initializes the TIM5 Time Base Unit according to the specified  parameters.
     93            * @param  TIM5_Prescaler : This parameter can be any member of the @Ref TIM5_Prescaler_TypeDef enumeration.
     94            * @param  TIM5_CounterMode : This parameter can be any member of the @Ref TIM5_CounterMode_TypeDef enumeration.
     95            * @param  TIM5_Period : This parameter must be a value between 0x0000 and 0xFFFF.
     96            * @retval None
     97            */
     98          

   \                                 In section .near_func.text, align 1
     99          void TIM5_TimeBaseInit(TIM5_Prescaler_TypeDef TIM5_Prescaler,
    100                                 TIM5_CounterMode_TypeDef TIM5_CounterMode,
    101                                 uint16_t TIM5_Period)
    102          {
   \                     TIM5_TimeBaseInit:
   \   000000 B700                  LD        S:?b1, A
   \   000002 9093                  LDW       Y, X
    103          
    104            assert_param(IS_TIM5_PRESCALER(TIM5_Prescaler));
    105            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    106          
    107          
    108          
    109            /* Set the Autoreload value */
    110            TIM5->ARRH = (uint8_t)(TIM5_Period >> 8) ;
   \   000004 93                    LDW       X, Y
   \   000005 4F                    CLR       A
   \   000006 01                    RRWA      X, A
   \   000007 9F                    LD        A, XL
   \   000008 C7530F                LD        L:0x530f, A
    111            TIM5->ARRL = (uint8_t)(TIM5_Period);
   \   00000B 909F                  LD        A, YL
   \   00000D C75310                LD        L:0x5310, A
    112          
    113            /* Set the Prescaler value */
    114            TIM5->PSCR = (uint8_t)(TIM5_Prescaler);
   \   000010 B600                  LD        A, S:?b1
   \   000012 C7530E                LD        L:0x530e, A
    115          
    116            /* Select the Counter Mode */
    117            TIM5->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
   \   000015 C65300                LD        A, L:0x5300
   \   000018 A48F                  AND       A, #0x8f
   \   00001A C75300                LD        L:0x5300, A
    118            TIM5->CR1 |= (uint8_t)(TIM5_CounterMode);
   \   00001D B600                  LD        A, S:?b0
   \   00001F CA5300                OR        A, L:0x5300
   \   000022 C75300                LD        L:0x5300, A
    119          
    120            /* Generate an update event to reload the Prescaler value immediately */
    121            TIM5->EGR = TIM5_EventSource_Update;
   \   000025 35015308              MOV       L:0x5308, #0x1
    122          }
   \   000029 81                    RET
    123          
    124          /**
    125            * @brief  Initializes the TIM5 Channel1 according to the specified parameters.
    126            * @param  TIM5_OCMode : This parameter can be any member of the @Ref TIM5_OCMode_TypeDef enumeration.
    127            * @param  TIM5_OutputState : This parameter can be any member of the @Ref TIM5_OutputState_TypeDef enumeration.
    128            * @param  TIM5_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    129            * @param  TIM5_OCPolarity : This parameter can be any member of the @Ref TIM5_OCPolarity_TypeDef enumeration.
    130            * @param  TIM5_OCIdleState : This parameter can be any member of the @Ref TIM5_OCIdleState_TypeDef  enumeration.
    131            * @retval None
    132            */

   \                                 In section .near_func.text, align 1
    133          void TIM5_OC1Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    134                            TIM5_OutputState_TypeDef TIM5_OutputState,
    135                            uint16_t TIM5_Pulse,
    136                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    137                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    138          {
   \                     TIM5_OC1Init:
   \   000000 B700                  LD        S:?b3, A
   \   000002 9093                  LDW       Y, X
    139            uint8_t tmpccmr1 = 0;
   \   000004 3F00                  CLR       S:?b4
    140          
    141            /* Check the parameters */
    142            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    143            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    144            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    145            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    146          
    147            tmpccmr1 = TIM5->CCMR1;
   \   000006 C65309                LD        A, L:0x5309
   \   000009 B700                  LD        S:?b4, A
    148          
    149            /* Disable the Channel 1: Reset the CCE Bit */
    150            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   00000B 7211530B              BRES      L:0x530b, #0x0
    151            /* Reset the Output Compare Bits */
    152            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B600                  LD        A, S:?b4
   \   000011 A48F                  AND       A, #0x8f
   \   000013 B700                  LD        S:?b4, A
    153          
    154            /* Set the Ouput Compare Mode */
    155            tmpccmr1 |= (uint8_t)TIM5_OCMode;
   \   000015 B600                  LD        A, S:?b3
   \   000017 BA00                  OR        A, S:?b4
   \   000019 B700                  LD        S:?b4, A
    156          
    157            TIM5->CCMR1 = tmpccmr1;
   \   00001B B600                  LD        A, S:?b4
   \   00001D C75309                LD        L:0x5309, A
    158          
    159            /* Set the Output State */
    160            if (TIM5_OutputState == TIM5_OutputState_Enable)
   \   000020 B600                  LD        A, S:?b0
   \   000022 A101                  CP        A, #0x1
   \   000024 2606                  JRNE      L:??TIM5_OC1Init_0
    161            {
    162              TIM5->CCER1 |= TIM_CCER1_CC1E;
   \   000026 7210530B              BSET      L:0x530b, #0x0
   \   00002A 2004                  JRA       L:??TIM5_OC1Init_1
    163            }
    164            else
    165            {
    166              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \                     ??TIM5_OC1Init_0:
   \   00002C 7211530B              BRES      L:0x530b, #0x0
    167            }
    168          
    169            /* Set the Output Polarity */
    170            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     ??TIM5_OC1Init_1:
   \   000030 B600                  LD        A, S:?b1
   \   000032 A101                  CP        A, #0x1
   \   000034 2606                  JRNE      L:??TIM5_OC1Init_2
    171            {
    172              TIM5->CCER1 |= TIM_CCER1_CC1P;
   \   000036 7212530B              BSET      L:0x530b, #0x1
   \   00003A 2004                  JRA       L:??TIM5_OC1Init_3
    173            }
    174            else
    175            {
    176              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TIM5_OC1Init_2:
   \   00003C 7213530B              BRES      L:0x530b, #0x1
    177            }
    178          
    179            /* Set the Output Idle state */
    180            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
   \                     ??TIM5_OC1Init_3:
   \   000040 B600                  LD        A, S:?b2
   \   000042 A101                  CP        A, #0x1
   \   000044 2606                  JRNE      L:??TIM5_OC1Init_4
    181            {
    182              TIM5->OISR |= TIM_OISR_OIS1;
   \   000046 72105316              BSET      L:0x5316, #0x0
   \   00004A 2004                  JRA       L:??TIM5_OC1Init_5
    183            }
    184            else
    185            {
    186              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS1);
   \                     ??TIM5_OC1Init_4:
   \   00004C 72115316              BRES      L:0x5316, #0x0
    187            }
    188          
    189            /* Set the Pulse value */
    190            TIM5->CCR1H = (uint8_t)(TIM5_Pulse >> 8);
   \                     ??TIM5_OC1Init_5:
   \   000050 93                    LDW       X, Y
   \   000051 4F                    CLR       A
   \   000052 01                    RRWA      X, A
   \   000053 9F                    LD        A, XL
   \   000054 C75311                LD        L:0x5311, A
    191            TIM5->CCR1L = (uint8_t)(TIM5_Pulse);
   \   000057 909F                  LD        A, YL
   \   000059 C75312                LD        L:0x5312, A
    192          }
   \   00005C 81                    RET
    193          
    194          /**
    195            * @brief  Initializes the TIM5 Channel2 according to the specified parameters.
    196            * @param  TIM5_OCMode : This parameter can be any member of the @Ref TIM5_OCMode_TypeDef enumeration.
    197            * @param  TIM5_OutputState : This parameter can be any member of the @Ref TIM5_OutputState_TypeDef enumeration.
    198            * @param  TIM5_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    199            * @param  TIM5_OCPolarity : This parameter can be any member of the @Ref TIM5_OCPolarity_TypeDef enumeration.
    200            * @param  TIM5_OCIdleState : This parameter can be any member of the @Ref TIM5_OCIdleState_TypeDef  enumeration.
    201            * @retval None
    202            */

   \                                 In section .near_func.text, align 1
    203          void TIM5_OC2Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    204                            TIM5_OutputState_TypeDef TIM5_OutputState,
    205                            uint16_t TIM5_Pulse,
    206                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    207                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    208          {
   \                     TIM5_OC2Init:
   \   000000 B700                  LD        S:?b3, A
   \   000002 9093                  LDW       Y, X
    209            uint8_t tmpccmr2 = 0;
   \   000004 3F00                  CLR       S:?b4
    210          
    211            /* Check the parameters */
    212            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    213            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    214            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    215            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    216          
    217            tmpccmr2 = TIM5->CCMR2;
   \   000006 C6530A                LD        A, L:0x530a
   \   000009 B700                  LD        S:?b4, A
    218          
    219            /* Disable the Channel 2: Reset the CCE Bit */
    220            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \   00000B 7219530B              BRES      L:0x530b, #0x4
    221          
    222            /* Reset the Output Compare Bits */
    223            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00000F B600                  LD        A, S:?b4
   \   000011 A48F                  AND       A, #0x8f
   \   000013 B700                  LD        S:?b4, A
    224          
    225            /* Set the Ouput Compare Mode */
    226            tmpccmr2 |= (uint8_t)TIM5_OCMode;
   \   000015 B600                  LD        A, S:?b3
   \   000017 BA00                  OR        A, S:?b4
   \   000019 B700                  LD        S:?b4, A
    227          
    228            TIM5->CCMR2 = tmpccmr2;
   \   00001B B600                  LD        A, S:?b4
   \   00001D C7530A                LD        L:0x530a, A
    229          
    230            /* Set the Output State */
    231            if (TIM5_OutputState == TIM5_OutputState_Enable)
   \   000020 B600                  LD        A, S:?b0
   \   000022 A101                  CP        A, #0x1
   \   000024 2606                  JRNE      L:??TIM5_OC2Init_0
    232            {
    233              TIM5->CCER1 |= TIM_CCER1_CC2E;
   \   000026 7218530B              BSET      L:0x530b, #0x4
   \   00002A 2004                  JRA       L:??TIM5_OC2Init_1
    234            }
    235            else
    236            {
    237              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM5_OC2Init_0:
   \   00002C 7219530B              BRES      L:0x530b, #0x4
    238            }
    239          
    240            /* Set the Output Polarity */
    241            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     ??TIM5_OC2Init_1:
   \   000030 B600                  LD        A, S:?b1
   \   000032 A101                  CP        A, #0x1
   \   000034 2606                  JRNE      L:??TIM5_OC2Init_2
    242            {
    243              TIM5->CCER1 |= TIM_CCER1_CC2P;
   \   000036 721A530B              BSET      L:0x530b, #0x5
   \   00003A 2004                  JRA       L:??TIM5_OC2Init_3
    244            }
    245            else
    246            {
    247              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
   \                     ??TIM5_OC2Init_2:
   \   00003C 721B530B              BRES      L:0x530b, #0x5
    248            }
    249          
    250          
    251            /* Set the Output Idle state */
    252            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
   \                     ??TIM5_OC2Init_3:
   \   000040 B600                  LD        A, S:?b2
   \   000042 A101                  CP        A, #0x1
   \   000044 2606                  JRNE      L:??TIM5_OC2Init_4
    253            {
    254              TIM5->OISR |= TIM_OISR_OIS2;
   \   000046 72145316              BSET      L:0x5316, #0x2
   \   00004A 2004                  JRA       L:??TIM5_OC2Init_5
    255            }
    256            else
    257            {
    258              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS2);
   \                     ??TIM5_OC2Init_4:
   \   00004C 72155316              BRES      L:0x5316, #0x2
    259            }
    260          
    261            /* Set the Pulse value */
    262            TIM5->CCR2H = (uint8_t)(TIM5_Pulse >> 8);
   \                     ??TIM5_OC2Init_5:
   \   000050 93                    LDW       X, Y
   \   000051 4F                    CLR       A
   \   000052 01                    RRWA      X, A
   \   000053 9F                    LD        A, XL
   \   000054 C75313                LD        L:0x5313, A
    263            TIM5->CCR2L = (uint8_t)(TIM5_Pulse);
   \   000057 909F                  LD        A, YL
   \   000059 C75314                LD        L:0x5314, A
    264          }
   \   00005C 81                    RET
    265          
    266          /**
    267            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    268            * and the AOE(automatic output enable).
    269            * @param  TIM5_OSSIState : Off-State Selection for Idle mode states.
    270            *   This parameter can be any member of the @Ref TIM5_OSSIState_TypeDef enumeration.
    271            * @param  TIM5_LockLevel : Lock level.
    272            *   This parameter can be any member of the @Ref TIM5_LockLevel_TypeDef enumeration.
    273            * @param  TIM5_BreakState : Break Input enable/disable .
    274            *   This parameter can be any member of the @Ref TIM5_BreakState_TypeDef enumeration.
    275            * @param  TIM5_BreakPolarity : Break Polarity.
    276            *   This parameter can be any member of the @Ref TIM5_BreakPolarity_TypeDef enumeration.
    277            * @param  TIM5_AutomaticOutput : TIM5 AOE Bit Set/Reset .
    278            *   This parameter can be anymember  of the @Ref TIM5_AutomaticOutput_TypeDef enumeration.
    279            * @retval None
    280            */

   \                                 In section .near_func.text, align 1
    281          void TIM5_BKRConfig(TIM5_OSSIState_TypeDef TIM5_OSSIState,
    282                              TIM5_LockLevel_TypeDef TIM5_LockLevel,
    283                              TIM5_BreakState_TypeDef TIM5_BreakState,
    284                              TIM5_BreakPolarity_TypeDef TIM5_BreakPolarity,
    285                              TIM5_AutomaticOutput_TypeDef TIM5_AutomaticOutput)
    286          
    287          {
   \                     TIM5_BKRConfig:
   \   000000 B700                  LD        S:?b4, A
   \   000002 B600                  LD        A, S:?b2
    288            /* Check the parameters */
    289            assert_param(IS_TIM5_OSSI_STATE(TIM5_OSSIState));
    290            assert_param(IS_TIM5_LOCK_LEVEL(TIM5_LockLevel));
    291            assert_param(IS_TIM5_BREAK_STATE(TIM5_BreakState));
    292            assert_param(IS_TIM5_BREAK_POLARITY(TIM5_BreakPolarity));
    293            assert_param(IS_TIM5_AUTOMATIC_OUTPUT_STATE(TIM5_AutomaticOutput));
    294          
    295          
    296          
    297            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSI State,
    298            the dead time value and the Automatic Output Enable Bit */
    299            TIM5->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM5_OSSIState | (uint8_t)TIM5_LockLevel) | \
    300                                            (uint8_t)((uint8_t)TIM5_BreakState | (uint8_t)TIM5_BreakPolarity)) | \
    301                                            TIM5_AutomaticOutput));
   \   000004 BA00                  OR        A, S:?b1
   \   000006 88                    PUSH      A
   \   000007 B600                  LD        A, S:?b0
   \   000009 BA00                  OR        A, S:?b4
   \   00000B B700                  LD        S:?b0, A
   \   00000D 84                    POP       A
   \   00000E BA00                  OR        A, S:?b0
   \   000010 BA00                  OR        A, S:?b3
   \   000012 C75315                LD        L:0x5315, A
    302          }
   \   000015 81                    RET
    303          
    304          /**
    305            * @brief  Initializes the TIM5 peripheral according to the specified parameters.
    306            * @param  TIM5_Channel : This parameter can be any member of the @Ref TIM5_Channel_TypeDef enumeration.
    307            * @param  TIM5_ICPolarity : This parameter can be any member of the @Ref TIM5_ICPolarity_TypeDef enumeration.
    308            * @param  TIM5_ICSelection : This parameter can be any member of the @Ref TIM5_ICSelection_TypeDef enumeration.
    309            * @param  TIM5_ICPrescaler : This parameter can be any member of the @Ref TIM5_ICPSC_TypeDef enumeration.
    310            * @param  TIM5_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    311            * @retval None
    312            */

   \                                 In section .near_func.text, align 1
    313          void TIM5_ICInit(TIM5_Channel_TypeDef TIM5_Channel,
    314                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    315                           TIM5_ICSelection_TypeDef TIM5_ICSelection,
    316                           TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
    317                           uint8_t TIM5_ICFilter)
    318          {
   \                     TIM5_ICInit:
   \   000000 450000                MOV       S:?b4, S:?b0
   \   000003 450000                MOV       S:?b0, S:?b1
   \   000006 450000                MOV       S:?b5, S:?b2
   \   000009 450000                MOV       S:?b1, S:?b3
    319            /* Check the parameters */
    320            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
    321          
    322            if (TIM5_Channel == TIM5_Channel_1)
   \   00000C 4D                    TNZ       A
   \   00000D 260A                  JRNE      L:??TIM5_ICInit_0
    323            {
    324              /* TI1 Configuration */
    325              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
   \   00000F B600                  LD        A, S:?b4
   \   000011 CD0000                CALL      L:TI1_Config
    326          
    327              /* Set the Input Capture Prescaler value */
    328              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   \   000014 B600                  LD        A, S:?b5
   \   000016 CC0000                JP        L:TIM5_SetIC1Prescaler
    329            }
    330            else /* if (TIM5_Channel == TIM5_Channel_2) */
    331            {
    332              /* TI2 Configuration */
    333              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
   \                     ??TIM5_ICInit_0:
   \   000019 B600                  LD        A, S:?b4
   \   00001B CD0000                CALL      L:TI2_Config
    334          
    335              /* Set the Input Capture Prescaler value */
    336              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   \   00001E B600                  LD        A, S:?b5
   \   000020 CC0000                JP        L:TIM5_SetIC2Prescaler
    337            }
    338          }
    339          
    340          /**
    341            * @brief  Configures the TIM5 peripheral in PWM Input Mode according to the
    342            * specified parameters.
    343            * @param  TIM5_Channel : This parameter can be any member of the @Ref TIM5_Channel_TypeDef enumeration.
    344            * @param  TIM5_ICPolarity : This parameter can be any member of the @Ref TIM5_ICPolarity_TypeDef enumeration.
    345            * @param  TIM5_ICSelection : This parameter can be any member of the @Ref TIM5_ICSelection_TypeDef enumeration.
    346            * @param  TIM5_ICPrescaler : This parameter can be any member of the @Ref TIM5_ICPSC_TypeDef enumeration.
    347            * @param  TIM5_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    348            * @retval None
    349            */

   \                                 In section .near_func.text, align 1, keep-with-next
    350          void TIM5_PWMIConfig(TIM5_Channel_TypeDef TIM5_Channel,
    351                               TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    352                               TIM5_ICSelection_TypeDef TIM5_ICSelection,
    353                               TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
    354                               uint8_t TIM5_ICFilter)
    355          {
   \                     TIM5_PWMIConfig:
   \   000000 CD0000                CALL      L:?push_w4
   \   000003 B700                  LD        S:?b6, A
   \   000005 450000                MOV       S:?b7, S:?b0
   \   000008 B600                  LD        A, S:?b1
   \   00000A 450000                MOV       S:?b8, S:?b2
   \   00000D 450000                MOV       S:?b9, S:?b3
    356            uint8_t icpolarity = TIM5_ICPolarity_Rising;
   \   000010 3F00                  CLR       S:?b5
    357            uint8_t icselection = TIM5_ICSelection_DirectTI;
   \   000012 35010000              MOV       S:?b4, #0x1
    358          
    359            /* Check the parameters */
    360            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
    361          
    362            /* Select the Opposite Input Polarity */
    363            if (TIM5_ICPolarity == TIM5_ICPolarity_Rising)
   \   000016 3D00                  TNZ       S:?b7
   \   000018 2606                  JRNE      L:??TIM5_PWMIConfig_0
    364            {
    365              icpolarity = TIM5_ICPolarity_Falling;
   \   00001A 35010000              MOV       S:?b5, #0x1
   \   00001E 2002                  JRA       L:??TIM5_PWMIConfig_1
    366            }
    367            else
    368            {
    369              icpolarity = TIM5_ICPolarity_Rising;
   \                     ??TIM5_PWMIConfig_0:
   \   000020 3F00                  CLR       S:?b5
    370            }
    371          
    372            /* Select the Opposite Input */
    373            if (TIM5_ICSelection == TIM5_ICSelection_DirectTI)
   \                     ??TIM5_PWMIConfig_1:
   \   000022 A101                  CP        A, #0x1
   \   000024 2606                  JRNE      L:??TIM5_PWMIConfig_2
    374            {
    375              icselection = TIM5_ICSelection_IndirectTI;
   \   000026 35020000              MOV       S:?b4, #0x2
   \   00002A 2004                  JRA       L:??TIM5_PWMIConfig_3
    376            }
    377            else
    378            {
    379              icselection = TIM5_ICSelection_DirectTI;
   \                     ??TIM5_PWMIConfig_2:
   \   00002C 35010000              MOV       S:?b4, #0x1
    380            }
    381          
    382            if (TIM5_Channel == TIM5_Channel_1)
   \                     ??TIM5_PWMIConfig_3:
   \   000030 3D00                  TNZ       S:?b6
   \   000032 2622                  JRNE      L:??TIM5_PWMIConfig_4
    383            {
    384              /* TI1 Configuration */
    385              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection,
    386                         TIM5_ICFilter);
   \   000034 450000                MOV       S:?b1, S:?b9
   \   000037 B700                  LD        S:?b0, A
   \   000039 B600                  LD        A, S:?b7
   \   00003B CD0000                CALL      L:TI1_Config
    387          
    388              /* Set the Input Capture Prescaler value */
    389              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   \   00003E B600                  LD        A, S:?b8
   \   000040 CD0000                CALL      L:TIM5_SetIC1Prescaler
    390          
    391              /* TI2 Configuration */
    392              TI2_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
   \   000043 450000                MOV       S:?b1, S:?b9
   \   000046 450000                MOV       S:?b0, S:?b4
   \   000049 B600                  LD        A, S:?b5
   \   00004B CD0000                CALL      L:TI2_Config
    393          
    394              /* Set the Input Capture Prescaler value */
    395              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   \   00004E B600                  LD        A, S:?b8
   \   000050 CD0000                CALL      L:TIM5_SetIC2Prescaler
   \   000053 CC0000                JP        L:?epilogue_w4
    396            }
    397            else
    398            {
    399              /* TI2 Configuration */
    400              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection,
    401                         TIM5_ICFilter);
   \                     ??TIM5_PWMIConfig_4:
   \   000056 450000                MOV       S:?b1, S:?b9
   \   000059 B700                  LD        S:?b0, A
   \   00005B B600                  LD        A, S:?b7
   \   00005D CD0000                CALL      L:TI2_Config
    402          
    403              /* Set the Input Capture Prescaler value */
    404              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
   \   000060 B600                  LD        A, S:?b8
   \   000062 CD0000                CALL      L:TIM5_SetIC2Prescaler
    405          
    406              /* TI1 Configuration */
    407              TI1_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
   \   000065 450000                MOV       S:?b1, S:?b9
   \   000068 450000                MOV       S:?b0, S:?b4
   \   00006B B600                  LD        A, S:?b5
   \   00006D CD0000                CALL      L:TI1_Config
    408          
    409              /* Set the Input Capture Prescaler value */
    410              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
   \   000070 B600                  LD        A, S:?b8
   \   000072 CD0000                CALL      L:TIM5_SetIC1Prescaler
    411            }
    412          }
   \   000075 CC0000                JP        L:?epilogue_w4
    413          
    414          /**
    415            * @brief  Enables or disables the TIM5 peripheral.
    416            * @param  NewState : The new state of the TIM5 peripheral.
    417            *   This parameter can be any of the @ref FunctionalState enumeration.
    418            * @retval None
    419            */

   \                                 In section .near_func.text, align 1, keep-with-next
    420          void TIM5_Cmd(FunctionalState NewState)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_FUNCTIONAL_STATE(NewState));
    424          
    425            /* set or Reset the CEN Bit */
    426            if (NewState != DISABLE)
   \                     TIM5_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_Cmd_0
    427            {
    428              TIM5->CR1 |= TIM_CR1_CEN;
   \   000003 72105300              BSET      L:0x5300, #0x0
   \   000007 81                    RET
    429            }
    430            else
    431            {
    432              TIM5->CR1 &= (uint8_t)(~TIM_CR1_CEN);
   \                     ??TIM5_Cmd_0:
   \   000008 72115300              BRES      L:0x5300, #0x0
    433            }
    434          }
   \   00000C 81                    RET
    435          
    436          /**
    437            * @brief  Enables or disables the TIM5 peripheral Main Outputs.
    438            * @param  NewState : The new state of the TIM5 peripheral.
    439            *   This parameter can be any of the @ref FunctionalState enumeration.
    440            * @retval None
    441            */

   \                                 In section .near_func.text, align 1, keep-with-next
    442          void TIM5_CtrlPWMOutputs(FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            /* Set or Reset the MOE Bit */
    448          
    449            if (NewState != DISABLE)
   \                     TIM5_CtrlPWMOutputs:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_CtrlPWMOutputs_0
    450            {
    451              TIM5->BKR |= TIM_BKR_MOE ;
   \   000003 721E5315              BSET      L:0x5315, #0x7
   \   000007 81                    RET
    452            }
    453            else
    454            {
    455              TIM5->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
   \                     ??TIM5_CtrlPWMOutputs_0:
   \   000008 721F5315              BRES      L:0x5315, #0x7
    456            }
    457          }
   \   00000C 81                    RET
    458          
    459          /**
    460            * @brief  Enables or disables the specified TIM5 interrupts.
    461            * @param  TIM5_IT : Specifies the TIM5 interrupts sources to be enabled or disabled.
    462            *   This parameter can be any combination of the @ref TIM5_IT_TypeDef enumeration.
    463            * @param  NewState : The new state of the TIM5 peripheral.
    464            *   This parameter can be any of the @ref FunctionalState enumeration.
    465            * @retval None
    466            */

   \                                 In section .near_func.text, align 1, keep-with-next
    467          void TIM5_ITConfig(TIM5_IT_TypeDef TIM5_IT, FunctionalState NewState)
    468          {
    469            /* Check the parameters */
    470            assert_param(IS_TIM5_IT(TIM5_IT));
    471            assert_param(IS_FUNCTIONAL_STATE(NewState));
    472          
    473            if (NewState != DISABLE)
   \                     TIM5_ITConfig:
   \   000000 3D00                  TNZ       S:?b0
   \   000002 2707                  JREQ      L:??TIM5_ITConfig_0
    474            {
    475              /* Enable the Interrupt sources */
    476              TIM5->IER |= (uint8_t)TIM5_IT;
   \   000004 CA5305                OR        A, L:0x5305
   \   000007 C75305                LD        L:0x5305, A
   \   00000A 81                    RET
    477            }
    478            else
    479            {
    480              /* Disable the Interrupt sources */
    481              TIM5->IER &= (uint8_t)(~(uint8_t)TIM5_IT);
   \                     ??TIM5_ITConfig_0:
   \   00000B 43                    CPL       A
   \   00000C C45305                AND       A, L:0x5305
   \   00000F C75305                LD        L:0x5305, A
    482            }
    483          }
   \   000012 81                    RET
    484          
    485          /**
    486            * @brief  Enables or disables the TIM5 DMA Requests.
    487            * @param  TIM5_DMASources: specifies the DMA Request sources.
    488            *   This parameter can be any combination of  @ref TIM5_DMASource_TypeDef enumeration.
    489            * @param  NewState: new state of the DMA Request sources.
    490            *   This parameter can be: ENABLE or DISABLE.
    491            * @retval None
    492            */

   \                                 In section .near_func.text, align 1, keep-with-next
    493          void TIM5_DMACmd( TIM5_DMASource_TypeDef TIM5_DMASource, FunctionalState NewState)
    494          {
    495            /* Check the parameters */
    496            assert_param(IS_FUNCTIONAL_STATE(NewState));
    497            assert_param(IS_TIM5_DMA_SOURCE(TIM5_DMASource));
    498          
    499            if (NewState != DISABLE)
   \                     TIM5_DMACmd:
   \   000000 3D00                  TNZ       S:?b0
   \   000002 2707                  JREQ      L:??TIM5_DMACmd_0
    500            {
    501              /* Enable the DMA sources */
    502              TIM5->DER |= TIM5_DMASource;
   \   000004 CA5304                OR        A, L:0x5304
   \   000007 C75304                LD        L:0x5304, A
   \   00000A 81                    RET
    503            }
    504            else
    505            {
    506              /* Disable the DMA sources */
    507              TIM5->DER &= (uint8_t)(~TIM5_DMASource);
   \                     ??TIM5_DMACmd_0:
   \   00000B 43                    CPL       A
   \   00000C C45304                AND       A, L:0x5304
   \   00000F C75304                LD        L:0x5304, A
    508            }
    509          }
   \   000012 81                    RET
    510          
    511          /**
    512            * @brief  Enables the TIM5 internal Clock.
    513            * @par Parameters:
    514            * None
    515            * @retval None
    516            */

   \                                 In section .near_func.text, align 1, keep-with-next
    517          void TIM5_InternalClockConfig(void)
    518          {
    519            /* Disable slave mode to clock the prescaler directly with the internal clock */
    520            TIM5->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
   \                     TIM5_InternalClockConfig:
   \   000000 C65302                LD        A, L:0x5302
   \   000003 A4F8                  AND       A, #0xf8
   \   000005 C75302                LD        L:0x5302, A
    521          }
   \   000008 81                    RET
    522          
    523          /**
    524            * @brief  Configures the TIM5 External clock Mode1.
    525            * @param  TIM5_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    526            *   This parameter can be one of @ref TIM5_ExtTRGPSC_TypeDef enumeration.
    527            * @param  TIM5_ExtTRGPolarity : Specifies the external Trigger Polarity.
    528            *   This parameter can be one of @ref TIM5_ExtTRGPolarity_TypeDef enumeration.
    529            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    530            *   This parameter must be a value between 0x00 and 0x0F
    531            * @retval None
    532            */

   \                                 In section .near_func.text, align 1, keep-with-next
    533          void TIM5_ETRClockMode1Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
    534                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
    535                                        uint8_t ExtTRGFilter)
    536          {
    537            /* Configure the ETR Clock source */
    538            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM5_ETRClockMode1Config:
   \   000000 CD0000                CALL      L:TIM5_ETRConfig
    539          
    540            /* Select the External clock mode1 */
    541            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
   \   000003 C65302                LD        A, L:0x5302
   \   000006 A4F8                  AND       A, #0xf8
   \   000008 C75302                LD        L:0x5302, A
    542            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
   \   00000B C65302                LD        A, L:0x5302
   \   00000E AA07                  OR        A, #0x7
   \   000010 C75302                LD        L:0x5302, A
    543          
    544            /* Select the Trigger selection : ETRF */
    545            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_TS);
   \   000013 C65302                LD        A, L:0x5302
   \   000016 A48F                  AND       A, #0x8f
   \   000018 C75302                LD        L:0x5302, A
    546            TIM5->SMCR |= (uint8_t)((TIM5_TRGSelection_TypeDef)TIM5_TRGSelection_ETRF);
   \   00001B C65302                LD        A, L:0x5302
   \   00001E AA70                  OR        A, #0x70
   \   000020 C75302                LD        L:0x5302, A
    547          }
   \   000023 81                    RET
    548          
    549          /**
    550            * @brief  Configures the TIM5 External clock Mode2.
    551            * @param  TIM5_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    552            *   This parameter can be one of the @ref TIM5_ExtTRGPSC_TypeDef enumeration.
    553            * @param  TIM5_ExtTRGPolarity : Specifies the external Trigger Polarity.
    554            *   This parameter can be one of the @ref TIM5_ExtTRGPolarity_TypeDef enumeration.
    555            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    556            *   This parameter must be a value between 0x00 and 0x0F
    557            * @retval None
    558            */

   \                                 In section .near_func.text, align 1, keep-with-next
    559          void TIM5_ETRClockMode2Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
    560                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
    561                                        uint8_t ExtTRGFilter)
    562          {
    563            /* Configure the ETR Clock source */
    564            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM5_ETRClockMode2Config:
   \   000000 CD0000                CALL      L:TIM5_ETRConfig
    565          
    566            /* Enable the External clock mode2 */
    567            TIM5->ETR |= TIM_ETR_ECE ;
   \   000003 721C5303              BSET      L:0x5303, #0x6
    568          }
   \   000007 81                    RET
    569          
    570          /**
    571            * @brief  Configures the TIM5 External Trigger.
    572            * @param  TIM5_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    573            *   This parameter can be one of the @ref TIM5_ExtTRGPSC_TypeDef enumeration.
    574            * @param  TIM5_ExtTRGPolarity : Specifies the external Trigger Polarity.
    575            *   This parameter can be one of the @ref TIM5_ExtTRGPolarity_TypeDef enumeration.
    576            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    577            *   This parameter must be a value between 0x00 and 0x0F
    578            * @retval None
    579            */

   \                                 In section .near_func.text, align 1, keep-with-next
    580          void TIM5_ETRConfig(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
    581                              TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
    582                              uint8_t ExtTRGFilter)
    583          {
   \                     TIM5_ETRConfig:
   \   000000 B700                  LD        S:?b2, A
   \   000002 B600                  LD        A, S:?b0
    584            /* Check the parameters */
    585            assert_param(IS_TIM5_EXT_PRESCALER(TIM5_ExtTRGPrescaler));
    586            assert_param(IS_TIM5_EXT_POLARITY(TIM5_ExtTRGPolarity));
    587            assert_param(IS_TIM5_EXT_FILTER(ExtTRGFilter));
    588          
    589            /* Set the Prescaler, the Filter value and the Polarity */
    590            TIM5->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM5_ExtTRGPrescaler | (uint8_t)TIM5_ExtTRGPolarity)
    591                                   | (uint8_t)ExtTRGFilter);
   \   000004 BA00                  OR        A, S:?b2
   \   000006 BA00                  OR        A, S:?b1
   \   000008 CA5303                OR        A, L:0x5303
   \   00000B C75303                LD        L:0x5303, A
    592          }
   \   00000E 81                    RET
    593          
    594          /**
    595            * @brief  Configures the TIM5 Trigger as External Clock.
    596            * @param  TIM5_TIxExternalCLKSource : Specifies Trigger source.
    597            *   This parameter can be one of the @ref TIM5_TIxExternalCLK1Source_TypeDef enumeration.
    598            * @param  TIM5_ICPolarity : Specifies the TIx Polarity.
    599            *   This parameter can be @ref TIM5_ICPolarity_TypeDef enumeration.
    600            * @param  ICFilter : Specifies the filter value.
    601            *   This parameter must be a value between 0x00 and 0x0F
    602            * @retval None
    603            */

   \                                 In section .near_func.text, align 1, keep-with-next
    604          void TIM5_TIxExternalClockConfig(TIM5_TIxExternalCLK1Source_TypeDef TIM5_TIxExternalCLKSource,
    605                                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    606                                           uint8_t ICFilter)
    607          {
   \                     TIM5_TIxExternalClockConfig:
   \   000000 B700                  LD        S:?b4, A
   \   000002 450000                MOV       S:?b2, S:?b0
    608            /* Check the parameters */
    609            assert_param(IS_TIM5_TIXCLK_SOURCE(TIM5_TIxExternalCLKSource));
    610            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
    611            assert_param(IS_TIM5_IC_FILTER(ICFilter));
    612          
    613            /* Configure the TIM5 Input Clock Source */
    614            if (TIM5_TIxExternalCLKSource == TIM5_TIxExternalCLK1Source_TI2)
   \   000005 B600                  LD        A, S:?b4
   \   000007 A160                  CP        A, #0x60
   \   000009 260B                  JRNE      L:??TIM5_TIxExternalClockConfig_0
    615            {
    616              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
   \   00000B 35010000              MOV       S:?b0, #0x1
   \   00000F B600                  LD        A, S:?b2
   \   000011 CD0000                CALL      L:TI2_Config
   \   000014 2009                  JRA       L:??TIM5_TIxExternalClockConfig_1
    617            }
    618            else
    619            {
    620              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
   \                     ??TIM5_TIxExternalClockConfig_0:
   \   000016 35010000              MOV       S:?b0, #0x1
   \   00001A B600                  LD        A, S:?b2
   \   00001C CD0000                CALL      L:TI1_Config
    621            }
    622          
    623            /* Select the Trigger source */
    624            TIM5_SelectInputTrigger((TIM5_TRGSelection_TypeDef)TIM5_TIxExternalCLKSource);
   \                     ??TIM5_TIxExternalClockConfig_1:
   \   00001F B600                  LD        A, S:?b4
   \   000021 CD0000                CALL      L:TIM5_SelectInputTrigger
    625          
    626            /* Select the External clock mode1 */
    627            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
   \   000024 C65302                LD        A, L:0x5302
   \   000027 AA07                  OR        A, #0x7
   \   000029 C75302                LD        L:0x5302, A
    628          }
   \   00002C 81                    RET
    629          
    630          /**
    631            * @brief  Selects the TIM5 Input Trigger source.
    632            * @param  TIM5_InputTriggerSource : Specifies Input Trigger source.
    633            *   This parameter can be one of the @ref TIM5_TRGSelection_TypeDef enumeration.
    634            * @retval None
    635            */

   \                                 In section .near_func.text, align 1, keep-with-next
    636          void TIM5_SelectInputTrigger(TIM5_TRGSelection_TypeDef TIM5_InputTriggerSource)
    637          {
   \                     TIM5_SelectInputTrigger:
   \   000000 B700                  LD        S:?b0, A
    638            uint8_t tmpsmcr = 0;
   \   000002 3F00                  CLR       S:?b1
    639          
    640            /* Check the parameters */
    641            assert_param(IS_TIM5_TRIGGER_SELECTION(TIM5_InputTriggerSource));
    642          
    643            tmpsmcr = TIM5->SMCR;
   \   000004 C65302                LD        A, L:0x5302
   \   000007 B700                  LD        S:?b1, A
    644          
    645            /* Select the Tgigger Source */
    646            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    647            tmpsmcr |= (uint8_t)TIM5_InputTriggerSource;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    648          
    649            TIM5->SMCR = (uint8_t)tmpsmcr;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75302                LD        L:0x5302, A
    650          }
   \   00001A 81                    RET
    651          
    652          /**
    653            * @brief  Enables or Disables the TIM5 Update event.
    654            * @param  NewState : The new state of the TIM5 peripheral Preload register.
    655            *   This parameter can be any of the @ref FunctionalState enumeration.
    656            * @retval None
    657            */
    658          

   \                                 In section .near_func.text, align 1, keep-with-next
    659          void TIM5_UpdateDisableConfig(FunctionalState NewState)
    660          {
    661            /* Check the parameters */
    662            assert_param(IS_FUNCTIONAL_STATE(NewState));
    663          
    664            /* Set or Reset the UDIS Bit */
    665            if (NewState != DISABLE)
   \                     TIM5_UpdateDisableConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_UpdateDisableConfig_0
    666            {
    667              TIM5->CR1 |= TIM_CR1_UDIS;
   \   000003 72125300              BSET      L:0x5300, #0x1
   \   000007 81                    RET
    668            }
    669            else
    670            {
    671              TIM5->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
   \                     ??TIM5_UpdateDisableConfig_0:
   \   000008 72135300              BRES      L:0x5300, #0x1
    672            }
    673          }
   \   00000C 81                    RET
    674          
    675          /**
    676            * @brief  Selects the TIM5 Update Request Interrupt source.
    677            * @param  TIM5_UpdateSource : Specifies the Update source.
    678            *   This parameter can be one of the @ref TIM5_UpdateSource_TypeDef enumeration.
    679            * @retval None
    680            */

   \                                 In section .near_func.text, align 1, keep-with-next
    681          void TIM5_UpdateRequestConfig(TIM5_UpdateSource_TypeDef TIM5_UpdateSource)
    682          {
    683            /* Check the parameters */
    684            assert_param(IS_TIM5_UPDATE_SOURCE(TIM5_UpdateSource));
    685          
    686            /* Set or Reset the URS Bit */
    687            if (TIM5_UpdateSource == TIM5_UpdateSource_Regular)
   \                     TIM5_UpdateRequestConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM5_UpdateRequestConfig_0
    688            {
    689              TIM5->CR1 |= TIM_CR1_URS ;
   \   000004 72145300              BSET      L:0x5300, #0x2
   \   000008 81                    RET
    690            }
    691            else
    692            {
    693              TIM5->CR1 &= (uint8_t)(~TIM_CR1_URS);
   \                     ??TIM5_UpdateRequestConfig_0:
   \   000009 72155300              BRES      L:0x5300, #0x2
    694            }
    695          }
   \   00000D 81                    RET
    696          
    697          /**
    698            * @brief  Enables or Disables the TIMs Hall sensor interface.
    699            * @param  NewState : The new state of the TIM5 Hall sensor interface.
    700            *   This parameter can be any of the @ref FunctionalState enumeration.
    701            * @retval None
    702            */

   \                                 In section .near_func.text, align 1, keep-with-next
    703          void TIM5_SelectHallSensor(FunctionalState NewState)
    704          {
    705            /* Check the parameters */
    706            assert_param(IS_FUNCTIONAL_STATE(NewState));
    707          
    708            /* Set or Reset the TI1S Bit */
    709            if (NewState != DISABLE)
   \                     TIM5_SelectHallSensor:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_SelectHallSensor_0
    710            {
    711              TIM5->CR2 |= TIM_CR2_TI1S;
   \   000003 721E5301              BSET      L:0x5301, #0x7
   \   000007 81                    RET
    712            }
    713            else
    714            {
    715              TIM5->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
   \                     ??TIM5_SelectHallSensor_0:
   \   000008 721F5301              BRES      L:0x5301, #0x7
    716            }
    717          }
   \   00000C 81                    RET
    718          
    719          /**
    720            * @brief  Selects the TIMs One Pulse Mode.
    721            * @param  TIM5_OPMode : Specifies the OPM Mode to be used.
    722            *   This parameter can be one of the @ref TIM5_OPMode_TypeDef enumeration.
    723            * @retval None
    724            */

   \                                 In section .near_func.text, align 1, keep-with-next
    725          void TIM5_SelectOnePulseMode(TIM5_OPMode_TypeDef TIM5_OPMode)
    726          {
    727            /* Check the parameters */
    728            assert_param(IS_TIM5_OPM_MODE(TIM5_OPMode));
    729          
    730            /* Set or Reset the OPM Bit */
    731            if (TIM5_OPMode == TIM5_OPMode_Single)
   \                     TIM5_SelectOnePulseMode:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM5_SelectOnePulseMode_0
    732            {
    733              TIM5->CR1 |= TIM_CR1_OPM ;
   \   000004 72165300              BSET      L:0x5300, #0x3
   \   000008 81                    RET
    734            }
    735            else
    736            {
    737              TIM5->CR1 &= (uint8_t)(~TIM_CR1_OPM);
   \                     ??TIM5_SelectOnePulseMode_0:
   \   000009 72175300              BRES      L:0x5300, #0x3
    738            }
    739          }
   \   00000D 81                    RET
    740          
    741          /**
    742            * @brief  Selects the TIM5 Trigger Output Mode.
    743            * @param  TIM5_TRGOSource : Specifies the Trigger Output source.
    744            *   This parameter can be one of the @ref TIM5_TRGOSource_TypeDef enumeration.
    745            * @retval None
    746            */

   \                                 In section .near_func.text, align 1, keep-with-next
    747          void TIM5_SelectOutputTrigger(TIM5_TRGOSource_TypeDef TIM5_TRGOSource)
    748          {
   \                     TIM5_SelectOutputTrigger:
   \   000000 B700                  LD        S:?b0, A
    749            uint8_t tmpcr2 = 0;
   \   000002 3F00                  CLR       S:?b1
    750          
    751            /* Check the parameters */
    752            assert_param(IS_TIM5_TRGO_SOURCE(TIM5_TRGOSource));
    753          
    754            tmpcr2 = TIM5->CR2;
   \   000004 C65301                LD        A, L:0x5301
   \   000007 B700                  LD        S:?b1, A
    755          
    756            /* Reset the MMS Bits */
    757            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    758          
    759            /* Select the TRGO source */
    760            tmpcr2 |=  (uint8_t)TIM5_TRGOSource;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    761          
    762            TIM5->CR2 = tmpcr2;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75301                LD        L:0x5301, A
    763          }
   \   00001A 81                    RET
    764          
    765          /**
    766            * @brief  Selects the TIM5 Slave Mode.
    767            * @param  TIM5_SlaveMode : Specifies the TIM5 Slave Mode.
    768            *   This parameter can be one of the @ref TIM5_SlaveMode_TypeDef enumeration.
    769            * @retval None
    770            */

   \                                 In section .near_func.text, align 1, keep-with-next
    771          void TIM5_SelectSlaveMode(TIM5_SlaveMode_TypeDef TIM5_SlaveMode)
    772          {
   \                     TIM5_SelectSlaveMode:
   \   000000 B700                  LD        S:?b0, A
    773            uint8_t tmpsmcr = 0;
   \   000002 3F00                  CLR       S:?b1
    774          
    775            /* Check the parameters */
    776            assert_param(IS_TIM5_SLAVE_MODE(TIM5_SlaveMode));
    777          
    778            tmpsmcr = TIM5->SMCR;
   \   000004 C65302                LD        A, L:0x5302
   \   000007 B700                  LD        S:?b1, A
    779          
    780            /* Reset the SMS Bits */
    781            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A4F8                  AND       A, #0xf8
   \   00000D B700                  LD        S:?b1, A
    782          
    783            /* Select the Slave Mode */
    784            tmpsmcr |= (uint8_t)TIM5_SlaveMode;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    785          
    786            TIM5->SMCR = tmpsmcr;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75302                LD        L:0x5302, A
    787          }
   \   00001A 81                    RET
    788          
    789          /**
    790            * @brief  Sets or Resets the TIM5 Master/Slave Mode.
    791            * @param  NewState : The new state of the synchronization between TIM5 and its slaves (through TRGO).
    792            *   This parameter can be any of the @ref FunctionalState enumeration.
    793            * @retval None
    794            */

   \                                 In section .near_func.text, align 1, keep-with-next
    795          void TIM5_SelectMasterSlaveMode(FunctionalState NewState)
    796          {
    797            /* Check the parameters */
    798            assert_param(IS_FUNCTIONAL_STATE(NewState));
    799          
    800            /* Set or Reset the MSM Bit */
    801            if (NewState != DISABLE)
   \                     TIM5_SelectMasterSlaveMode:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_SelectMasterSlaveMode_0
    802            {
    803              TIM5->SMCR |= TIM_SMCR_MSM;
   \   000003 721E5302              BSET      L:0x5302, #0x7
   \   000007 81                    RET
    804            }
    805            else
    806            {
    807              TIM5->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
   \                     ??TIM5_SelectMasterSlaveMode_0:
   \   000008 721F5302              BRES      L:0x5302, #0x7
    808            }
    809          }
   \   00000C 81                    RET
    810          
    811          /**
    812            * @brief  Configures the TIM5 Encoder Interface.
    813            * @param  TIM5_EncoderMode : Specifies the TIM5 Encoder Mode.
    814            *   This parameter can be one of the @ref TIM5_EncoderMode_TypeDef enumeration.
    815            * @param  TIM5_IC1Polarity : Specifies the IC1 Polarity.
    816            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
    817            * @param  TIM5_IC2Polarity : Specifies the IC2 Polarity.
    818            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
    819            * @retval None
    820            */

   \                                 In section .near_func.text, align 1, keep-with-next
    821          void TIM5_EncoderInterfaceConfig(TIM5_EncoderMode_TypeDef TIM5_EncoderMode,
    822                                           TIM5_ICPolarity_TypeDef TIM5_IC1Polarity,
    823                                           TIM5_ICPolarity_TypeDef TIM5_IC2Polarity)
    824          {
   \                     TIM5_EncoderInterfaceConfig:
   \   000000 B700                  LD        S:?b4, A
    825            uint8_t tmpsmcr = 0;
   \   000002 3F00                  CLR       S:?b5
    826            uint8_t tmpccmr1 = 0;
   \   000004 3F00                  CLR       S:?b2
    827            uint8_t tmpccmr2 = 0;
   \   000006 3F00                  CLR       S:?b3
    828          
    829            /* Check the parameters */
    830            assert_param(IS_TIM5_ENCODER_MODE(TIM5_EncoderMode));
    831            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC1Polarity));
    832            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC2Polarity));
    833          
    834            tmpsmcr = TIM5->SMCR;
   \   000008 C65302                LD        A, L:0x5302
   \   00000B B700                  LD        S:?b5, A
    835            tmpccmr1 = TIM5->CCMR1;
   \   00000D C65309                LD        A, L:0x5309
   \   000010 B700                  LD        S:?b2, A
    836            tmpccmr2 = TIM5->CCMR2;
   \   000012 C6530A                LD        A, L:0x530a
   \   000015 B700                  LD        S:?b3, A
    837          
    838            /* Set the encoder Mode */
    839            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
   \   000017 B600                  LD        A, S:?b5
   \   000019 A4F0                  AND       A, #0xf0
   \   00001B B700                  LD        S:?b5, A
    840            tmpsmcr |= (uint8_t)TIM5_EncoderMode;
   \   00001D B600                  LD        A, S:?b4
   \   00001F BA00                  OR        A, S:?b5
   \   000021 B700                  LD        S:?b5, A
    841          
    842            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
    843            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000023 B600                  LD        A, S:?b2
   \   000025 A4FC                  AND       A, #0xfc
   \   000027 B700                  LD        S:?b2, A
    844            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
   \   000029 B600                  LD        A, S:?b3
   \   00002B A4FC                  AND       A, #0xfc
   \   00002D B700                  LD        S:?b3, A
    845            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
   \   00002F B600                  LD        A, S:?b2
   \   000031 AA01                  OR        A, #0x1
   \   000033 B700                  LD        S:?b2, A
    846            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
   \   000035 B600                  LD        A, S:?b3
   \   000037 AA01                  OR        A, #0x1
   \   000039 B700                  LD        S:?b3, A
    847          
    848            /* Set the TI1 and the TI2 Polarities */
    849            if (TIM5_IC1Polarity == TIM5_ICPolarity_Falling)
   \   00003B B600                  LD        A, S:?b0
   \   00003D A101                  CP        A, #0x1
   \   00003F 2606                  JRNE      L:??TIM5_EncoderInterfaceConfig_0
    850            {
    851              TIM5->CCER1 |= TIM_CCER1_CC1P ;
   \   000041 7212530B              BSET      L:0x530b, #0x1
   \   000045 2004                  JRA       L:??TIM5_EncoderInterfaceConfig_1
    852            }
    853            else
    854            {
    855              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM5_EncoderInterfaceConfig_0:
   \   000047 7213530B              BRES      L:0x530b, #0x1
    856            }
    857          
    858            if (TIM5_IC2Polarity == TIM5_ICPolarity_Falling)
   \                     ??TIM5_EncoderInterfaceConfig_1:
   \   00004B B600                  LD        A, S:?b1
   \   00004D A101                  CP        A, #0x1
   \   00004F 2606                  JRNE      L:??TIM5_EncoderInterfaceConfig_2
    859            {
    860              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000051 721A530B              BSET      L:0x530b, #0x5
   \   000055 2004                  JRA       L:??TIM5_EncoderInterfaceConfig_3
    861            }
    862            else
    863            {
    864              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM5_EncoderInterfaceConfig_2:
   \   000057 721B530B              BRES      L:0x530b, #0x5
    865            }
    866          
    867            TIM5->SMCR = tmpsmcr;
   \                     ??TIM5_EncoderInterfaceConfig_3:
   \   00005B B600                  LD        A, S:?b5
   \   00005D C75302                LD        L:0x5302, A
    868            TIM5->CCMR1 = tmpccmr1;
   \   000060 B600                  LD        A, S:?b2
   \   000062 C75309                LD        L:0x5309, A
    869            TIM5->CCMR2 = tmpccmr2;
   \   000065 B600                  LD        A, S:?b3
   \   000067 C7530A                LD        L:0x530a, A
    870          }
   \   00006A 81                    RET
    871          
    872          /**
    873            * @brief  Configures the TIM5 Prescaler.
    874            * @param  Prescaler : Specifies the Prescaler Register value
    875            *   This parameter can be one of the @ref TIM5_Prescaler_TypeDef enumeration.
    876            * @param  TIM5_PSCReloadMode : Specifies the TIM5 Prescaler Reload mode.
    877            *   This parameter can be one of the @ref TIM5_PSCReloadMode_TypeDef enumeration.
    878            * @retval None
    879            */

   \                                 In section .near_func.text, align 1, keep-with-next
    880          void TIM5_PrescalerConfig(TIM5_Prescaler_TypeDef Prescaler,
    881                                    TIM5_PSCReloadMode_TypeDef TIM5_PSCReloadMode)
    882          {
    883            /* Check the parameters */
    884            assert_param(IS_TIM5_PRESCALER(Prescaler));
    885            assert_param(IS_TIM5_PRESCALER_RELOAD(TIM5_PSCReloadMode));
    886          
    887            /* Set the Prescaler value */
    888            TIM5->PSCR = (uint8_t)(Prescaler);
   \                     TIM5_PrescalerConfig:
   \   000000 C7530E                LD        L:0x530e, A
    889          
    890            /* Set or reset the UG Bit */
    891            if (TIM5_PSCReloadMode == TIM5_PSCReloadMode_Immediate)
   \   000003 B600                  LD        A, S:?b0
   \   000005 A101                  CP        A, #0x1
   \   000007 2605                  JRNE      L:??TIM5_PrescalerConfig_0
    892            {
    893              TIM5->EGR |= TIM_EGR_UG ;
   \   000009 72105308              BSET      L:0x5308, #0x0
   \   00000D 81                    RET
    894            }
    895            else
    896            {
    897              TIM5->EGR &= (uint8_t)(~TIM_EGR_UG) ;
   \                     ??TIM5_PrescalerConfig_0:
   \   00000E 72115308              BRES      L:0x5308, #0x0
    898            }
    899          }
   \   000012 81                    RET
    900          
    901          /**
    902            * @brief  Specifies the TIM5 Counter Mode to be used.
    903            * @param  TIM5_CounterMode : Specifies the Counter Mode to be used
    904            *   This parameter can be one of the @ref TIM5_CounterMode_TypeDef enumeration.
    905            * @retval None
    906            */

   \                                 In section .near_func.text, align 1, keep-with-next
    907          void TIM5_CounterModeConfig(TIM5_CounterMode_TypeDef TIM5_CounterMode)
    908          {
   \                     TIM5_CounterModeConfig:
   \   000000 B700                  LD        S:?b0, A
    909            uint8_t tmpcr1 = 0;
   \   000002 3F00                  CLR       S:?b1
    910          
    911            /* Check the parameters */
    912            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    913          
    914            tmpcr1 = TIM5->CR1;
   \   000004 C65300                LD        A, L:0x5300
   \   000007 B700                  LD        S:?b1, A
    915          
    916            /* Reset the CMS and DIR Bits */
    917            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    918          
    919            /* Set the Counter Mode */
    920            tmpcr1 |= (uint8_t)TIM5_CounterMode;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    921          
    922            TIM5->CR1 = tmpcr1;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75300                LD        L:0x5300, A
    923          }
   \   00001A 81                    RET
    924          
    925          /**
    926            * @brief  Forces the TIM5 Channel1 output waveform to active or inactive level.
    927            * @param  TIM5_ForcedAction : Specifies the forced Action to be set to the output waveform.
    928            *   This parameter can be one of the @ref TIM5_ForcedAction_TypeDef enumeration.
    929            * @retval None
    930            */

   \                                 In section .near_func.text, align 1, keep-with-next
    931          void TIM5_ForcedOC1Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    932          {
   \                     TIM5_ForcedOC1Config:
   \   000000 B700                  LD        S:?b0, A
    933            uint8_t tmpccmr1 = 0;
   \   000002 3F00                  CLR       S:?b1
    934          
    935            /* Check the parameters */
    936            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    937          
    938            tmpccmr1 = TIM5->CCMR1;
   \   000004 C65309                LD        A, L:0x5309
   \   000007 B700                  LD        S:?b1, A
    939          
    940            /* Reset the OCM Bits */
    941            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    942          
    943            /* Configure The Forced output Mode */
    944            tmpccmr1 |= (uint8_t)TIM5_ForcedAction;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    945          
    946            TIM5->CCMR1 = tmpccmr1;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75309                LD        L:0x5309, A
    947          }
   \   00001A 81                    RET
    948          
    949          /**
    950            * @brief  Forces the TIM5 Channel2 output waveform to active or inactive level.
    951            * @param  TIM5_ForcedAction : Specifies the forced Action to be set to the output waveform.
    952            *   This parameter can be one of the @ref TIM5_ForcedAction_TypeDef enumeration.
    953            * @retval None
    954            */

   \                                 In section .near_func.text, align 1, keep-with-next
    955          void TIM5_ForcedOC2Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    956          {
   \                     TIM5_ForcedOC2Config:
   \   000000 B700                  LD        S:?b0, A
    957            uint8_t tmpccmr2 = 0;
   \   000002 3F00                  CLR       S:?b1
    958          
    959            /* Check the parameters */
    960            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    961          
    962            tmpccmr2 = TIM5->CCMR2;
   \   000004 C6530A                LD        A, L:0x530a
   \   000007 B700                  LD        S:?b1, A
    963          
    964            /* Reset the OCM Bits */
    965            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A48F                  AND       A, #0x8f
   \   00000D B700                  LD        S:?b1, A
    966          
    967            /* Configure The Forced output Mode */
    968            tmpccmr2 |= (uint8_t)TIM5_ForcedAction;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
    969          
    970            TIM5->CCMR2 = tmpccmr2;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C7530A                LD        L:0x530a, A
    971          }
   \   00001A 81                    RET
    972          
    973          /**
    974            * @brief  Enables or disables TIM5 peripheral Preload register on ARR.
    975            * @param  NewState : The new state of the TIM5 peripheral Preload register.
    976            *   This parameter can be any of the @ref FunctionalState enumeration.
    977            * @retval None
    978            */

   \                                 In section .near_func.text, align 1, keep-with-next
    979          void TIM5_ARRPreloadConfig(FunctionalState NewState)
    980          {
    981            /* Check the parameters */
    982            assert_param(IS_FUNCTIONAL_STATE(NewState));
    983          
    984            /* Set or Reset the ARPE Bit */
    985            if (NewState != DISABLE)
   \                     TIM5_ARRPreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_ARRPreloadConfig_0
    986            {
    987              TIM5->CR1 |= TIM_CR1_ARPE;
   \   000003 721E5300              BSET      L:0x5300, #0x7
   \   000007 81                    RET
    988            }
    989            else
    990            {
    991              TIM5->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
   \                     ??TIM5_ARRPreloadConfig_0:
   \   000008 721F5300              BRES      L:0x5300, #0x7
    992            }
    993          }
   \   00000C 81                    RET
    994          
    995          /**
    996            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR1.
    997            * @param  NewState : The new state of the Capture Compare Preload register.
    998            *   This parameter can be any of the @ref FunctionalState enumeration.
    999            * @retval None
   1000            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1001          void TIM5_OC1PreloadConfig(FunctionalState NewState)
   1002          {
   1003            /* Check the parameters */
   1004            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1005          
   1006            /* Set or Reset the OC1PE Bit */
   1007            if (NewState != DISABLE)
   \                     TIM5_OC1PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_OC1PreloadConfig_0
   1008            {
   1009              TIM5->CCMR1 |= TIM_CCMR_OCxPE ;
   \   000003 72165309              BSET      L:0x5309, #0x3
   \   000007 81                    RET
   1010            }
   1011            else
   1012            {
   1013              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM5_OC1PreloadConfig_0:
   \   000008 72175309              BRES      L:0x5309, #0x3
   1014            }
   1015          }
   \   00000C 81                    RET
   1016          
   1017          /**
   1018            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR2.
   1019            * @param  NewState : The new state of the Capture Compare Preload register.
   1020            *   This parameter can be any of the @ref FunctionalState enumeration.
   1021            * @retval None
   1022            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1023          void TIM5_OC2PreloadConfig(FunctionalState NewState)
   1024          {
   1025            /* Check the parameters */
   1026            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1027          
   1028            /* Set or Reset the OC2PE Bit */
   1029            if (NewState != DISABLE)
   \                     TIM5_OC2PreloadConfig:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_OC2PreloadConfig_0
   1030            {
   1031              TIM5->CCMR2 |= TIM_CCMR_OCxPE ;
   \   000003 7216530A              BSET      L:0x530a, #0x3
   \   000007 81                    RET
   1032            }
   1033            else
   1034            {
   1035              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   \                     ??TIM5_OC2PreloadConfig_0:
   \   000008 7217530A              BRES      L:0x530a, #0x3
   1036            }
   1037          }
   \   00000C 81                    RET
   1038          
   1039          /**
   1040            * @brief  Configures the TIM5 Capture Compare 1 Fast feature.
   1041            * @param  NewState : The new state of the Output Compare Fast Enable bit.
   1042            *   This parameter can be any of the @ref FunctionalState enumeration.
   1043            * @retval None
   1044            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1045          void TIM5_OC1FastCmd(FunctionalState NewState)
   1046          {
   1047            /* Check the parameters */
   1048            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1049          
   1050            /* Set or Reset the OC1FE Bit */
   1051            if (NewState != DISABLE)
   \                     TIM5_OC1FastCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_OC1FastCmd_0
   1052            {
   1053              TIM5->CCMR1 |= TIM_CCMR_OCxFE ;
   \   000003 72145309              BSET      L:0x5309, #0x2
   \   000007 81                    RET
   1054            }
   1055            else
   1056            {
   1057              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM5_OC1FastCmd_0:
   \   000008 72155309              BRES      L:0x5309, #0x2
   1058            }
   1059          }
   \   00000C 81                    RET
   1060          
   1061          /**
   1062            * @brief  Configures the TIM5 Capture Compare 2 Fast feature.
   1063            * @param  NewState : The new state of the Output Compare Fast Enable bit.
   1064            *   This parameter can be any of the @ref FunctionalState enumeration.
   1065            * @retval None
   1066            */
   1067          

   \                                 In section .near_func.text, align 1, keep-with-next
   1068          void TIM5_OC2FastCmd(FunctionalState NewState)
   1069          {
   1070            /* Check the parameters */
   1071            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1072          
   1073            /* Set or Reset the OC2FE Bit */
   1074            if (NewState != DISABLE)
   \                     TIM5_OC2FastCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_OC2FastCmd_0
   1075            {
   1076              TIM5->CCMR2 |= TIM_CCMR_OCxFE ;
   \   000003 7214530A              BSET      L:0x530a, #0x2
   \   000007 81                    RET
   1077            }
   1078            else
   1079            {
   1080              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   \                     ??TIM5_OC2FastCmd_0:
   \   000008 7215530A              BRES      L:0x530a, #0x2
   1081            }
   1082          }
   \   00000C 81                    RET
   1083          
   1084          /**
   1085            * @brief  Configures the TIM5 event to be generated by software.
   1086            * @param  TIM5_EventSource : Specifies the event source.
   1087            *   This parameter can be one of the @ref TIM5_EventSource_TypeDef enumeration.
   1088            * @retval None
   1089            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1090          void TIM5_GenerateEvent(TIM5_EventSource_TypeDef TIM5_EventSource)
   1091          {
   1092            /* Check the parameters */
   1093            assert_param(IS_TIM5_EVENT_SOURCE((uint8_t)TIM5_EventSource));
   1094          
   1095            /* Set the event sources */
   1096            TIM5->EGR |= (uint8_t)TIM5_EventSource;
   \                     TIM5_GenerateEvent:
   \   000000 CA5308                OR        A, L:0x5308
   \   000003 C75308                LD        L:0x5308, A
   1097          }
   \   000006 81                    RET
   1098          
   1099          /**
   1100            * @brief  Configures the TIM5 Channel 1 polarity.
   1101            * @param  TIM5_OCPolarity : Specifies the OC1 Polarity.
   1102            *   This parameter can be one of the @ref TIM5_OCPolarity_TypeDef enumeration.
   1103            * @retval None
   1104            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1105          void TIM5_OC1PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1106          {
   1107            /* Check the parameters */
   1108            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1109          
   1110            /* Set or Reset the CC1P Bit */
   1111            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     TIM5_OC1PolarityConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM5_OC1PolarityConfig_0
   1112            {
   1113              TIM5->CCER1 |= TIM_CCER1_CC1P ;
   \   000004 7212530B              BSET      L:0x530b, #0x1
   \   000008 81                    RET
   1114            }
   1115            else
   1116            {
   1117              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   \                     ??TIM5_OC1PolarityConfig_0:
   \   000009 7213530B              BRES      L:0x530b, #0x1
   1118            }
   1119          }
   \   00000D 81                    RET
   1120          
   1121          /**
   1122            * @brief  Configures the TIM5 Channel 2 polarity.
   1123            * @param  TIM5_OCPolarity : Specifies the OC2 Polarity.
   1124            *   This parameter can be one of the @ref TIM5_OCPolarity_TypeDef enumeration.
   1125            * @retval None
   1126            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1127          void TIM5_OC2PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1128          {
   1129            /* Check the parameters */
   1130            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1131          
   1132            /* Set or Reset the CC2P Bit */
   1133            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   \                     TIM5_OC2PolarityConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??TIM5_OC2PolarityConfig_0
   1134            {
   1135              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000004 721A530B              BSET      L:0x530b, #0x5
   \   000008 81                    RET
   1136            }
   1137            else
   1138            {
   1139              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TIM5_OC2PolarityConfig_0:
   \   000009 721B530B              BRES      L:0x530b, #0x5
   1140            }
   1141          }
   \   00000D 81                    RET
   1142          
   1143          /**
   1144            * @brief  Enables or disables the TIM5 Capture Compare Channel x.
   1145            * @param  TIM5_Channel : Specifies the TIM5 Channel.
   1146            *   This parameter can be one of @ref TIM5_Channel_TypeDef enumeration.
   1147            * @param  NewState : Specifies the TIM5 Channel CCxE bit new state.
   1148            *   This parameter can be any of the @ref FunctionalState enumeration.
   1149            * @retval None
   1150            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1151          void TIM5_CCxCmd(TIM5_Channel_TypeDef TIM5_Channel,
   1152                           FunctionalState NewState)
   1153          {
   1154            /* Check the parameters */
   1155            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1156            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1157          
   1158            if (TIM5_Channel == TIM5_Channel_1)
   \                     TIM5_CCxCmd:
   \   000000 4D                    TNZ       A
   \   000001 260E                  JRNE      L:??TIM5_CCxCmd_0
   1159            {
   1160              /* Set or Reset the CC1E Bit */
   1161              if (NewState != DISABLE)
   \   000003 3D00                  TNZ       S:?b0
   \   000005 2705                  JREQ      L:??TIM5_CCxCmd_1
   1162              {
   1163                TIM5->CCER1 |= TIM_CCER1_CC1E ;
   \   000007 7210530B              BSET      L:0x530b, #0x0
   \   00000B 81                    RET
   1164              }
   1165              else
   1166              {
   1167                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   \                     ??TIM5_CCxCmd_1:
   \   00000C 7211530B              BRES      L:0x530b, #0x0
   \   000010 81                    RET
   1168              }
   1169          
   1170            }
   1171            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1172            {
   1173              /* Set or Reset the CC2E Bit */
   1174              if (NewState != DISABLE)
   \                     ??TIM5_CCxCmd_0:
   \   000011 3D00                  TNZ       S:?b0
   \   000013 2705                  JREQ      L:??TIM5_CCxCmd_2
   1175              {
   1176                TIM5->CCER1 |= TIM_CCER1_CC2E;
   \   000015 7218530B              BSET      L:0x530b, #0x4
   \   000019 81                    RET
   1177              }
   1178              else
   1179              {
   1180                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   \                     ??TIM5_CCxCmd_2:
   \   00001A 7219530B              BRES      L:0x530b, #0x4
   1181              }
   1182            }
   1183          }
   \   00001E 81                    RET
   1184          
   1185          /**
   1186            * @brief  Selects the TIM5 Ouput Compare Mode. This function disables the
   1187            * selected channel before changing the Ouput Compare Mode. User has to
   1188            * enable this channel using TIM5_CCxCmd and TIM5_CCxNCmd functions.
   1189            * @param  TIM5_Channel : Specifies the TIM5 Channel.
   1190            *   This parameter can be one of the @ref TIM5_Channel_TypeDef enumeration
   1191            * @param  TIM5_OCMode : Specifies the TIM5 Output Compare Mode.
   1192            *   This parameter can be one of the @ref TIM5_OCMode_TypeDef enumeration.
   1193            * @retval None
   1194            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1195          void TIM5_SelectOCxM(TIM5_Channel_TypeDef TIM5_Channel,
   1196                               TIM5_OCMode_TypeDef TIM5_OCMode)
   1197          {
   1198            /* Check the parameters */
   1199            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1200            assert_param(IS_TIM5_OCM(TIM5_OCMode));
   1201          
   1202            if (TIM5_Channel == TIM5_Channel_1)
   \                     TIM5_SelectOCxM:
   \   000000 4D                    TNZ       A
   \   000001 2615                  JRNE      L:??TIM5_SelectOCxM_0
   1203            {
   1204              /* Disable the Channel 1: Reset the CCE Bit */
   1205              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   \   000003 7211530B              BRES      L:0x530b, #0x0
   1206          
   1207              /* Reset the Output Compare Bits */
   1208              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
   \   000007 C65309                LD        A, L:0x5309
   \   00000A A48F                  AND       A, #0x8f
   \   00000C C75309                LD        L:0x5309, A
   1209          
   1210              /* Set the Ouput Compare Mode */
   1211              TIM5->CCMR1 |= (uint8_t)TIM5_OCMode;
   \   00000F B600                  LD        A, S:?b0
   \   000011 CA5309                OR        A, L:0x5309
   \   000014 C75309                LD        L:0x5309, A
   \   000017 81                    RET
   1212            }
   1213            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1214            {
   1215              /* Disable the Channel 2: Reset the CCE Bit */
   1216              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   \                     ??TIM5_SelectOCxM_0:
   \   000018 7219530B              BRES      L:0x530b, #0x4
   1217          
   1218              /* Reset the Output Compare Bits */
   1219              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
   \   00001C C6530A                LD        A, L:0x530a
   \   00001F A48F                  AND       A, #0x8f
   \   000021 C7530A                LD        L:0x530a, A
   1220          
   1221              /* Set the Ouput Compare Mode */
   1222              TIM5->CCMR2 |= (uint8_t)TIM5_OCMode;
   \   000024 B600                  LD        A, S:?b0
   \   000026 CA530A                OR        A, L:0x530a
   \   000029 C7530A                LD        L:0x530a, A
   1223            }
   1224          }
   \   00002C 81                    RET
   1225          
   1226          /**
   1227            * @brief  Sets the TIM5 Counter Register value.
   1228            * @param  Counter : Specifies the Counter register new value.
   1229            *   This parameter is between 0x0000 and 0xFFFF.
   1230            * @retval None
   1231            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1232          void TIM5_SetCounter(uint16_t Counter)
   1233          {
   \                     TIM5_SetCounter:
   \   000000 9093                  LDW       Y, X
   1234          
   1235            /* Set the Counter Register value */
   1236            TIM5->CNTRH = (uint8_t)(Counter >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C7530C                LD        L:0x530c, A
   1237            TIM5->CNTRL = (uint8_t)(Counter);
   \   000009 909F                  LD        A, YL
   \   00000B C7530D                LD        L:0x530d, A
   1238          }
   \   00000E 81                    RET
   1239          
   1240          /**
   1241            * @brief  Sets the TIM5 Autoreload Register value.
   1242            * @param  Autoreload : Specifies the Autoreload register new value.
   1243            *   This parameter is between 0x0000 and 0xFFFF.
   1244            * @retval None
   1245            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1246          void TIM5_SetAutoreload(uint16_t Autoreload)
   1247          {
   \                     TIM5_SetAutoreload:
   \   000000 9093                  LDW       Y, X
   1248            /* Set the Autoreload Register value */
   1249            TIM5->ARRH = (uint8_t)(Autoreload >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C7530F                LD        L:0x530f, A
   1250            TIM5->ARRL = (uint8_t)(Autoreload);
   \   000009 909F                  LD        A, YL
   \   00000B C75310                LD        L:0x5310, A
   1251          }
   \   00000E 81                    RET
   1252          
   1253          /**
   1254            * @brief  Sets the TIM5 Capture Compare1 Register value.
   1255            * @param  Compare : Specifies the Capture Compare1 register new value.
   1256            *   This parameter is between 0x0000 and 0xFFFF.
   1257            * @retval None
   1258            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1259          void TIM5_SetCompare1(uint16_t Compare)
   1260          {
   \                     TIM5_SetCompare1:
   \   000000 9093                  LDW       Y, X
   1261            /* Set the Capture Compare1 Register value */
   1262            TIM5->CCR1H = (uint8_t)(Compare >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C75311                LD        L:0x5311, A
   1263            TIM5->CCR1L = (uint8_t)(Compare);
   \   000009 909F                  LD        A, YL
   \   00000B C75312                LD        L:0x5312, A
   1264          }
   \   00000E 81                    RET
   1265          
   1266          /**
   1267            * @brief  Sets the TIM5 Capture Compare2 Register value.
   1268            * @param  Compare : Specifies the Capture Compare2 register new value.
   1269            *   This parameter is between 0x0000 and 0xFFFF.
   1270            * @retval None
   1271            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1272          void TIM5_SetCompare2(uint16_t Compare)
   1273          {
   \                     TIM5_SetCompare2:
   \   000000 9093                  LDW       Y, X
   1274            /* Set the Capture Compare2 Register value */
   1275            TIM5->CCR2H = (uint8_t)(Compare >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 C75313                LD        L:0x5313, A
   1276            TIM5->CCR2L = (uint8_t)(Compare);
   \   000009 909F                  LD        A, YL
   \   00000B C75314                LD        L:0x5314, A
   1277          }
   \   00000E 81                    RET
   1278          
   1279          /**
   1280            * @brief  Sets the TIM5 Input Capture 1 prescaler.
   1281            * @param  TIM5_IC1Prescaler : Specifies the Input Capture prescaler new value
   1282            *   This parameter can be one of the @ref TIM5_ICPSC_TypeDef enumeration.
   1283            * @retval None
   1284            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1285          void TIM5_SetIC1Prescaler(TIM5_ICPSC_TypeDef TIM5_IC1Prescaler)
   1286          {
   \                     TIM5_SetIC1Prescaler:
   \   000000 B700                  LD        S:?b0, A
   1287            uint8_t tmpccmr1 = 0;
   \   000002 3F00                  CLR       S:?b1
   1288          
   1289            /* Check the parameters */
   1290            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC1Prescaler));
   1291          
   1292            tmpccmr1 = TIM5->CCMR1;
   \   000004 C65309                LD        A, L:0x5309
   \   000007 B700                  LD        S:?b1, A
   1293          
   1294            /* Reset the IC1PSC Bits */
   1295            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A4F3                  AND       A, #0xf3
   \   00000D B700                  LD        S:?b1, A
   1296          
   1297            /* Set the IC1PSC value */
   1298            tmpccmr1 |= (uint8_t)TIM5_IC1Prescaler;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
   1299          
   1300            TIM5->CCMR1 = tmpccmr1;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C75309                LD        L:0x5309, A
   1301          }
   \   00001A 81                    RET
   1302          
   1303          /**
   1304            * @brief  Sets the TIM5 Input Capture 2 prescaler.
   1305            * @param  TIM5_IC2Prescaler : Specifies the Input Capture prescaler new value
   1306            *   This parameter can be one of the @ref TIM5_ICPSC_TypeDef enumeration.
   1307            * @retval None
   1308            */

   \                                 In section .near_func.text, align 1, keep-with-next
   1309          void TIM5_SetIC2Prescaler(TIM5_ICPSC_TypeDef TIM5_IC2Prescaler)
   1310          {
   \                     TIM5_SetIC2Prescaler:
   \   000000 B700                  LD        S:?b0, A
   1311            uint8_t tmpccmr2 = 0;
   \   000002 3F00                  CLR       S:?b1
   1312          
   1313            /* Check the parameters */
   1314            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC2Prescaler));
   1315          
   1316            tmpccmr2 = TIM5->CCMR2;
   \   000004 C6530A                LD        A, L:0x530a
   \   000007 B700                  LD        S:?b1, A
   1317          
   1318            /* Reset the IC2PSC Bits */
   1319            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   \   000009 B600                  LD        A, S:?b1
   \   00000B A4F3                  AND       A, #0xf3
   \   00000D B700                  LD        S:?b1, A
   1320          
   1321            /* Set the IC2PSC value */
   1322            tmpccmr2 |= (uint8_t)TIM5_IC2Prescaler;
   \   00000F B600                  LD        A, S:?b0
   \   000011 BA00                  OR        A, S:?b1
   \   000013 B700                  LD        S:?b1, A
   1323          
   1324            TIM5->CCMR2 = tmpccmr2;
   \   000015 B600                  LD        A, S:?b1
   \   000017 C7530A                LD        L:0x530a, A
   1325          }
   \   00001A 81                    RET
   1326          
   1327          /**
   1328            * @brief  Gets the TIM5 Input Capture 1 value.
   1329            * @param  None
   1330            * @retval Capture Compare 1 Register value.
   1331            */

   \                                 In section .near_func.text, align 1
   1332          uint16_t TIM5_GetCapture1(void)
   1333          {
   1334            uint16_t tmpccr1 = 0;
   \                     TIM5_GetCapture1:
   \   000000 905F                  CLRW      Y
   1335            uint8_t tmpccr1l, tmpccr1h;
   1336          
   1337            tmpccr1h = TIM5->CCR1H;
   \   000002 C65311                LD        A, L:0x5311
   \   000005 B700                  LD        S:?b0, A
   1338            tmpccr1l = TIM5->CCR1L;
   \   000007 C65312                LD        A, L:0x5312
   1339          
   1340            tmpccr1 = (uint16_t)(tmpccr1l);
   \   00000A 5F                    CLRW      X
   \   00000B 97                    LD        XL, A
   \   00000C 9093                  LDW       Y, X
   1341            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   \   00000E 5F                    CLRW      X
   \   00000F 41                    EXG       A, XL
   \   000010 B600                  LD        A, S:?b0
   \   000012 41                    EXG       A, XL
   \   000013 4F                    CLR       A
   \   000014 02                    RLWA      X, A
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 51                    EXGW      X, Y
   \   000018 01                    RRWA      X, A
   \   000019 BA00                  OR        A, S:?b1
   \   00001B 01                    RRWA      X, A
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 01                    RRWA      X, A
   \   00001F 51                    EXGW      X, Y
   1342            /* Get the Capture 1 Register value */
   1343            return ((uint16_t)tmpccr1);
   \   000020 93                    LDW       X, Y
   \   000021 81                    RET
   1344          }
   1345          
   1346          /**
   1347            * @brief  Gets the TIM5 Input Capture 2 value.
   1348            * @param  None
   1349            * @retval Capture Compare 2 Register value.
   1350            */

   \                                 In section .near_func.text, align 1
   1351          uint16_t TIM5_GetCapture2(void)
   1352          {
   1353            uint16_t tmpccr2 = 0;
   \                     TIM5_GetCapture2:
   \   000000 905F                  CLRW      Y
   1354            uint8_t tmpccr2l, tmpccr2h;
   1355          
   1356            tmpccr2h = TIM5->CCR2H;
   \   000002 C65313                LD        A, L:0x5313
   \   000005 B700                  LD        S:?b0, A
   1357            tmpccr2l = TIM5->CCR2L;
   \   000007 C65314                LD        A, L:0x5314
   1358          
   1359            tmpccr2 = (uint16_t)(tmpccr2l);
   \   00000A 5F                    CLRW      X
   \   00000B 97                    LD        XL, A
   \   00000C 9093                  LDW       Y, X
   1360            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   \   00000E 5F                    CLRW      X
   \   00000F 41                    EXG       A, XL
   \   000010 B600                  LD        A, S:?b0
   \   000012 41                    EXG       A, XL
   \   000013 4F                    CLR       A
   \   000014 02                    RLWA      X, A
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 51                    EXGW      X, Y
   \   000018 01                    RRWA      X, A
   \   000019 BA00                  OR        A, S:?b1
   \   00001B 01                    RRWA      X, A
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 01                    RRWA      X, A
   \   00001F 51                    EXGW      X, Y
   1361            /* Get the Capture 2 Register value */
   1362            return ((uint16_t)tmpccr2);
   \   000020 93                    LDW       X, Y
   \   000021 81                    RET
   1363          }
   1364          
   1365          /**
   1366            * @brief  Gets the TIM5 Counter value.
   1367            * @param  None
   1368            * @retval Counter Register value.
   1369            */

   \                                 In section .near_func.text, align 1
   1370          uint16_t TIM5_GetCounter(void)
   1371          {
   1372            uint16_t tmpcnt = 0;
   \                     TIM5_GetCounter:
   \   000000 905F                  CLRW      Y
   1373            uint8_t tmpcntrl, tmpcntrh;
   1374          
   1375            tmpcntrh = TIM5->CNTRH;
   \   000002 C6530C                LD        A, L:0x530c
   \   000005 B700                  LD        S:?b0, A
   1376            tmpcntrl = TIM5->CNTRL;
   \   000007 C6530D                LD        A, L:0x530d
   1377          
   1378            tmpcnt = (uint16_t)(tmpcntrl);
   \   00000A 5F                    CLRW      X
   \   00000B 97                    LD        XL, A
   \   00000C 9093                  LDW       Y, X
   1379            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
   \   00000E 5F                    CLRW      X
   \   00000F 41                    EXG       A, XL
   \   000010 B600                  LD        A, S:?b0
   \   000012 41                    EXG       A, XL
   \   000013 4F                    CLR       A
   \   000014 02                    RLWA      X, A
   \   000015 BF00                  LDW       S:?w0, X
   \   000017 51                    EXGW      X, Y
   \   000018 01                    RRWA      X, A
   \   000019 BA00                  OR        A, S:?b1
   \   00001B 01                    RRWA      X, A
   \   00001C BA00                  OR        A, S:?b0
   \   00001E 01                    RRWA      X, A
   \   00001F 51                    EXGW      X, Y
   1380            /* Get the Counter Register value */
   1381            return ((uint16_t)tmpcnt);
   \   000020 93                    LDW       X, Y
   \   000021 81                    RET
   1382          }
   1383          
   1384          /**
   1385            * @brief  Gets the TIM5 Prescaler value.
   1386            * @param  None
   1387            * @retval TIM5_Prescaler_TypeDef : Prescaler Register value.
   1388            */

   \                                 In section .near_func.text, align 1
   1389          TIM5_Prescaler_TypeDef TIM5_GetPrescaler(void)
   1390          {
   1391            /* Get the Prescaler Register value */
   1392            return ((TIM5_Prescaler_TypeDef)TIM5->PSCR);
   \                     TIM5_GetPrescaler:
   \   000000 C6530E                LD        A, L:0x530e
   \   000003 81                    RET
   1393          }
   1394          
   1395          /**
   1396            * @brief  Selects the TIM5 peripheral Capture Compare DMA source.
   1397            * @param   NewState: new state of the Capture Compare DMA source.
   1398            *   This parameter can be: ENABLE or DISABLE.
   1399            * @retval None
   1400            */

   \                                 In section .near_func.text, align 1
   1401          void TIM5_SelectCCDMA(FunctionalState NewState)
   1402          {
   1403            /* Check the parameters */
   1404            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1405          
   1406            if (NewState != DISABLE)
   \                     TIM5_SelectCCDMA:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??TIM5_SelectCCDMA_0
   1407            {
   1408              /* Set the CCDS Bit */
   1409              TIM5->CR2 |= TIM_CR2_CCDS;
   \   000003 72165301              BSET      L:0x5301, #0x3
   \   000007 81                    RET
   1410            }
   1411            else
   1412            {
   1413              /* Reset the CCDS Bit */
   1414              TIM5->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   \                     ??TIM5_SelectCCDMA_0:
   \   000008 72175301              BRES      L:0x5301, #0x3
   1415            }
   1416          }
   \   00000C 81                    RET
   1417          
   1418          /**
   1419            * @brief  Checks whether the specified TIM5 flag is set or not.
   1420            * @param  TIM5_FLAG : Specifies the flag to check.
   1421            *   This parameter can be one of the @ref TIM5_FLAG_TypeDef enumeration.
   1422            * @retval FlagStatus : The new state of TIM5_FLAG.
   1423            *   This parameter can be any of the @ref FlagStatus enumeration.
   1424            */

   \                                 In section .near_func.text, align 1
   1425          FlagStatus TIM5_GetFlagStatus(TIM5_FLAG_TypeDef TIM5_FLAG)
   1426          {
   1427            FlagStatus bitstatus = RESET;
   \                     TIM5_GetFlagStatus:
   \   000000 3F00                  CLR       S:?b0
   1428            uint8_t tim5_flag_l = 0, tim5_flag_h = 0;
   \   000002 3F00                  CLR       S:?b2
   \   000004 3F00                  CLR       S:?b1
   1429          
   1430            /* Check the parameters */
   1431            assert_param(IS_TIM5_GET_FLAG(TIM5_FLAG));
   1432          
   1433            tim5_flag_l = (uint8_t)(TIM5->SR1 & (uint8_t)(TIM5_FLAG));
   \   000006 9F                    LD        A, XL
   \   000007 C45306                AND       A, L:0x5306
   \   00000A B700                  LD        S:?b2, A
   1434            tim5_flag_h = (uint8_t)(TIM5->SR2 & (uint8_t)((uint16_t)TIM5_FLAG >> 8));
   \   00000C 4F                    CLR       A
   \   00000D 01                    RRWA      X, A
   \   00000E 9F                    LD        A, XL
   \   00000F C45307                AND       A, L:0x5307
   \   000012 B700                  LD        S:?b1, A
   1435          
   1436            if ((uint8_t)(tim5_flag_l | tim5_flag_h) != 0)
   \   000014 B600                  LD        A, S:?b1
   \   000016 BA00                  OR        A, S:?b2
   \   000018 A100                  CP        A, #0x0
   \   00001A 2706                  JREQ      L:??TIM5_GetFlagStatus_0
   1437            {
   1438              bitstatus = SET;
   \   00001C 35010000              MOV       S:?b0, #0x1
   \   000020 2002                  JRA       L:??TIM5_GetFlagStatus_1
   1439            }
   1440            else
   1441            {
   1442              bitstatus = RESET;
   \                     ??TIM5_GetFlagStatus_0:
   \   000022 3F00                  CLR       S:?b0
   1443            }
   1444            return ((FlagStatus)bitstatus);
   \                     ??TIM5_GetFlagStatus_1:
   \   000024 B600                  LD        A, S:?b0
   \   000026 81                    RET
   1445          }
   1446          
   1447          /**
   1448            * @brief  Clears the TIMs pending flags.
   1449            * @param  TIM5_FLAG : Specifies the flag to clear.
   1450            *   This parameter can be one of the @ref TIM5_FLAG_TypeDef enumeration.
   1451            * @retval None
   1452            */

   \                                 In section .near_func.text, align 1
   1453          void TIM5_ClearFlag(TIM5_FLAG_TypeDef TIM5_FLAG)
   1454          {
   1455            /* Check the parameters */
   1456            assert_param(IS_TIM5_CLEAR_FLAG((uint16_t)TIM5_FLAG));
   1457            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing 1 has no effect*/
   1458            TIM5->SR1 = (uint8_t)(~(uint8_t)(TIM5_FLAG));
   \                     TIM5_ClearFlag:
   \   000000 9F                    LD        A, XL
   \   000001 43                    CPL       A
   \   000002 C75306                LD        L:0x5306, A
   1459            TIM5->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM5_FLAG >> 8));
   \   000005 4F                    CLR       A
   \   000006 01                    RRWA      X, A
   \   000007 9F                    LD        A, XL
   \   000008 43                    CPL       A
   \   000009 C75307                LD        L:0x5307, A
   1460          }
   \   00000C 81                    RET
   1461          
   1462          /**
   1463            * @brief  Checks whether the TIM5 interrupt has occurred or not.
   1464            * @param  TIM5_IT : Specifies the TIM5 interrupt source to check.
   1465            *   This parameter can be one of the @ref TIM5_IT_TypeDef enumeration.
   1466            * @retval ITStatus : The new state of the TIM5_IT.
   1467            *   This parameter can be any of the @ref ITStatus enumeration.
   1468            */

   \                                 In section .near_func.text, align 1
   1469          ITStatus TIM5_GetITStatus(TIM5_IT_TypeDef TIM5_IT)
   1470          {
   \                     TIM5_GetITStatus:
   \   000000 B700                  LD        S:?b3, A
   1471            ITStatus bitstatus = RESET;
   \   000002 3F00                  CLR       S:?b0
   1472          
   1473            uint8_t TIM5_itStatus = 0x0, TIM5_itEnable = 0x0;
   \   000004 3F00                  CLR       S:?b2
   \   000006 3F00                  CLR       S:?b1
   1474          
   1475            /* Check the parameters */
   1476            assert_param(IS_TIM5_GET_IT(TIM5_IT));
   1477          
   1478            TIM5_itStatus = (uint8_t)(TIM5->SR1 & (uint8_t)TIM5_IT);
   \   000008 B600                  LD        A, S:?b3
   \   00000A C45306                AND       A, L:0x5306
   \   00000D B700                  LD        S:?b2, A
   1479          
   1480            TIM5_itEnable = (uint8_t)(TIM5->IER & (uint8_t)TIM5_IT);
   \   00000F B600                  LD        A, S:?b3
   \   000011 C45305                AND       A, L:0x5305
   \   000014 B700                  LD        S:?b1, A
   1481          
   1482            if ((TIM5_itStatus != (uint8_t)RESET ) && (TIM5_itEnable != (uint8_t)RESET))
   \   000016 3D00                  TNZ       S:?b2
   \   000018 270A                  JREQ      L:??TIM5_GetITStatus_0
   \   00001A 3D00                  TNZ       S:?b1
   \   00001C 2706                  JREQ      L:??TIM5_GetITStatus_0
   1483            {
   1484              bitstatus = (ITStatus)SET;
   \   00001E 35010000              MOV       S:?b0, #0x1
   \   000022 2002                  JRA       L:??TIM5_GetITStatus_1
   1485            }
   1486            else
   1487            {
   1488              bitstatus = (ITStatus)RESET;
   \                     ??TIM5_GetITStatus_0:
   \   000024 3F00                  CLR       S:?b0
   1489            }
   1490            return ((ITStatus)bitstatus);
   \                     ??TIM5_GetITStatus_1:
   \   000026 B600                  LD        A, S:?b0
   \   000028 81                    RET
   1491          }
   1492          
   1493          /**
   1494            * @brief  Clears the TIM's interrupt pending bits.
   1495            * @param  TIM5_IT : Specifies the pending bit to clear.
   1496            *   This parameter can be one of the @ref TIM5_IT_TypeDef enumeration.
   1497            * @retval None
   1498            */

   \                                 In section .near_func.text, align 1
   1499          void TIM5_ClearITPendingBit(TIM5_IT_TypeDef TIM5_IT)
   1500          {
   1501            /* Check the parameters */
   1502            assert_param(IS_TIM5_IT(TIM5_IT));
   1503          
   1504            /* Clear the IT pending Bit */
   1505            TIM5->SR1 = (uint8_t)(~(uint8_t)TIM5_IT);
   \                     TIM5_ClearITPendingBit:
   \   000000 43                    CPL       A
   \   000001 C75306                LD        L:0x5306, A
   1506          }
   \   000004 81                    RET
   1507          
   1508          /**
   1509            * @brief  Configure the TI1 as Input.
   1510            * @param  TIM5_ICPolarity : The Input Polarity.
   1511            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
   1512            * @param  TIM5_ICSelection : Specifies the input to be used.
   1513            *   This parameter can be one of the @ref TIM5_ICSelection_TypeDef enumeration.
   1514            * @param  TIM5_ICFilter : Specifies the Input Capture Filter.
   1515            *   This parameter must be a value between 0x00 and 0x0F.
   1516            * @retval None
   1517            */

   \                                 In section .near_func.text, align 1
   1518          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity, \
   1519                                 TIM5_ICSelection_TypeDef TIM5_ICSelection, \
   1520                                 uint8_t TIM5_ICFilter)
   1521          {
   \                     TI1_Config:
   \   000000 B700                  LD        S:?b2, A
   1522            uint8_t tmpccmr1 = 0;
   \   000002 3F00                  CLR       S:?b3
   1523            uint8_t tmpicpolarity = TIM5_ICPolarity;
   1524            tmpccmr1 = TIM5->CCMR1;
   \   000004 C65309                LD        A, L:0x5309
   \   000007 B700                  LD        S:?b3, A
   1525          
   1526            /* Check the parameters */
   1527            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   1528            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   1529            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   1530          
   1531            /* Disable the Channel 1: Reset the CCE Bit */
   1532            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   \   000009 7211530B              BRES      L:0x530b, #0x0
   1533          
   1534            /* Select the Input and set the filter */
   1535            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B600                  LD        A, S:?b3
   \   00000F A40C                  AND       A, #0xc
   \   000011 B700                  LD        S:?b3, A
   1536            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   \   000013 B600                  LD        A, S:?b1
   \   000015 4E                    SWAP      A
   \   000016 A4F0                  AND       A, #0xf0
   \   000018 BA00                  OR        A, S:?b0
   \   00001A BA00                  OR        A, S:?b3
   \   00001C B700                  LD        S:?b3, A
   1537          
   1538            TIM5->CCMR1 = tmpccmr1;
   \   00001E B600                  LD        A, S:?b3
   \   000020 C75309                LD        L:0x5309, A
   1539          
   1540            /* Select the Polarity */
   1541            if (tmpicpolarity == (uint8_t)(TIM5_ICPolarity_Falling))
   \   000023 B600                  LD        A, S:?b2
   \   000025 A101                  CP        A, #0x1
   \   000027 2606                  JRNE      L:??TI1_Config_0
   1542            {
   1543              TIM5->CCER1 |= TIM_CCER1_CC1P;
   \   000029 7212530B              BSET      L:0x530b, #0x1
   \   00002D 2004                  JRA       L:??TI1_Config_1
   1544            }
   1545            else
   1546            {
   1547              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   \                     ??TI1_Config_0:
   \   00002F 7213530B              BRES      L:0x530b, #0x1
   1548            }
   1549          
   1550            /* Set the CCE Bit */
   1551            TIM5->CCER1 |=  TIM_CCER1_CC1E;
   \                     ??TI1_Config_1:
   \   000033 7210530B              BSET      L:0x530b, #0x0
   1552          }
   \   000037 81                    RET
   1553          
   1554          /**
   1555            * @brief  Configure the TI2 as Input.
   1556            * @param  TIM5_ICPolarity : The Input Polarity.
   1557            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
   1558            * @param  TIM5_ICSelection : Specifies the input to be used.
   1559            *   This parameter can be one of the @ref TIM5_ICSelection_TypeDef enumeration.
   1560            * @param  TIM5_ICFilter : Specifies the Input Capture Filter.
   1561            *   This parameter must be a value between 0x00 and 0x0F.
   1562            * @retval None
   1563            */

   \                                 In section .near_func.text, align 1
   1564          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1565                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
   1566                                 uint8_t TIM5_ICFilter)
   1567          {
   \                     TI2_Config:
   \   000000 B700                  LD        S:?b2, A
   1568            uint8_t tmpccmr2 = 0;
   \   000002 3F00                  CLR       S:?b3
   1569            uint8_t tmpicpolarity = TIM5_ICPolarity;
   1570          
   1571            /* Check the parameters */
   1572            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   1573            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   1574            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   1575          
   1576            tmpccmr2 = TIM5->CCMR2;
   \   000004 C6530A                LD        A, L:0x530a
   \   000007 B700                  LD        S:?b3, A
   1577          
   1578            /* Disable the Channel 2: Reset the CCE Bit */
   1579            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   \   000009 7219530B              BRES      L:0x530b, #0x4
   1580          
   1581            /* Select the Input and set the filter */
   1582            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   \   00000D B600                  LD        A, S:?b3
   \   00000F A40C                  AND       A, #0xc
   \   000011 B700                  LD        S:?b3, A
   1583            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   \   000013 B600                  LD        A, S:?b1
   \   000015 4E                    SWAP      A
   \   000016 A4F0                  AND       A, #0xf0
   \   000018 BA00                  OR        A, S:?b0
   \   00001A BA00                  OR        A, S:?b3
   \   00001C B700                  LD        S:?b3, A
   1584          
   1585            TIM5->CCMR2 = tmpccmr2;
   \   00001E B600                  LD        A, S:?b3
   \   000020 C7530A                LD        L:0x530a, A
   1586          
   1587            /* Select the Polarity */
   1588            if (tmpicpolarity == TIM5_ICPolarity_Falling)
   \   000023 B600                  LD        A, S:?b2
   \   000025 A101                  CP        A, #0x1
   \   000027 2606                  JRNE      L:??TI2_Config_0
   1589            {
   1590              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   \   000029 721A530B              BSET      L:0x530b, #0x5
   \   00002D 2004                  JRA       L:??TI2_Config_1
   1591            }
   1592            else
   1593            {
   1594              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   \                     ??TI2_Config_0:
   \   00002F 721B530B              BRES      L:0x530b, #0x5
   1595            }
   1596          
   1597            /* Set the CCE Bit */
   1598            TIM5->CCER1 |=  TIM_CCER1_CC2E;
   \                     ??TI2_Config_1:
   \   000033 7218530B              BSET      L:0x530b, #0x4
   1599          }
   \   000037 81                    RET
   1600          /**
   1601            * @}
   1602            */
   1603          
   1604          /**
   1605            * @}
   1606            */
   1607          
   1608          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label              Bytes
     --------------              -----
     TIM5_DeInit                  101
     TIM5_TimeBaseInit             42
     TIM5_OC1Init                  93
     TIM5_OC2Init                  93
     TIM5_BKRConfig                22
     TIM5_ICInit                   35
     TIM5_PWMIConfig              120
     TIM5_Cmd                      13
     TIM5_CtrlPWMOutputs           13
     TIM5_ITConfig                 19
     TIM5_DMACmd                   19
     TIM5_InternalClockConfig       9
     TIM5_ETRClockMode1Config      36
     TIM5_ETRClockMode2Config       8
     TIM5_ETRConfig                15
     TIM5_TIxExternalClockConfig   45
     TIM5_SelectInputTrigger       27
     TIM5_UpdateDisableConfig      13
     TIM5_UpdateRequestConfig      14
     TIM5_SelectHallSensor         13
     TIM5_SelectOnePulseMode       14
     TIM5_SelectOutputTrigger      27
     TIM5_SelectSlaveMode          27
     TIM5_SelectMasterSlaveMode    13
     TIM5_EncoderInterfaceConfig  107
     TIM5_PrescalerConfig          19
     TIM5_CounterModeConfig        27
     TIM5_ForcedOC1Config          27
     TIM5_ForcedOC2Config          27
     TIM5_ARRPreloadConfig         13
     TIM5_OC1PreloadConfig         13
     TIM5_OC2PreloadConfig         13
     TIM5_OC1FastCmd               13
     TIM5_OC2FastCmd               13
     TIM5_GenerateEvent             7
     TIM5_OC1PolarityConfig        14
     TIM5_OC2PolarityConfig        14
     TIM5_CCxCmd                   31
     TIM5_SelectOCxM               45
     TIM5_SetCounter               15
     TIM5_SetAutoreload            15
     TIM5_SetCompare1              15
     TIM5_SetCompare2              15
     TIM5_SetIC1Prescaler          27
     TIM5_SetIC2Prescaler          27
     TIM5_GetCapture1              34
     TIM5_GetCapture2              34
     TIM5_GetCounter               34
     TIM5_GetPrescaler              4
     TIM5_SelectCCDMA              13
     TIM5_GetFlagStatus            39
     TIM5_ClearFlag                13
     TIM5_GetITStatus              41
     TIM5_ClearITPendingBit         5
     TI1_Config                    56
     TI2_Config                    56

 
 1 657 bytes in section .near_func.text
 
 1 657 bytes of CODE memory

Errors: none
Warnings: none
