###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             11/Mar/2014  17:31:35 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_a #
#                    dc.c                                                     #
#    Command line =  "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_a #
#                    dc.c" -e -Ol --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model small --data_model medium -o                #
#                    "F:\Skydrive\Final Design\Servo Motor STM8L\Debug\Obj\"  #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.0\stm8\LIB\dlstm8smn.h" -D STM8L15X_MD -lCN            #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Debug\List\" --diag_suppress Pe177,Pe550 -I        #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Project\Discover\inc\" -I "F:\Skydrive\Final       #
#                    Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Dr #
#                    iver\inc\" --vregs 16                                    #
#    List file    =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\List\stm8l15x_adc.lst                        #
#    Object file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\Obj\stm8l15x_adc.o                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\Skydrive\Final Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the ADC firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_adc.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          
     35          /**
     36              * @addtogroup ADC_Public_Functions
     37              * @{
     38              */
     39          
     40          /**
     41            * @brief  Deinitializes the ADC peripheral registers to their default reset values.
     42            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
     43            * @retval None
     44            */

   \                                 In section .near_func.text, align 1
     45          void ADC_DeInit(ADC_TypeDef* ADCx)
     46          {
     47            /*  Set the Configuration registers to their reset values */
     48            ADCx->CR1 =  ADC_CR1_RESET_VALUE;
   \                     ADC_DeInit:
   \   000000 4F                    CLR       A
   \   000001 F7                    LD        (X), A
     49            ADCx->CR2 =  ADC_CR2_RESET_VALUE;
   \   000002 9093                  LDW       Y, X
   \   000004 905C                  INCW      Y
   \   000006 4F                    CLR       A
   \   000007 90F7                  LD        (Y), A
     50            ADCx->CR3 =  ADC_CR3_RESET_VALUE;
   \   000009 9093                  LDW       Y, X
   \   00000B 72A90002              ADDW      Y, #0x2
   \   00000F A61F                  LD        A, #0x1f
   \   000011 90F7                  LD        (Y), A
     51          
     52            /*  Set the status registers to their reset values */
     53            ADCx->SR =  (uint8_t)~ADC_SR_RESET_VALUE;
   \   000013 9093                  LDW       Y, X
   \   000015 72A90003              ADDW      Y, #0x3
   \   000019 A6FF                  LD        A, #0xff
   \   00001B 90F7                  LD        (Y), A
     54          
     55            /*  Set the High threshold registers to their reset values */
     56            ADCx->HTRH =  ADC_HTRH_RESET_VALUE;
   \   00001D 9093                  LDW       Y, X
   \   00001F 72A90006              ADDW      Y, #0x6
   \   000023 A60F                  LD        A, #0xf
   \   000025 90F7                  LD        (Y), A
     57            ADCx->HTRL =  ADC_HTRL_RESET_VALUE;
   \   000027 9093                  LDW       Y, X
   \   000029 72A90007              ADDW      Y, #0x7
   \   00002D A6FF                  LD        A, #0xff
   \   00002F 90F7                  LD        (Y), A
     58          
     59            /*  Set the low threshold registers to their reset values */
     60            ADCx->LTRH =  ADC_LTRH_RESET_VALUE;
   \   000031 9093                  LDW       Y, X
   \   000033 72A90008              ADDW      Y, #0x8
   \   000037 4F                    CLR       A
   \   000038 90F7                  LD        (Y), A
     61            ADCx->LTRL =  ADC_LTRL_RESET_VALUE;
   \   00003A 9093                  LDW       Y, X
   \   00003C 72A90009              ADDW      Y, #0x9
   \   000040 4F                    CLR       A
   \   000041 90F7                  LD        (Y), A
     62          
     63            /*  Set the channels sequence registers to their reset values */
     64            ADCx->SQR[0] =  ADC_SQR1_RESET_VALUE;
   \   000043 9093                  LDW       Y, X
   \   000045 72A9000A              ADDW      Y, #0xa
   \   000049 4F                    CLR       A
   \   00004A 90F7                  LD        (Y), A
     65            ADCx->SQR[1] =  ADC_SQR2_RESET_VALUE;
   \   00004C 9093                  LDW       Y, X
   \   00004E 72A9000B              ADDW      Y, #0xb
   \   000052 4F                    CLR       A
   \   000053 90F7                  LD        (Y), A
     66            ADCx->SQR[2] =  ADC_SQR3_RESET_VALUE;
   \   000055 9093                  LDW       Y, X
   \   000057 72A9000C              ADDW      Y, #0xc
   \   00005B 4F                    CLR       A
   \   00005C 90F7                  LD        (Y), A
     67            ADCx->SQR[3] =  ADC_SQR4_RESET_VALUE;
   \   00005E 9093                  LDW       Y, X
   \   000060 72A9000D              ADDW      Y, #0xd
   \   000064 4F                    CLR       A
   \   000065 90F7                  LD        (Y), A
     68          
     69            /*  Set the channels Trigger registers to their reset values */
     70            ADCx->TRIGR[0] =  ADC_TRIGR1_RESET_VALUE;
   \   000067 9093                  LDW       Y, X
   \   000069 72A9000E              ADDW      Y, #0xe
   \   00006D 4F                    CLR       A
   \   00006E 90F7                  LD        (Y), A
     71            ADCx->TRIGR[1] =  ADC_TRIGR2_RESET_VALUE;
   \   000070 9093                  LDW       Y, X
   \   000072 72A9000F              ADDW      Y, #0xf
   \   000076 4F                    CLR       A
   \   000077 90F7                  LD        (Y), A
     72            ADCx->TRIGR[2] =  ADC_TRIGR3_RESET_VALUE;
   \   000079 9093                  LDW       Y, X
   \   00007B 72A90010              ADDW      Y, #0x10
   \   00007F 4F                    CLR       A
   \   000080 90F7                  LD        (Y), A
     73            ADCx->TRIGR[3] =  ADC_TRIGR4_RESET_VALUE;
   \   000082 1C0011                ADDW      X, #0x11
   \   000085 4F                    CLR       A
   \   000086 F7                    LD        (X), A
     74          }
   \   000087 81                    RET
     75          
     76          /**
     77            * @brief  Initializes the specified ADC peripheral according to the specified parameters.
     78            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
     79            * @param  ADC_ConversionMode : specifies the ADC conversion mode,
     80            *         This parameter can be one of the @ref ADC_ConversionMode_TypeDef
     81            * @param  ADC_Resolution : specifies the ADC Data resolusion,
     82            *         This parameter can be one of the @ref ADC_Resolution_TypeDef
     83            * @param  ADC_Prescaler : specifies the ADC Prescaler,
     84            *         This parameter can be one of the @ref ADC_Prescaler_TypeDef
     85            * @retval None
     86            */

   \                                 In section .near_func.text, align 1
     87          void ADC_Init(ADC_TypeDef* ADCx,
     88                        ADC_ConversionMode_TypeDef ADC_ConversionMode,
     89                        ADC_Resolution_TypeDef ADC_Resolution,
     90                        ADC_Prescaler_TypeDef ADC_Prescaler)
     91          {
   \                     ADC_Init:
   \   000000 B700                  LD        S:?b2, A
     92            /* Check the parameters */
     93            assert_param(IS_ADC_CONVERSION_MODE(ADC_ConversionMode));
     94            assert_param(IS_ADC_RESOLUTION(ADC_Resolution));
     95            assert_param(IS_ADC_PRESCALER(ADC_Prescaler));
     96          
     97            /*clear CR1 register */
     98            ADCx->CR1 &= (uint8_t)~(ADC_CR1_CONT | ADC_CR1_RES);
   \   000002 F6                    LD        A, (X)
   \   000003 A49B                  AND       A, #0x9b
   \   000005 F7                    LD        (X), A
     99          
    100            /* set the resolution and the conversion mode */
    101            ADCx->CR1 |= (uint8_t)((uint8_t)ADC_ConversionMode | (uint8_t)ADC_Resolution);
   \   000006 B600                  LD        A, S:?b0
   \   000008 BA00                  OR        A, S:?b2
   \   00000A FA                    OR        A, (X)
   \   00000B F7                    LD        (X), A
    102          
    103            /*clear CR2 register */
    104            ADCx->CR2 &= (uint8_t)~(ADC_CR2_PRESC );
   \   00000C 9093                  LDW       Y, X
   \   00000E 905C                  INCW      Y
   \   000010 90F6                  LD        A, (Y)
   \   000012 A47F                  AND       A, #0x7f
   \   000014 9093                  LDW       Y, X
   \   000016 905C                  INCW      Y
   \   000018 90F7                  LD        (Y), A
    105          
    106            /* set the Prescaler */
    107            ADCx->CR2 |= (uint8_t) ADC_Prescaler;
   \   00001A 9093                  LDW       Y, X
   \   00001C 905C                  INCW      Y
   \   00001E B600                  LD        A, S:?b1
   \   000020 90FA                  OR        A, (Y)
   \   000022 5C                    INCW      X
   \   000023 F7                    LD        (X), A
    108          }
   \   000024 81                    RET
    109          
    110          
    111          /**
    112            * @brief  Enables or disables the selected ADC channel(s).
    113            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    114            * @param  ADC_Channels: specifies the ADC channels to be initialized,
    115            *         This parameter can be a value of @ref ADC_Channel_TypeDef, or a combination
    116            *         of values as follows:
    117            *           - 1st combination : channels from ADC_Channel_0 to ADC_Channel_7
    118            *           - 2nd combination : channels from ADC_Channel_8 to ADC_Channel_15
    119            *           - 3rd combination : channels from ADC_Channel_16 to ADC_Channel_23
    120            * @param  NewState : new state of the specified ADC channel(s).
    121            *         This parameter can be: ENABLE or DISABLE.
    122            * @retval None
    123            */

   \                                 In section .near_func.text, align 1
    124          void ADC_ChannelCmd(ADC_TypeDef* ADCx,
    125                              ADC_Channel_TypeDef ADC_Channels,
    126                              FunctionalState NewState)
    127          {
   \                     ADC_ChannelCmd:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 B700                  LD        S:?b0, A
    128            uint8_t regindex = 0;
   \   000004 3F00                  CLR       S:?b1
    129            /* Check the parameters */
    130            assert_param(IS_FUNCTIONAL_STATE(NewState));
    131          
    132            regindex = (uint8_t)((uint16_t)ADC_Channels >> 8);
   \   000006 93                    LDW       X, Y
   \   000007 4F                    CLR       A
   \   000008 01                    RRWA      X, A
   \   000009 9F                    LD        A, XL
   \   00000A B700                  LD        S:?b1, A
    133          
    134            if (NewState != DISABLE)
   \   00000C 3D00                  TNZ       S:?b0
   \   00000E 271D                  JREQ      L:??ADC_ChannelCmd_0
    135            {
    136              /* Enable the selected ADC channel(s). */
    137              ADCx->SQR[regindex] |= (uint8_t)(ADC_Channels);
   \   000010 5F                    CLRW      X
   \   000011 41                    EXG       A, XL
   \   000012 B600                  LD        A, S:?b1
   \   000014 41                    EXG       A, XL
   \   000015 72BB0000              ADDW      X, S:?w1
   \   000019 1C000A                ADDW      X, #0xa
   \   00001C 909F                  LD        A, YL
   \   00001E FA                    OR        A, (X)
   \   00001F 5F                    CLRW      X
   \   000020 41                    EXG       A, XL
   \   000021 B600                  LD        A, S:?b1
   \   000023 41                    EXG       A, XL
   \   000024 72BB0000              ADDW      X, S:?w1
   \   000028 1C000A                ADDW      X, #0xa
   \   00002B F7                    LD        (X), A
   \   00002C 81                    RET
    138            }
    139            else
    140            {
    141              /* Disable the selected ADC channel(s). */
    142              ADCx->SQR[regindex] &= (uint8_t)(~(uint8_t)(ADC_Channels));
   \                     ??ADC_ChannelCmd_0:
   \   00002D 5F                    CLRW      X
   \   00002E 41                    EXG       A, XL
   \   00002F B600                  LD        A, S:?b1
   \   000031 41                    EXG       A, XL
   \   000032 72BB0000              ADDW      X, S:?w1
   \   000036 1C000A                ADDW      X, #0xa
   \   000039 909F                  LD        A, YL
   \   00003B 43                    CPL       A
   \   00003C F4                    AND       A, (X)
   \   00003D 5F                    CLRW      X
   \   00003E 41                    EXG       A, XL
   \   00003F B600                  LD        A, S:?b1
   \   000041 41                    EXG       A, XL
   \   000042 72BB0000              ADDW      X, S:?w1
   \   000046 1C000A                ADDW      X, #0xa
   \   000049 F7                    LD        (X), A
    143            }
    144          }
   \   00004A 81                    RET
    145          
    146          /**
    147            * @brief  Enables or disables the selected ADC peripheral.
    148            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    149            * @param  NewState : new state of the specified ADC peripheral.
    150            *         This parameter can be: ENABLE or DISABLE.
    151            * @retval None
    152            */

   \                                 In section .near_func.text, align 1
    153          void ADC_Cmd(ADC_TypeDef* ADCx,
    154                       FunctionalState NewState)
    155          {
    156            /* Check the parameters */
    157            assert_param(IS_FUNCTIONAL_STATE(NewState));
    158          
    159            if (NewState != DISABLE)
   \                     ADC_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??ADC_Cmd_0
    160            {
    161              /* Set the ADON bit to wake up the specified ADC from power down mode */
    162              ADCx->CR1 |= ADC_CR1_ADON;
   \   000003 F6                    LD        A, (X)
   \   000004 AA01                  OR        A, #0x1
   \   000006 F7                    LD        (X), A
   \   000007 81                    RET
    163            }
    164            else
    165            {
    166              /* Disable the selected ADC peripheral */
    167              ADCx->CR1 &= (uint8_t)~ADC_CR1_ADON;
   \                     ??ADC_Cmd_0:
   \   000008 F6                    LD        A, (X)
   \   000009 A4FE                  AND       A, #0xfe
   \   00000B F7                    LD        (X), A
    168            }
    169          }
   \   00000C 81                    RET
    170          
    171          /**
    172            * @brief  Enables or disables the specified ADC interrupts.
    173            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    174            * @param  ADC_IT : specifies the ADC interrupt sources to be enabled or disabled.
    175            *         This parameter can be any combination of the @ref ADC_IT_TypeDef
    176            * @param  NewState : new state of the specified ADC interrupts.
    177            *         This parameter can be: ENABLE or DISABLE.
    178            * @retval None
    179            */

   \                                 In section .near_func.text, align 1
    180          void ADC_ITConfig(ADC_TypeDef* ADCx,
    181                            ADC_IT_TypeDef ADC_IT,
    182                            FunctionalState NewState)
    183          {
    184            /* Check the parameters */
    185            assert_param(IS_FUNCTIONAL_STATE(NewState));
    186            assert_param(IS_ADC_IT(ADC_IT));
    187          
    188            if (NewState != DISABLE)
   \                     ADC_ITConfig:
   \   000000 3D00                  TNZ       S:?b0
   \   000002 2703                  JREQ      L:??ADC_ITConfig_0
    189            {
    190              /* Enable the selected ADC interrupts */
    191              ADCx->CR1 |= (uint8_t) ADC_IT;
   \   000004 FA                    OR        A, (X)
   \   000005 F7                    LD        (X), A
   \   000006 81                    RET
    192            }
    193            else
    194            {
    195              /* Disable the selected ADC interrupts */
    196              ADCx->CR1 &= (uint8_t)(~ADC_IT);
   \                     ??ADC_ITConfig_0:
   \   000007 43                    CPL       A
   \   000008 F4                    AND       A, (X)
   \   000009 F7                    LD        (X), A
    197            }
    198          }
   \   00000A 81                    RET
    199          
    200          /**
    201            * @brief  Enables or disables the specified ADC DMA request.
    202            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    203            * @param  NewState : new state of the specified ADC DMA transfer.
    204            *         This parameter can be: ENABLE or DISABLE.
    205            * @retval None
    206            */

   \                                 In section .near_func.text, align 1
    207          void ADC_DMACmd(ADC_TypeDef* ADCx,
    208                          FunctionalState NewState)
    209          {
    210            /* Check the parameters */
    211            assert_param(IS_FUNCTIONAL_STATE(NewState));
    212          
    213            if (NewState != DISABLE)
   \                     ADC_DMACmd:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??ADC_DMACmd_0
    214            {
    215              /* Enable the specified ADC DMA request */
    216              ADCx->SQR[0] &= (uint8_t)~ADC_SQR1_DMAOFF;
   \   000003 9093                  LDW       Y, X
   \   000005 72A9000A              ADDW      Y, #0xa
   \   000009 90F6                  LD        A, (Y)
   \   00000B A47F                  AND       A, #0x7f
   \   00000D 1C000A                ADDW      X, #0xa
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    217            }
    218            else
    219            {
    220              /* Disable the specified ADC DMA request */
    221              ADCx->SQR[0] |= ADC_SQR1_DMAOFF;
   \                     ??ADC_DMACmd_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A9000A              ADDW      Y, #0xa
   \   000018 90F6                  LD        A, (Y)
   \   00001A AA80                  OR        A, #0x80
   \   00001C 1C000A                ADDW      X, #0xa
   \   00001F F7                    LD        (X), A
    222            }
    223          }
   \   000020 81                    RET
    224          
    225          /**
    226            * @brief  Enables or disables the Temperature sensor internal reference.
    227            * @param  NewState : new state of the Temperature sensor internal reference.
    228            *         This parameter can be: ENABLE or DISABLE.
    229            * @retval None
    230            */

   \                                 In section .near_func.text, align 1
    231          void ADC_TempSensorCmd(FunctionalState NewState)
    232          {
    233            /* Check the parameters */
    234            assert_param(IS_FUNCTIONAL_STATE(NewState));
    235          
    236            if (NewState != DISABLE)
   \                     ADC_TempSensorCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??ADC_TempSensorCmd_0
    237            {
    238              /*Enable the Temperature sensor internal reference.*/
    239              ADC1->TRIGR[0] |= (uint8_t)(ADC_TRIGR1_TSON);
   \   000003 721A534E              BSET      L:0x534e, #0x5
   \   000007 81                    RET
    240            }
    241            else
    242            {
    243              /*Disable the Temperature sensor internal reference.*/
    244              ADC1->TRIGR[0] &= (uint8_t)(~ADC_TRIGR1_TSON);
   \                     ??ADC_TempSensorCmd_0:
   \   000008 721B534E              BRES      L:0x534e, #0x5
    245            }
    246          }
   \   00000C 81                    RET
    247          
    248          /**
    249            * @brief  Enables or disables the Internal Voltage reference.
    250            * @param  NewState : new state of the Internal Voltage reference.
    251            *         This parameter can be: ENABLE or DISABLE.
    252            * @retval None
    253            */

   \                                 In section .near_func.text, align 1
    254          void ADC_VrefintCmd(FunctionalState NewState)
    255          {
    256            /* Check the parameters */
    257            assert_param(IS_FUNCTIONAL_STATE(NewState));
    258          
    259            if (NewState != DISABLE)
   \                     ADC_VrefintCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??ADC_VrefintCmd_0
    260            {
    261              /* Enable the Internal Voltage reference.*/
    262              ADC1->TRIGR[0] |= (uint8_t)(ADC_TRIGR1_VREFINTON);
   \   000003 7218534E              BSET      L:0x534e, #0x4
   \   000007 81                    RET
    263            }
    264            else
    265            {
    266              /* Disable the Internal Voltage reference.*/
    267              ADC1->TRIGR[0] &= (uint8_t)(~ADC_TRIGR1_VREFINTON);
   \                     ??ADC_VrefintCmd_0:
   \   000008 7219534E              BRES      L:0x534e, #0x4
    268            }
    269          }
   \   00000C 81                    RET
    270          
    271          /**
    272            * @brief  Starts ADC conversion, by software trigger.
    273            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    274            * @retval None
    275            */

   \                                 In section .near_func.text, align 1
    276          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    277          {
    278            /*  Start the ADC software conversion */
    279            ADCx->CR1 |= ADC_CR1_START;
   \                     ADC_SoftwareStartConv:
   \   000000 F6                    LD        A, (X)
   \   000001 AA02                  OR        A, #0x2
   \   000003 F7                    LD        (X), A
    280          }
   \   000004 81                    RET
    281          
    282          /**
    283            * @brief  Configures the sampling time for the selected ADC channel group.
    284            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    285            * @param  ADC_GroupChannels : ADC channel group to configure.
    286            *         This parameter can be a value of @ref ADC_Group_TypeDef
    287            * @param  ADC_SamplingTime : Specifies the sample time value
    288            *         This parameter can be a value of @ref ADC_SamplingTime_TypeDef
    289            * @retval None
    290            */

   \                                 In section .near_func.text, align 1
    291          void ADC_SamplingTimeConfig(ADC_TypeDef* ADCx,
    292                                      ADC_Group_TypeDef ADC_GroupChannels,
    293                                      ADC_SamplingTime_TypeDef ADC_SamplingTime)
    294          {
    295            /* Check the parameters */
    296            assert_param(IS_ADC_GROUP(ADC_GroupChannels));
    297            assert_param(IS_ADC_SAMPLING_TIME_CYCLES(ADC_SamplingTime));
    298          
    299            if ( ADC_GroupChannels != ADC_Group_SlowChannels)
   \                     ADC_SamplingTimeConfig:
   \   000000 4D                    TNZ       A
   \   000001 2724                  JREQ      L:??ADC_SamplingTimeConfig_0
    300            {
    301              /* Configures the sampling time for the Fast ADC channel group. */
    302              ADCx->CR3 &= (uint8_t)~ADC_CR3_SMPT2;
   \   000003 9093                  LDW       Y, X
   \   000005 72A90002              ADDW      Y, #0x2
   \   000009 90F6                  LD        A, (Y)
   \   00000B A41F                  AND       A, #0x1f
   \   00000D 9093                  LDW       Y, X
   \   00000F 72A90002              ADDW      Y, #0x2
   \   000013 90F7                  LD        (Y), A
    303              ADCx->CR3 |= (uint8_t)(ADC_SamplingTime << 5);
   \   000015 9093                  LDW       Y, X
   \   000017 72A90002              ADDW      Y, #0x2
   \   00001B B600                  LD        A, S:?b0
   \   00001D CD0000                CALL      L:?sll8_a_a_5
   \   000020 90FA                  OR        A, (Y)
   \   000022 1C0002                ADDW      X, #0x2
   \   000025 F7                    LD        (X), A
   \   000026 81                    RET
    304            }
    305            else
    306            {
    307              /* Configures the sampling time for the Slow ADC channel group. */
    308              ADCx->CR2 &= (uint8_t)~ADC_CR2_SMPT1;
   \                     ??ADC_SamplingTimeConfig_0:
   \   000027 9093                  LDW       Y, X
   \   000029 905C                  INCW      Y
   \   00002B 90F6                  LD        A, (Y)
   \   00002D A4F8                  AND       A, #0xf8
   \   00002F 9093                  LDW       Y, X
   \   000031 905C                  INCW      Y
   \   000033 90F7                  LD        (Y), A
    309              ADCx->CR2 |= (uint8_t)ADC_SamplingTime;
   \   000035 9093                  LDW       Y, X
   \   000037 905C                  INCW      Y
   \   000039 B600                  LD        A, S:?b0
   \   00003B 90FA                  OR        A, (Y)
   \   00003D 5C                    INCW      X
   \   00003E F7                    LD        (X), A
    310            }
    311          }
   \   00003F 81                    RET
    312          
    313          /**
    314            * @brief  Configures the status of the Schmitt Trigger for the selected ADC channel(s).
    315            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    316            * @param  ADC_Channels: specifies the ADC channels to be initialized,
    317            *         This parameter can be a value of @ref ADC_Channel_TypeDef enumeration.
    318            * @param  NewState : new state of the Schmitt Trigger
    319            *         This parameter can be: ENABLE or DISABLE.
    320            * @retval None
    321            */

   \                                 In section .near_func.text, align 1
    322          void ADC_SchmittTriggerConfig(ADC_TypeDef* ADCx,
    323                                        ADC_Channel_TypeDef ADC_Channels,
    324                                        FunctionalState NewState)
    325          {
   \                     ADC_SchmittTriggerConfig:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 B700                  LD        S:?b0, A
    326            uint8_t regindex = 0;
   \   000004 3F00                  CLR       S:?b1
    327            /* Check the parameters */
    328            assert_param(IS_FUNCTIONAL_STATE(NewState));
    329          
    330            regindex = (uint8_t)((uint16_t)ADC_Channels >> 8);
   \   000006 93                    LDW       X, Y
   \   000007 4F                    CLR       A
   \   000008 01                    RRWA      X, A
   \   000009 9F                    LD        A, XL
   \   00000A B700                  LD        S:?b1, A
    331          
    332            if (NewState != DISABLE)
   \   00000C 3D00                  TNZ       S:?b0
   \   00000E 271E                  JREQ      L:??ADC_SchmittTriggerConfig_0
    333            {
    334              /* Enable the Schmitt Trigger for the selected ADC channel(s).*/
    335              ADCx->TRIGR[regindex] &= (uint8_t)(~(uint8_t)ADC_Channels);
   \   000010 5F                    CLRW      X
   \   000011 41                    EXG       A, XL
   \   000012 B600                  LD        A, S:?b1
   \   000014 41                    EXG       A, XL
   \   000015 72BB0000              ADDW      X, S:?w1
   \   000019 1C000E                ADDW      X, #0xe
   \   00001C 909F                  LD        A, YL
   \   00001E 43                    CPL       A
   \   00001F F4                    AND       A, (X)
   \   000020 5F                    CLRW      X
   \   000021 41                    EXG       A, XL
   \   000022 B600                  LD        A, S:?b1
   \   000024 41                    EXG       A, XL
   \   000025 72BB0000              ADDW      X, S:?w1
   \   000029 1C000E                ADDW      X, #0xe
   \   00002C F7                    LD        (X), A
   \   00002D 81                    RET
    336            }
    337            else
    338            {
    339              /* Disable the Schmitt Trigger for the selected ADC channel(s).*/
    340              ADCx->TRIGR[regindex] |= (uint8_t)(ADC_Channels);
   \                     ??ADC_SchmittTriggerConfig_0:
   \   00002E 5F                    CLRW      X
   \   00002F 41                    EXG       A, XL
   \   000030 B600                  LD        A, S:?b1
   \   000032 41                    EXG       A, XL
   \   000033 72BB0000              ADDW      X, S:?w1
   \   000037 1C000E                ADDW      X, #0xe
   \   00003A 909F                  LD        A, YL
   \   00003C FA                    OR        A, (X)
   \   00003D 5F                    CLRW      X
   \   00003E 41                    EXG       A, XL
   \   00003F B600                  LD        A, S:?b1
   \   000041 41                    EXG       A, XL
   \   000042 72BB0000              ADDW      X, S:?w1
   \   000046 1C000E                ADDW      X, #0xe
   \   000049 F7                    LD        (X), A
    341            }
    342          }
   \   00004A 81                    RET
    343          
    344          /**
    345            * @brief  Configures the ADC conversion through external trigger.
    346            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    347            * @param  ADC_ExtEventSelection : Specifies the external trigger.
    348            *         This parameter can be a value of @ref ADC_ExtEventSelection_TypeDef
    349            * @param  ADC_ExtTRGSensitivity : Specifies the external trigger sensitivity.
    350            *         This parameter can be a value of @ref ADC_ExtTRGSensitivity_TypeDef
    351            * @retval None
    352            */

   \                                 In section .near_func.text, align 1
    353          void ADC_ExternalTrigConfig(ADC_TypeDef* ADCx,
    354                                      ADC_ExtEventSelection_TypeDef ADC_ExtEventSelection,
    355                                      ADC_ExtTRGSensitivity_TypeDef ADC_ExtTRGSensitivity)
    356          {
   \                     ADC_ExternalTrigConfig:
   \   000000 B700                  LD        S:?b1, A
    357            /* Check the parameters */
    358            assert_param(IS_ADC_EXT_EVENT_SELECTION(ADC_ExtEventSelection));
    359            assert_param(IS_ADC_EXT_TRG_SENSITIVITY(ADC_ExtTRGSensitivity));
    360          
    361            /*clear old config in CR2 register */
    362            ADCx->CR2 &= (uint8_t)~(ADC_CR2_TRIGEDGE | ADC_CR2_EXTSEL);
   \   000002 9093                  LDW       Y, X
   \   000004 905C                  INCW      Y
   \   000006 90F6                  LD        A, (Y)
   \   000008 A487                  AND       A, #0x87
   \   00000A 9093                  LDW       Y, X
   \   00000C 905C                  INCW      Y
   \   00000E 90F7                  LD        (Y), A
    363          
    364            /* set the External Trigger Edge Sensitivity  and the external event selection*/
    365            ADCx->CR2 |= (uint8_t)( (uint8_t)ADC_ExtTRGSensitivity | (uint8_t)ADC_ExtEventSelection);
   \   000010 B600                  LD        A, S:?b1
   \   000012 BA00                  OR        A, S:?b0
   \   000014 9093                  LDW       Y, X
   \   000016 905C                  INCW      Y
   \   000018 90FA                  OR        A, (Y)
   \   00001A 5C                    INCW      X
   \   00001B F7                    LD        (X), A
    366          }
   \   00001C 81                    RET
    367          
    368          
    369          /**
    370            * @brief  Returns the last ADC converted data.
    371            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    372            * @retval The Data conversion value.
    373            */

   \                                 In section .near_func.text, align 1
    374          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    375          {
   \                     ADC_GetConversionValue:
   \   000000 BF00                  LDW       S:?w0, X
    376            uint16_t tmpreg = 0;
   \   000002 5F                    CLRW      X
    377          
    378            /* Get last ADC converted data.*/
    379            tmpreg = (uint16_t)(ADCx->DRH);
   \   000003 90BE00                LDW       Y, S:?w0
   \   000006 72A90004              ADDW      Y, #0x4
   \   00000A 90F6                  LD        A, (Y)
   \   00000C 905F                  CLRW      Y
   \   00000E 9097                  LD        YL, A
   \   000010 93                    LDW       X, Y
    380            tmpreg = (uint16_t)((uint16_t)((uint16_t)tmpreg << 8) | ADCx->DRL);
   \   000011 90BE00                LDW       Y, S:?w0
   \   000014 72A90005              ADDW      Y, #0x5
   \   000018 90F6                  LD        A, (Y)
   \   00001A 905F                  CLRW      Y
   \   00001C 9097                  LD        YL, A
   \   00001E 4F                    CLR       A
   \   00001F 02                    RLWA      X, A
   \   000020 90BF00                LDW       S:?w0, Y
   \   000023 01                    RRWA      X, A
   \   000024 BA00                  OR        A, S:?b1
   \   000026 01                    RRWA      X, A
   \   000027 BA00                  OR        A, S:?b0
   \   000029 01                    RRWA      X, A
    381          
    382            /* Return the selected ADC conversion value */
    383            return (uint16_t)(tmpreg) ;
   \   00002A 81                    RET
    384          }
    385          
    386          
    387          /**
    388            * @brief  Configures the channel to be checked by the Analog watchdog.
    389            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    390            * @param  ADC_AnalogWatchdogSelection : Specifies the channel to be checked by
    391            *         by the Analog watchdog.
    392            *         This parameter can be a value of @ref ADC_AnalogWatchdogSelection_TypeDef
    393            * @retval None
    394            */

   \                                 In section .near_func.text, align 1
    395          void ADC_AnalogWatchdogChannelSelect(ADC_TypeDef* ADCx,
    396                                               ADC_AnalogWatchdogSelection_TypeDef ADC_AnalogWatchdogSelection)
    397          {
   \                     ADC_AnalogWatchdogChannelSelect:
   \   000000 B700                  LD        S:?b0, A
    398            /* Check the parameters */
    399            assert_param(IS_ADC_ANALOGWATCHDOG_SELECTION(ADC_AnalogWatchdogSelection));
    400          
    401            /*reset the CHSEL bits */
    402            ADCx->CR3 &= ((uint8_t)~ADC_CR3_CHSEL);
   \   000002 9093                  LDW       Y, X
   \   000004 72A90002              ADDW      Y, #0x2
   \   000008 90F6                  LD        A, (Y)
   \   00000A A4E0                  AND       A, #0xe0
   \   00000C 9093                  LDW       Y, X
   \   00000E 72A90002              ADDW      Y, #0x2
   \   000012 90F7                  LD        (Y), A
    403          
    404            /* Select the channel to be checked by the Analog watchdog.*/
    405            ADCx->CR3 |= (uint8_t)ADC_AnalogWatchdogSelection;
   \   000014 9093                  LDW       Y, X
   \   000016 72A90002              ADDW      Y, #0x2
   \   00001A B600                  LD        A, S:?b0
   \   00001C 90FA                  OR        A, (Y)
   \   00001E 1C0002                ADDW      X, #0x2
   \   000021 F7                    LD        (X), A
    406          }
   \   000022 81                    RET
    407          
    408          /**
    409            * @brief  Configures the high and low thresholds of the Analog watchdog.
    410            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    411            * @param  HighThreshold: Analog watchdog High threshold value.
    412              *       This parameter must be a 12bit value.
    413            * @param  LowThreshold: Analog watchdog Low threshold value.
    414              *       This parameter must be a 12bit value.
    415            * @retval None
    416            */

   \                                 In section .near_func.text, align 1
    417          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx,
    418                                                  uint16_t HighThreshold,
    419                                                  uint16_t LowThreshold)
    420          {
   \                     ADC_AnalogWatchdogThresholdsConfig:
   \   000000 BF00                  LDW       S:?w1, X
    421            /* Check the parameters */
    422            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    423            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    424          
    425            /* Set the ADC high threshold */
    426            ADCx->HTRH = (uint8_t)(HighThreshold >> 8);
   \   000002 93                    LDW       X, Y
   \   000003 4F                    CLR       A
   \   000004 01                    RRWA      X, A
   \   000005 9F                    LD        A, XL
   \   000006 BE00                  LDW       X, S:?w1
   \   000008 1C0006                ADDW      X, #0x6
   \   00000B F7                    LD        (X), A
    427            ADCx->HTRL = (uint8_t)(HighThreshold);
   \   00000C BE00                  LDW       X, S:?w1
   \   00000E 1C0007                ADDW      X, #0x7
   \   000011 909F                  LD        A, YL
   \   000013 F7                    LD        (X), A
    428          
    429            /* Set the ADC low threshold */
    430            ADCx->LTRH = (uint8_t)(LowThreshold >> 8);
   \   000014 BE00                  LDW       X, S:?w0
   \   000016 4F                    CLR       A
   \   000017 01                    RRWA      X, A
   \   000018 9F                    LD        A, XL
   \   000019 BE00                  LDW       X, S:?w1
   \   00001B 1C0008                ADDW      X, #0x8
   \   00001E F7                    LD        (X), A
    431            ADCx->LTRL = (uint8_t)(LowThreshold);
   \   00001F BE00                  LDW       X, S:?w1
   \   000021 1C0009                ADDW      X, #0x9
   \   000024 B600                  LD        A, S:?b1
   \   000026 F7                    LD        (X), A
    432          }
   \   000027 81                    RET
    433          
    434          /**
    435            * @brief  Configures the Analog watchdog.
    436            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    437            * @param  ADC_AnalogWatchdogSelection : Specifies the channel to be checked by
    438            *         by the Analog watchdog.
    439            *         This parameter can be a value of @ref ADC_AnalogWatchdogSelection_TypeDef
    440            * @param  HighThreshold: Analog watchdog High threshold value.
    441              *       This parameter must be a 12bit value.
    442            * @param  LowThreshold: Analog watchdog Low threshold value.
    443              *       This parameter must be a 12bit value.
    444            * @retval None
    445            */

   \                                 In section .near_func.text, align 1
    446          void ADC_AnalogWatchdogConfig(ADC_TypeDef* ADCx,
    447                                        ADC_AnalogWatchdogSelection_TypeDef ADC_AnalogWatchdogSelection,
    448                                        uint16_t HighThreshold,
    449                                        uint16_t LowThreshold)
    450          {
   \                     ADC_AnalogWatchdogConfig:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 B700                  LD        S:?b4, A
    451            /* Check the parameters */
    452            assert_param(IS_ADC_ANALOGWATCHDOG_SELECTION(ADC_AnalogWatchdogSelection));
    453            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    454            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    455          
    456            /*Reset the CHSEL bits */
    457            ADCx->CR3 &= ((uint8_t)~ADC_CR3_CHSEL);
   \   000004 BE00                  LDW       X, S:?w1
   \   000006 1C0002                ADDW      X, #0x2
   \   000009 F6                    LD        A, (X)
   \   00000A A4E0                  AND       A, #0xe0
   \   00000C BE00                  LDW       X, S:?w1
   \   00000E 1C0002                ADDW      X, #0x2
   \   000011 F7                    LD        (X), A
    458          
    459            /* Select the channel to be checked by the Analog watchdog.*/
    460            ADCx->CR3 |= (uint8_t)ADC_AnalogWatchdogSelection;
   \   000012 BE00                  LDW       X, S:?w1
   \   000014 1C0002                ADDW      X, #0x2
   \   000017 B600                  LD        A, S:?b4
   \   000019 FA                    OR        A, (X)
   \   00001A BE00                  LDW       X, S:?w1
   \   00001C 1C0002                ADDW      X, #0x2
   \   00001F F7                    LD        (X), A
    461          
    462            /* Set the ADC high threshold */
    463            ADCx->HTRH = (uint8_t)(HighThreshold >> 8);
   \   000020 93                    LDW       X, Y
   \   000021 4F                    CLR       A
   \   000022 01                    RRWA      X, A
   \   000023 9F                    LD        A, XL
   \   000024 BE00                  LDW       X, S:?w1
   \   000026 1C0006                ADDW      X, #0x6
   \   000029 F7                    LD        (X), A
    464            ADCx->HTRL = (uint8_t)(HighThreshold);
   \   00002A BE00                  LDW       X, S:?w1
   \   00002C 1C0007                ADDW      X, #0x7
   \   00002F 909F                  LD        A, YL
   \   000031 F7                    LD        (X), A
    465          
    466            /* Set the ADC low threshold */
    467            ADCx->LTRH = (uint8_t)(LowThreshold >> 8);
   \   000032 BE00                  LDW       X, S:?w0
   \   000034 4F                    CLR       A
   \   000035 01                    RRWA      X, A
   \   000036 9F                    LD        A, XL
   \   000037 BE00                  LDW       X, S:?w1
   \   000039 1C0008                ADDW      X, #0x8
   \   00003C F7                    LD        (X), A
    468            ADCx->LTRL = (uint8_t)LowThreshold;
   \   00003D BE00                  LDW       X, S:?w1
   \   00003F 1C0009                ADDW      X, #0x9
   \   000042 B600                  LD        A, S:?b1
   \   000044 F7                    LD        (X), A
    469          }
   \   000045 81                    RET
    470          
    471          /**
    472            * @brief  Checks whether the specified ADC flag is set or not.
    473            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    474            * @param  ADC_FLAG: specifies the flag to check.
    475            *         This parameter can be a value of @ref ADC_FLAG_TypeDef
    476            * @retval The new state of ADC_FLAG (SET or RESET).
    477            */

   \                                 In section .near_func.text, align 1
    478          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, ADC_FLAG_TypeDef ADC_FLAG)
    479          {
    480            FlagStatus flagstatus = RESET;
   \                     ADC_GetFlagStatus:
   \   000000 3F00                  CLR       S:?b0
    481          
    482            /* Check the parameters */
    483            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
    484          
    485            /* Check the status of the specified ADC flag */
    486            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \   000002 1C0003                ADDW      X, #0x3
   \   000005 F4                    AND       A, (X)
   \   000006 A100                  CP        A, #0x0
   \   000008 2706                  JREQ      L:??ADC_GetFlagStatus_0
    487            {
    488              /* ADC_FLAG is set */
    489              flagstatus = SET;
   \   00000A 35010000              MOV       S:?b0, #0x1
   \   00000E 2002                  JRA       L:??ADC_GetFlagStatus_1
    490            }
    491            else
    492            {
    493              /* ADC_FLAG is reset */
    494              flagstatus = RESET;
   \                     ??ADC_GetFlagStatus_0:
   \   000010 3F00                  CLR       S:?b0
    495            }
    496          
    497            /* Return the ADC_FLAG status */
    498            return  flagstatus;
   \                     ??ADC_GetFlagStatus_1:
   \   000012 B600                  LD        A, S:?b0
   \   000014 81                    RET
    499          }
    500          
    501          /**
    502            * @brief  Clears the ADC's pending flags.
    503            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    504            * @param  ADC_FLAG: specifies the flag to clear.
    505            *         This parameter can be a value of @ref ADC_FLAG_TypeDef
    506            * @retval None
    507            */

   \                                 In section .near_func.text, align 1
    508          void ADC_ClearFlag(ADC_TypeDef* ADCx,
    509                             ADC_FLAG_TypeDef ADC_FLAG)
    510          {
    511            /* Check the parameters */
    512            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
    513          
    514            /* Clear the selected ADC flags */
    515            ADCx->SR = (uint8_t)~ADC_FLAG;
   \                     ADC_ClearFlag:
   \   000000 1C0003                ADDW      X, #0x3
   \   000003 43                    CPL       A
   \   000004 F7                    LD        (X), A
    516          }
   \   000005 81                    RET
    517          
    518          
    519          /**
    520            * @brief  Checks whether the specified ADC interrupt has occurred or not.
    521            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    522            * @param  ADC_IT: specifies the ADC interrupt source to check.
    523            *         This parameter can be a value of @ref ADC_IT_TypeDef
    524            * @retval Status of ADC_IT (SET or RESET).
    525            */

   \                                 In section .near_func.text, align 1
    526          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx,
    527                                   ADC_IT_TypeDef ADC_IT)
    528          {
   \                     ADC_GetITStatus:
   \   000000 B700                  LD        S:?b3, A
    529            ITStatus itstatus = RESET;
   \   000002 3F00                  CLR       S:?b0
    530            uint8_t itmask = 0, enablestatus = 0;
   \   000004 3F00                  CLR       S:?b2
   \   000006 3F00                  CLR       S:?b1
    531          
    532            /* Check the parameters */
    533            assert_param(IS_ADC_GET_IT(ADC_IT));
    534          
    535            /* Get the ADC IT index */
    536            itmask = (uint8_t)(ADC_IT >> 3);
   \   000008 B600                  LD        A, S:?b3
   \   00000A 44                    SRL       A
   \   00000B 44                    SRL       A
   \   00000C 44                    SRL       A
   \   00000D B700                  LD        S:?b2, A
    537            itmask =  (uint8_t)((uint8_t)((uint8_t)(itmask & (uint8_t)0x10) >> 2) | (uint8_t)(itmask & (uint8_t)0x03));
   \   00000F B600                  LD        A, S:?b2
   \   000011 A410                  AND       A, #0x10
   \   000013 44                    SRL       A
   \   000014 44                    SRL       A
   \   000015 B700                  LD        S:?b4, A
   \   000017 B600                  LD        A, S:?b2
   \   000019 A403                  AND       A, #0x3
   \   00001B BA00                  OR        A, S:?b4
   \   00001D B700                  LD        S:?b2, A
    538          
    539            /* Get the ADC_IT enable bit status */
    540            enablestatus = (uint8_t)(ADCx->CR1 & (uint8_t)ADC_IT) ;
   \   00001F B600                  LD        A, S:?b3
   \   000021 F4                    AND       A, (X)
   \   000022 B700                  LD        S:?b1, A
    541          
    542            /* Check the status of the specified ADC interrupt */
    543            if (((ADCx->SR & itmask) != (uint8_t)RESET) && enablestatus)
   \   000024 1C0003                ADDW      X, #0x3
   \   000027 B600                  LD        A, S:?b2
   \   000029 F4                    AND       A, (X)
   \   00002A A100                  CP        A, #0x0
   \   00002C 270A                  JREQ      L:??ADC_GetITStatus_0
   \   00002E 3D00                  TNZ       S:?b1
   \   000030 2706                  JREQ      L:??ADC_GetITStatus_0
    544            {
    545              /* ADC_IT is set */
    546              itstatus = SET;
   \   000032 35010000              MOV       S:?b0, #0x1
   \   000036 2002                  JRA       L:??ADC_GetITStatus_1
    547            }
    548            else
    549            {
    550              /* ADC_IT is reset */
    551              itstatus = RESET;
   \                     ??ADC_GetITStatus_0:
   \   000038 3F00                  CLR       S:?b0
    552            }
    553          
    554            /* Return the ADC_IT status */
    555            return  itstatus;
   \                     ??ADC_GetITStatus_1:
   \   00003A B600                  LD        A, S:?b0
   \   00003C 81                    RET
    556          }
    557          
    558          /**
    559            * @brief  Clears the ADCs interrupt pending bits.
    560            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    561            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
    562            *         This parameter can be a value of @ref ADC_IT_TypeDef
    563            * @retval None
    564            */

   \                                 In section .near_func.text, align 1
    565          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx,
    566                                     ADC_IT_TypeDef ADC_IT)
    567          {
    568            uint8_t itmask = 0;
   \                     ADC_ClearITPendingBit:
   \   000000 3F00                  CLR       S:?b0
    569          
    570            /* Check the parameters */
    571            assert_param(IS_ADC_IT(ADC_IT));
    572          
    573            /* Get the ADC IT index */
    574            itmask = (uint8_t)(ADC_IT >> 3);
   \   000002 44                    SRL       A
   \   000003 44                    SRL       A
   \   000004 44                    SRL       A
   \   000005 B700                  LD        S:?b0, A
    575            itmask =  (uint8_t)((uint8_t)(((uint8_t)(itmask & (uint8_t)0x10)) >> 2) | (uint8_t)(itmask & (uint8_t)0x03));
   \   000007 B600                  LD        A, S:?b0
   \   000009 A410                  AND       A, #0x10
   \   00000B 44                    SRL       A
   \   00000C 44                    SRL       A
   \   00000D B700                  LD        S:?b1, A
   \   00000F B600                  LD        A, S:?b0
   \   000011 A403                  AND       A, #0x3
   \   000013 BA00                  OR        A, S:?b1
   \   000015 B700                  LD        S:?b0, A
    576          
    577            /* Clear the selected ADC interrupt pending bits */
    578            ADCx->SR = (uint8_t)~itmask;
   \   000017 1C0003                ADDW      X, #0x3
   \   00001A 3300                  CPL       S:?b0
   \   00001C B600                  LD        A, S:?b0
   \   00001E F7                    LD        (X), A
    579          }
   \   00001F 81                    RET
    580          
    581          /**
    582              * @}
    583              */
    584          
    585          /**
    586            * @}
    587            */
    588          
    589          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     ADC_DeInit                      136
     ADC_Init                         37
     ADC_ChannelCmd                   75
     ADC_Cmd                          13
     ADC_ITConfig                     11
     ADC_DMACmd                       33
     ADC_TempSensorCmd                13
     ADC_VrefintCmd                   13
     ADC_SoftwareStartConv             5
     ADC_SamplingTimeConfig           64
     ADC_SchmittTriggerConfig         75
     ADC_ExternalTrigConfig           29
     ADC_GetConversionValue           43
     ADC_AnalogWatchdogChannelSelect
                                      35
     ADC_AnalogWatchdogThresholdsConfig
                                      40
     ADC_AnalogWatchdogConfig         70
     ADC_GetFlagStatus                21
     ADC_ClearFlag                     6
     ADC_GetITStatus                  61
     ADC_ClearITPendingBit            32

 
 812 bytes in section .near_func.text
 
 812 bytes of CODE memory

Errors: none
Warnings: none
