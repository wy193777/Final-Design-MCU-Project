###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             12/Mar/2014  16:17:10 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_d #
#                    ac.c                                                     #
#    Command line =  "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_d #
#                    ac.c" -e -Ol --no_cse --no_unroll --no_inline            #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model small --data_model medium -o                #
#                    "F:\Skydrive\Final Design\Servo Motor STM8L\Debug\Obj\"  #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.0\stm8\LIB\dlstm8smn.h" -D STM8L15X_MD -lCN            #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Debug\List\" --diag_suppress Pe177,Pe550 -I        #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Project\Discover\inc\" -I "F:\Skydrive\Final       #
#                    Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Dr #
#                    iver\inc\" --vregs 16                                    #
#    List file    =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\List\stm8l15x_dac.lst                        #
#    Object file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\Obj\stm8l15x_dac.o                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\Skydrive\Final Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_dac.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the DAC firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_dac.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          
     35          /**
     36              * @addtogroup DAC_Public_Functions
     37              * @{
     38              */
     39          
     40          /**
     41            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
     42            * @param  None
     43            * @retval None
     44            */

   \                                 In section .near_func.text, align 1
     45          void DAC_DeInit(void)
     46          {
     47            /*  Set Channel1  the Configuration registers to their reset values */
     48            DAC->CH1CR1 = DAC_CR1_RESET_VALUE;
   \                     DAC_DeInit:
   \   000000 35005380              MOV       L:0x5380, #0x0
     49            DAC->CH1CR2 = DAC_CR2_RESET_VALUE;
   \   000004 35005381              MOV       L:0x5381, #0x0
     50          
     51            /*  Set Channel2  the Configuration registers to their reset values */
     52            DAC->CH2CR1 = DAC_CR1_RESET_VALUE;
   \   000008 35005382              MOV       L:0x5382, #0x0
     53            DAC->CH2CR2 = DAC_CR2_RESET_VALUE;
   \   00000C 35005383              MOV       L:0x5383, #0x0
     54          
     55            /*  Set the Software Trigger configuration registers to their reset values */
     56            DAC->SWTRIGR = DAC_SWTRIGR_RESET_VALUE;
   \   000010 35005384              MOV       L:0x5384, #0x0
     57          
     58            /*  Set the Status registers to their reset values */
     59            DAC->SR = (uint8_t)~DAC_SR_RESET_VALUE;
   \   000014 35FF5385              MOV       L:0x5385, #0xff
     60          
     61            /*  Set the Channel1 Data holding registers to their reset values */
     62            DAC->CH1RDHRH = DAC_RDHRH_RESET_VALUE;
   \   000018 35005388              MOV       L:0x5388, #0x0
     63            DAC->CH1RDHRL = DAC_RDHRL_RESET_VALUE;
   \   00001C 35005389              MOV       L:0x5389, #0x0
     64            DAC->CH1LDHRH = DAC_LDHRH_RESET_VALUE;
   \   000020 3500538C              MOV       L:0x538c, #0x0
     65            DAC->CH1LDHRL = DAC_LDHRL_RESET_VALUE;
   \   000024 3500538D              MOV       L:0x538d, #0x0
     66            DAC->CH1DHR8 = DAC_DHR8_RESET_VALUE;
   \   000028 35005390              MOV       L:0x5390, #0x0
     67          
     68            /*  Set the Channel2 Data holding registers to their reset values */
     69            DAC->CH2RDHRH = DAC_RDHRH_RESET_VALUE;
   \   00002C 35005394              MOV       L:0x5394, #0x0
     70            DAC->CH2RDHRL = DAC_RDHRL_RESET_VALUE;
   \   000030 35005395              MOV       L:0x5395, #0x0
     71            DAC->CH2LDHRH = DAC_LDHRH_RESET_VALUE;
   \   000034 35005398              MOV       L:0x5398, #0x0
     72            DAC->CH2LDHRL = DAC_LDHRL_RESET_VALUE;
   \   000038 35005399              MOV       L:0x5399, #0x0
     73            DAC->CH2DHR8 = DAC_DHR8_RESET_VALUE;
   \   00003C 3500539C              MOV       L:0x539c, #0x0
     74          
     75            /*  Set the Dual mode 12bit Right Data holding registers to their reset values */
     76            DAC->DCH1RDHRH = DAC_RDHRH_RESET_VALUE;
   \   000040 350053A0              MOV       L:0x53a0, #0x0
     77            DAC->DCH1RDHRL = DAC_RDHRL_RESET_VALUE;
   \   000044 350053A1              MOV       L:0x53a1, #0x0
     78            DAC->DCH2RDHRH = DAC_RDHRH_RESET_VALUE;
   \   000048 350053A2              MOV       L:0x53a2, #0x0
     79            DAC->DCH2RDHRL = DAC_RDHRL_RESET_VALUE;
   \   00004C 350053A3              MOV       L:0x53a3, #0x0
     80          
     81            /*  Set the Dual mode 12bit Left Data holding registers to their reset values */
     82            DAC->DCH1LDHRH = DAC_LDHRH_RESET_VALUE;
   \   000050 350053A4              MOV       L:0x53a4, #0x0
     83            DAC->DCH1LDHRL = DAC_LDHRL_RESET_VALUE;
   \   000054 350053A5              MOV       L:0x53a5, #0x0
     84            DAC->DCH2LDHRH = DAC_LDHRH_RESET_VALUE;
   \   000058 350053A6              MOV       L:0x53a6, #0x0
     85            DAC->DCH2LDHRL = DAC_LDHRL_RESET_VALUE;
   \   00005C 350053A7              MOV       L:0x53a7, #0x0
     86          
     87            /*  Set the Dual mode 8bit Data holding registers to their reset values */
     88            DAC->DCH1DHR8 = DAC_DHR8_RESET_VALUE;
   \   000060 350053A8              MOV       L:0x53a8, #0x0
     89            DAC->DCH2DHR8 = DAC_DHR8_RESET_VALUE;
   \   000064 350053A9              MOV       L:0x53a9, #0x0
     90          }
   \   000068 81                    RET
     91          
     92          /**
     93            * @brief  Initializes the DAC according to the specified parameters.
     94            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
     95            *         enumeration.
     96            * @param  DAC_Trigger : the selected DAC trigger from @ref DAC_Trigger_TypeDef
     97            *         enumeration.
     98            * @param  DAC_OutputBuffer : the status of DAC load Buffer from
     99            *         @ref DAC_OutputBuffer_TypeDef enumeration.
    100            * @retval None
    101            */

   \                                 In section .near_func.text, align 1
    102          void DAC_Init(DAC_Channel_TypeDef DAC_Channel,
    103                        DAC_Trigger_TypeDef DAC_Trigger,
    104                        DAC_OutputBuffer_TypeDef DAC_OutputBuffer)
    105          {
    106            uint8_t tmpreg = 0;
   \                     DAC_Init:
   \   000000 3F00                  CLR       S:?b2
    107            uint16_t tmpreg2 = 0;
   \   000002 5F                    CLRW      X
    108          
    109            /* Check the DAC parameters */
    110            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    111            assert_param(IS_DAC_TRIGGER(DAC_Trigger));
    112            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_OutputBuffer));
    113          
    114            /* Get the DAC CHxCR1 value */
    115            tmpreg2 =  (uint16_t)((uint8_t)((uint8_t)DAC_Channel << 1));
   \   000003 48                    SLL       A
   \   000004 905F                  CLRW      Y
   \   000006 9097                  LD        YL, A
   \   000008 93                    LDW       X, Y
    116            tmpreg = *(uint8_t*)((uint16_t)(DAC_BASE + CR1_Offset + tmpreg2));
   \   000009 9093                  LDW       Y, X
   \   00000B 72A95380              ADDW      Y, #0x5380
   \   00000F 90F6                  LD        A, (Y)
   \   000011 B700                  LD        S:?b2, A
    117          
    118            /* Clear BOFFx, TENx, TSELx bits */
    119            tmpreg &= (uint8_t)~(DAC_CR1_BOFF | DAC_CR1_TEN | DAC_CR1_TSEL );
   \   000013 B600                  LD        A, S:?b2
   \   000015 A4C1                  AND       A, #0xc1
   \   000017 B700                  LD        S:?b2, A
    120          
    121            /* Set BOFFx bit according to DAC_OutputBuffer value */
    122            tmpreg |= (uint8_t)(DAC_OutputBuffer);
   \   000019 B600                  LD        A, S:?b1
   \   00001B BA00                  OR        A, S:?b2
   \   00001D B700                  LD        S:?b2, A
    123          
    124          
    125            /* Configure for the selected DAC channel trigger*/
    126            if (DAC_Trigger != DAC_Trigger_None)
   \   00001F B600                  LD        A, S:?b0
   \   000021 A130                  CP        A, #0x30
   \   000023 2708                  JREQ      L:??DAC_Init_0
    127            {
    128              /* Set TSELx and TEN  bits according to DAC_Trigger value */
    129              tmpreg |= (uint8_t)(DAC_CR1_TEN | DAC_Trigger) ;
   \   000025 B600                  LD        A, S:?b0
   \   000027 AA04                  OR        A, #0x4
   \   000029 BA00                  OR        A, S:?b2
   \   00002B B700                  LD        S:?b2, A
    130            }
    131          
    132            /* Write to DAC CHxCR1 */
    133            *(uint8_t*)((uint16_t)(DAC_BASE + CR1_Offset + tmpreg2)) = (uint8_t)tmpreg;
   \                     ??DAC_Init_0:
   \   00002D 1C5380                ADDW      X, #0x5380
   \   000030 B600                  LD        A, S:?b2
   \   000032 F7                    LD        (X), A
    134          }
   \   000033 81                    RET
    135          
    136          /**
    137            * @brief  Enables or disables DAC Wave Generation according to the specified
    138            *         parameters.
    139            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
    140            *         enumeration.
    141            * @param  DAC_Wave : the selected waveform from @ref DAC_Wave_TypeDef enumeration.
    142            * @retval None
    143            */

   \                                 In section .near_func.text, align 1
    144          void DAC_WaveGenerationCmd(DAC_Channel_TypeDef DAC_Channel,
    145                                     DAC_Wave_TypeDef DAC_Wave,
    146                                     FunctionalState NewState)
    147          {
   \                     DAC_WaveGenerationCmd:
   \   000000 B700                  LD        S:?b2, A
    148            uint8_t tmpreg = 0;
   \   000002 3F00                  CLR       S:?b3
    149          
    150            /* Check the DAC parameters */
    151            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    152            assert_param(IS_DAC_WAVE(DAC_Wave));
    153            assert_param(IS_FUNCTIONAL_STATE(NewState));
    154          
    155            /* Get the DAC CHxCR1 value & Clear WAVEN bits */
    156            tmpreg = (uint8_t)((*(uint8_t*)(uint16_t)(DAC_BASE + CR1_Offset + (uint8_t)((uint8_t)DAC_Channel << 1))) & (uint8_t)~(DAC_CR1_WAVEN));
   \   000004 B600                  LD        A, S:?b2
   \   000006 48                    SLL       A
   \   000007 5F                    CLRW      X
   \   000008 97                    LD        XL, A
   \   000009 1C5380                ADDW      X, #0x5380
   \   00000C F6                    LD        A, (X)
   \   00000D A43F                  AND       A, #0x3f
   \   00000F B700                  LD        S:?b3, A
    157          
    158            if (NewState != DISABLE)
   \   000011 3D00                  TNZ       S:?b1
   \   000013 2706                  JREQ      L:??DAC_WaveGenerationCmd_0
    159            {
    160              tmpreg |= (uint8_t)(DAC_Wave);
   \   000015 B600                  LD        A, S:?b0
   \   000017 BA00                  OR        A, S:?b3
   \   000019 B700                  LD        S:?b3, A
    161            }
    162          
    163            /* Write to DAC CHxCR1 */
    164            (*(uint8_t*) (uint16_t)(DAC_BASE + CR1_Offset +  (uint8_t)((uint8_t)DAC_Channel << 1))) = tmpreg;
   \                     ??DAC_WaveGenerationCmd_0:
   \   00001B B600                  LD        A, S:?b2
   \   00001D 48                    SLL       A
   \   00001E 5F                    CLRW      X
   \   00001F 97                    LD        XL, A
   \   000020 1C5380                ADDW      X, #0x5380
   \   000023 B600                  LD        A, S:?b3
   \   000025 F7                    LD        (X), A
    165          
    166          }
   \   000026 81                    RET
    167          
    168          
    169          /**
    170            * @brief  Select DAC Noise Wave Generation LFSR according to the specified
    171            *         parameters.
    172            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
    173            *         enumeration.
    174            * @param  DAC_LFSRUnmask : the selected unmasked bit from
    175            *         @ref DAC_LFSRUnmask_TypeDef enumeration.
    176            * @retval None
    177            */

   \                                 In section .near_func.text, align 1
    178          void DAC_NoiseWaveLFSR(DAC_Channel_TypeDef DAC_Channel, DAC_LFSRUnmask_TypeDef DAC_LFSRUnmask)
    179          {
    180            uint8_t tmpreg = 0;
   \                     DAC_NoiseWaveLFSR:
   \   000000 3F00                  CLR       S:?b1
    181            uint16_t cr2addr = 0;
   \   000002 905F                  CLRW      Y
    182          
    183            /* Check the DAC parameters */
    184            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    185            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_LFSRUnmask));
    186          
    187            /* Get the DAC CHxCR2 value  &  Clear MAMPx bits */
    188            cr2addr = (uint16_t)(DAC_BASE + CR2_Offset + (uint8_t)((uint8_t)DAC_Channel << 1));
   \   000004 48                    SLL       A
   \   000005 5F                    CLRW      X
   \   000006 97                    LD        XL, A
   \   000007 1C5381                ADDW      X, #0x5381
   \   00000A 9093                  LDW       Y, X
    189            tmpreg = (uint8_t)((*(uint8_t*)(cr2addr)) & (uint8_t)~(DAC_CR2_MAMPx));
   \   00000C 90F6                  LD        A, (Y)
   \   00000E A4F0                  AND       A, #0xf0
   \   000010 B700                  LD        S:?b1, A
    190          
    191            /* Write to DAC CHxCR2 */
    192            (*(uint8_t*)(cr2addr)) = (uint8_t)( tmpreg | DAC_LFSRUnmask);
   \   000012 B600                  LD        A, S:?b0
   \   000014 BA00                  OR        A, S:?b1
   \   000016 90F7                  LD        (Y), A
    193          }
   \   000018 81                    RET
    194          /**
    195            * @brief  Select DAC Triangle Wave Generation Amplitude according
    196            *         to the specified parameters.
    197            * @param  DAC_Channel : the selected DAC channel from
    198            *         @ref DAC_Channel_TypeDef enumeration.
    199            * @param  DAC_TriangleAmplitude : the selected Amplitude from
    200            *         @ref DAC_TriangleAmplitude_TypeDef enumeration.
    201            * @retval None
    202            */

   \                                 In section .near_func.text, align 1
    203          void DAC_TriangleWaveAmplitude(DAC_Channel_TypeDef DAC_Channel, DAC_TriangleAmplitude_TypeDef DAC_TriangleAmplitude)
    204          {
    205            uint8_t tmpreg = 0;
   \                     DAC_TriangleWaveAmplitude:
   \   000000 3F00                  CLR       S:?b1
    206            uint16_t cr2addr = 0;
   \   000002 905F                  CLRW      Y
    207          
    208            /* Check the DAC parameters */
    209            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    210            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_TriangleAmplitude));
    211          
    212          
    213            /* Get the DAC CHxCR2 value  &  Clear MAMPx bits */
    214            cr2addr = (uint16_t)(DAC_BASE + CR2_Offset + (uint8_t)((uint8_t)DAC_Channel << 1));
   \   000004 48                    SLL       A
   \   000005 5F                    CLRW      X
   \   000006 97                    LD        XL, A
   \   000007 1C5381                ADDW      X, #0x5381
   \   00000A 9093                  LDW       Y, X
    215            tmpreg = (uint8_t)((*(uint8_t*)(cr2addr)) & (uint8_t)~(DAC_CR2_MAMPx));
   \   00000C 90F6                  LD        A, (Y)
   \   00000E A4F0                  AND       A, #0xf0
   \   000010 B700                  LD        S:?b1, A
    216          
    217            /* Write to DAC CHxCR2 */
    218            (*(uint8_t*)(cr2addr)) = (uint8_t)( tmpreg | DAC_TriangleAmplitude);
   \   000012 B600                  LD        A, S:?b0
   \   000014 BA00                  OR        A, S:?b1
   \   000016 90F7                  LD        (Y), A
    219          }
   \   000018 81                    RET
    220          /**
    221            * @brief  Enables or disables the specified DAC channel.
    222            * @param  DAC_Channel : the selected DAC channel from
    223            *         @ref DAC_Channel_TypeDef enumeration.
    224            * @param  NewState : new state of the DAC channel.
    225            *         This parameter can be: ENABLE or DISABLE.
    226            * @retval None
    227            */

   \                                 In section .near_func.text, align 1
    228          void DAC_Cmd(DAC_Channel_TypeDef DAC_Channel, FunctionalState NewState)
    229          {
    230            uint16_t cr1addr = 0;
   \                     DAC_Cmd:
   \   000000 5F                    CLRW      X
    231            /* Check the parameters */
    232            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    233            assert_param(IS_FUNCTIONAL_STATE(NewState));
    234          
    235            /* Find CHxCR1 register Address */
    236            cr1addr = DAC_BASE + CR1_Offset + (uint8_t)((uint8_t)DAC_Channel << 1);
   \   000001 48                    SLL       A
   \   000002 905F                  CLRW      Y
   \   000004 9097                  LD        YL, A
   \   000006 72A95380              ADDW      Y, #0x5380
   \   00000A 93                    LDW       X, Y
    237          
    238            if (NewState != DISABLE)
   \   00000B 3D00                  TNZ       S:?b0
   \   00000D 2705                  JREQ      L:??DAC_Cmd_0
    239            {
    240              /* Enable the selected DAC channel */
    241              (*(uint8_t*)(cr1addr)) |= DAC_CR1_EN;
   \   00000F F6                    LD        A, (X)
   \   000010 AA01                  OR        A, #0x1
   \   000012 F7                    LD        (X), A
   \   000013 81                    RET
    242            }
    243            else
    244            {
    245              /* Disable the selected DAC channel */
    246              (*(uint8_t*)(cr1addr)) &= (uint8_t) ~(DAC_CR1_EN);
   \                     ??DAC_Cmd_0:
   \   000014 F6                    LD        A, (X)
   \   000015 A4FE                  AND       A, #0xfe
   \   000017 F7                    LD        (X), A
    247            }
    248          }
   \   000018 81                    RET
    249          
    250          /**
    251            * @brief  Enables or disables the specified DAC interrupts.
    252            * @param  DAC_Channel : the selected DAC channel from
    253            *         @ref DAC_Channel_TypeDef enumeration.
    254            * @param  DAC_IT : the selected DAC interrupt from
    255            *         @ref DAC_IT_TypeDef enumeration.
    256            * @param  NewState : new state of the DAC interrupt .
    257            *         This parameter can be: ENABLE or DISABLE.
    258            * @retval None
    259            */

   \                                 In section .near_func.text, align 1
    260          void DAC_ITConfig(DAC_Channel_TypeDef DAC_Channel, DAC_IT_TypeDef DAC_IT,
    261                            FunctionalState NewState)
    262          {
    263            uint16_t cr2addr = 0;
   \                     DAC_ITConfig:
   \   000000 905F                  CLRW      Y
    264          
    265            /* Check the parameters */
    266            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    267            assert_param(IS_FUNCTIONAL_STATE(NewState));
    268            assert_param(IS_DAC_IT(DAC_IT));
    269          
    270            /* Find CHxCR2 register Address */
    271            cr2addr = DAC_BASE + CR2_Offset + (uint8_t)((uint8_t)DAC_Channel << 1);
   \   000002 48                    SLL       A
   \   000003 5F                    CLRW      X
   \   000004 97                    LD        XL, A
   \   000005 1C5381                ADDW      X, #0x5381
   \   000008 9093                  LDW       Y, X
    272          
    273            if (NewState != DISABLE)
   \   00000A 3D00                  TNZ       S:?b1
   \   00000C 2707                  JREQ      L:??DAC_ITConfig_0
    274            {
    275              /* Enable the selected DAC interrupts */
    276              (*(uint8_t*)(cr2addr)) |=  (uint8_t)(DAC_IT);
   \   00000E B600                  LD        A, S:?b0
   \   000010 90FA                  OR        A, (Y)
   \   000012 90F7                  LD        (Y), A
   \   000014 81                    RET
    277            }
    278            else
    279            {
    280              /* Disable the selected DAC interrupts */
    281              (*(uint8_t*)(cr2addr)) &= (uint8_t)(~(DAC_IT));
   \                     ??DAC_ITConfig_0:
   \   000015 3300                  CPL       S:?b0
   \   000017 B600                  LD        A, S:?b0
   \   000019 90F4                  AND       A, (Y)
   \   00001B 90F7                  LD        (Y), A
    282            }
    283          }
   \   00001D 81                    RET
    284          
    285          /**
    286            * @brief  Enables or disables the specified DAC channel DMA request.
    287            * @param  DAC_Channel : the selected DAC channel from
    288            *         @ref DAC_Channel_TypeDef enumeration.
    289            * @param  NewState : new state of the selected DAC channel DMA request.
    290            *         This parameter can be: ENABLE or DISABLE.
    291            * @retval None.
    292            */

   \                                 In section .near_func.text, align 1
    293          void DAC_DMACmd(DAC_Channel_TypeDef DAC_Channel, FunctionalState NewState)
    294          {
    295            uint16_t cr2addr = 0;
   \                     DAC_DMACmd:
   \   000000 5F                    CLRW      X
    296          
    297            /* Check the parameters */
    298            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    299            assert_param(IS_FUNCTIONAL_STATE(NewState));
    300          
    301            /* Find CHxCR2 register Address */
    302            cr2addr = DAC_BASE + CR2_Offset + (uint8_t)((uint8_t)DAC_Channel << 1);
   \   000001 48                    SLL       A
   \   000002 905F                  CLRW      Y
   \   000004 9097                  LD        YL, A
   \   000006 72A95381              ADDW      Y, #0x5381
   \   00000A 93                    LDW       X, Y
    303          
    304            if (NewState != DISABLE)
   \   00000B 3D00                  TNZ       S:?b0
   \   00000D 2705                  JREQ      L:??DAC_DMACmd_0
    305            {
    306              /* Enable the selected DAC channel DMA request */
    307              (*(uint8_t*)(cr2addr)) |= DAC_CR2_DMAEN;
   \   00000F F6                    LD        A, (X)
   \   000010 AA10                  OR        A, #0x10
   \   000012 F7                    LD        (X), A
   \   000013 81                    RET
    308            }
    309            else
    310            {
    311              /* Disable the selected DAC channel DMA request */
    312              (*(uint8_t*)(cr2addr)) &= (uint8_t)~(DAC_CR2_DMAEN);
   \                     ??DAC_DMACmd_0:
   \   000014 F6                    LD        A, (X)
   \   000015 A4EF                  AND       A, #0xef
   \   000017 F7                    LD        (X), A
    313            }
    314          }
   \   000018 81                    RET
    315          
    316          /**
    317            * @brief  Enables or disables the selected DAC channel software trigger.
    318            * @param  DAC_Channel : the selected DAC channel from
    319            *         @ref DAC_Channel_TypeDef enumeration.
    320            * @param  NewState : new state of the selected DAC channel software trigger.
    321            *         This parameter can be: ENABLE or DISABLE.
    322            * @retval None.
    323            */

   \                                 In section .near_func.text, align 1
    324          void DAC_SoftwareTriggerCmd(DAC_Channel_TypeDef DAC_Channel, FunctionalState NewState)
    325          {
    326            /* Check the parameters */
    327            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    328            assert_param(IS_FUNCTIONAL_STATE(NewState));
    329          
    330            if (NewState != DISABLE)
   \                     DAC_SoftwareTriggerCmd:
   \   000000 3D00                  TNZ       S:?b0
   \   000002 270D                  JREQ      L:??DAC_SoftwareTriggerCmd_0
    331            {
    332              /* Enable software trigger for the selected DAC channel */
    333              DAC->SWTRIGR |= (uint8_t)(DAC_SWTRIGR_SWTRIG1 << DAC_Channel);
   \   000004 5F                    CLRW      X
   \   000005 5C                    INCW      X
   \   000006 CD0000                CALL      L:?sll16_x_x_a
   \   000009 9F                    LD        A, XL
   \   00000A CA5384                OR        A, L:0x5384
   \   00000D C75384                LD        L:0x5384, A
   \   000010 81                    RET
    334            }
    335            else
    336            {
    337              /* Disable software trigger for the selected DAC channel */
    338              DAC->SWTRIGR &= (uint8_t)~((uint8_t)(DAC_SWTRIGR_SWTRIG1 << DAC_Channel));
   \                     ??DAC_SoftwareTriggerCmd_0:
   \   000011 5F                    CLRW      X
   \   000012 5C                    INCW      X
   \   000013 CD0000                CALL      L:?sll16_x_x_a
   \   000016 9F                    LD        A, XL
   \   000017 43                    CPL       A
   \   000018 C45384                AND       A, L:0x5384
   \   00001B C75384                LD        L:0x5384, A
    339            }
    340          }
   \   00001E 81                    RET
    341          
    342          
    343          /**
    344            * @brief  Enables or disables the dual channel DAC  software triggers.
    345            * @param  NewState : new state of the  DAC channels software triggers.
    346            *         This parameter can be: ENABLE or DISABLE.
    347            * @retval None.
    348            */

   \                                 In section .near_func.text, align 1
    349          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    350          {
    351            /* Check the parameters */
    352            assert_param(IS_FUNCTIONAL_STATE(NewState));
    353          
    354            if (NewState != DISABLE)
   \                     DAC_DualSoftwareTriggerCmd:
   \   000000 4D                    TNZ       A
   \   000001 2709                  JREQ      L:??DAC_DualSoftwareTriggerCmd_0
    355            {
    356              /* Enable software trigger for both DAC channels */
    357              DAC->SWTRIGR |= (DAC_SWTRIGR_SWTRIG1 | DAC_SWTRIGR_SWTRIG2) ;
   \   000003 C65384                LD        A, L:0x5384
   \   000006 AA03                  OR        A, #0x3
   \   000008 C75384                LD        L:0x5384, A
   \   00000B 81                    RET
    358            }
    359            else
    360            {
    361              /* Disable software trigger for both DAC channels */
    362              DAC->SWTRIGR &= (uint8_t)~(DAC_SWTRIGR_SWTRIG1 | DAC_SWTRIGR_SWTRIG2);
   \                     ??DAC_DualSoftwareTriggerCmd_0:
   \   00000C C65384                LD        A, L:0x5384
   \   00000F A4FC                  AND       A, #0xfc
   \   000011 C75384                LD        L:0x5384, A
    363            }
    364          }
   \   000014 81                    RET
    365          
    366          
    367          /**
    368            * @brief  Set the specified data holding register value for DAC channel1.
    369            * @param  DAC_Align : Specifies the data alignement for DAC channel1 from
    370            *         @ref DAC_Align_TypeDef enumeration.
    371            * @param  DAC_Data : Data to be loaded in the selected data holding register.
    372            * @retval None.
    373            */

   \                                 In section .near_func.text, align 1
    374          void DAC_SetChannel1Data(DAC_Align_TypeDef DAC_Align, uint16_t DAC_Data)
    375          {
   \                     DAC_SetChannel1Data:
   \   000000 B700                  LD        S:?b2, A
   \   000002 9093                  LDW       Y, X
    376            /* Check the parameters */
    377            assert_param(IS_DAC_ALIGN(DAC_Align));
    378          
    379            if (DAC_Align != DAC_Align_8b_R)
   \   000004 B600                  LD        A, S:?b2
   \   000006 A108                  CP        A, #0x8
   \   000008 271D                  JREQ      L:??DAC_SetChannel1Data_0
    380            {
    381              /* Set the DAC channel1 selected data holding register */
    382              *(uint8_t*)((uint16_t)(DAC_BASE + CH1RDHRH_Offset + DAC_Align )) = (uint8_t)(((uint16_t)DAC_Data) >> 8);
   \   00000A 5F                    CLRW      X
   \   00000B 41                    EXG       A, XL
   \   00000C B600                  LD        A, S:?b2
   \   00000E 41                    EXG       A, XL
   \   00000F 1C5388                ADDW      X, #0x5388
   \   000012 BF00                  LDW       S:?w0, X
   \   000014 93                    LDW       X, Y
   \   000015 4F                    CLR       A
   \   000016 01                    RRWA      X, A
   \   000017 9F                    LD        A, XL
   \   000018 92C700                LD        [S:?w0.w], A
    383              *(uint8_t*)((uint16_t)(DAC_BASE + CH1RDHRH_Offset + 1 + DAC_Align )) = (uint8_t)DAC_Data;
   \   00001B 5F                    CLRW      X
   \   00001C 41                    EXG       A, XL
   \   00001D B600                  LD        A, S:?b2
   \   00001F 41                    EXG       A, XL
   \   000020 1C5389                ADDW      X, #0x5389
   \   000023 909F                  LD        A, YL
   \   000025 F7                    LD        (X), A
   \   000026 81                    RET
    384            }
    385            else
    386            {
    387              /* Check the parameter */
    388              assert_param(IS_DAC_DATA_08R(DAC_Data));
    389          
    390              /* Set the DAC channel1 selected data holding register */
    391              DAC->CH1DHR8 = (uint8_t)(DAC_Data);
   \                     ??DAC_SetChannel1Data_0:
   \   000027 909F                  LD        A, YL
   \   000029 C75390                LD        L:0x5390, A
    392            }
    393          }
   \   00002C 81                    RET
    394          
    395          /**
    396            * @brief  Set the specified data holding register value for DAC channel2.
    397            * @param  DAC_Align : Specifies the data alignement for DAC channel2 from
    398            *         @ref DAC_Align_TypeDef enumeration.
    399            * @param  DAC_Data : Data to be loaded in the selected data holding register.
    400            * @retval None.
    401            */

   \                                 In section .near_func.text, align 1
    402          void DAC_SetChannel2Data(DAC_Align_TypeDef DAC_Align, uint16_t DAC_Data)
    403          {
   \                     DAC_SetChannel2Data:
   \   000000 B700                  LD        S:?b2, A
   \   000002 9093                  LDW       Y, X
    404            /* Check the parameters */
    405            assert_param(IS_DAC_ALIGN(DAC_Align));
    406          
    407            if (DAC_Align != DAC_Align_8b_R)
   \   000004 B600                  LD        A, S:?b2
   \   000006 A108                  CP        A, #0x8
   \   000008 271D                  JREQ      L:??DAC_SetChannel2Data_0
    408            {
    409              /* Set the DAC channel2 selected data holding register */
    410              *(uint8_t*)((uint16_t)(DAC_BASE + CH2RDHRH_Offset + DAC_Align )) = (uint8_t)(((uint16_t)DAC_Data) >> 8);
   \   00000A 5F                    CLRW      X
   \   00000B 41                    EXG       A, XL
   \   00000C B600                  LD        A, S:?b2
   \   00000E 41                    EXG       A, XL
   \   00000F 1C5394                ADDW      X, #0x5394
   \   000012 BF00                  LDW       S:?w0, X
   \   000014 93                    LDW       X, Y
   \   000015 4F                    CLR       A
   \   000016 01                    RRWA      X, A
   \   000017 9F                    LD        A, XL
   \   000018 92C700                LD        [S:?w0.w], A
    411              *(uint8_t*)((uint16_t)(DAC_BASE + CH2RDHRH_Offset + 1 + DAC_Align )) = (uint8_t)DAC_Data;
   \   00001B 5F                    CLRW      X
   \   00001C 41                    EXG       A, XL
   \   00001D B600                  LD        A, S:?b2
   \   00001F 41                    EXG       A, XL
   \   000020 1C5395                ADDW      X, #0x5395
   \   000023 909F                  LD        A, YL
   \   000025 F7                    LD        (X), A
   \   000026 81                    RET
    412            }
    413            else
    414            {
    415              /* Check the parameter */
    416              assert_param(IS_DAC_DATA_08R(DAC_Data));
    417          
    418              /* Set the DAC channel2 selected data holding register */
    419              DAC->CH2DHR8 = (uint8_t)(DAC_Data);
   \                     ??DAC_SetChannel2Data_0:
   \   000027 909F                  LD        A, YL
   \   000029 C7539C                LD        L:0x539c, A
    420            }
    421          }
   \   00002C 81                    RET
    422          
    423          /**
    424            * @brief  Set the specified data holding register value for DAC Dual channels data.
    425            * @param  DAC_Align : Specifies the data alignement for DAC channel2 from
    426            *         @ref DAC_Align_TypeDef enumeration.
    427            * @param  DAC_Data2 : Data to be loaded in the selected data holding register
    428            *         for channel 2.
    429            * @param  DAC_Data1 : Data to be loaded in the selected data holding register
    430            *         for channel 1.
    431            * @retval None.
    432            */

   \                                 In section .near_func.text, align 1
    433          void DAC_SetDualChannelData(DAC_Align_TypeDef DAC_Align,
    434                                      uint16_t DAC_Data2,
    435                                      uint16_t DAC_Data1)
    436          {
   \                     DAC_SetDualChannelData:
   \   000000 BF00                  LDW       S:?w1, X
   \   000002 90BF00                LDW       S:?w0, Y
    437            uint16_t dchxrdhrhaddr = 0;
   \   000005 905F                  CLRW      Y
    438          
    439            /* Check the parameters */
    440            assert_param(IS_DAC_ALIGN(DAC_Align));
    441          
    442            if (DAC_Align != DAC_Align_8b_R)
   \   000007 A108                  CP        A, #0x8
   \   000009 2725                  JREQ      L:??DAC_SetDualChannelData_0
    443            {
    444              /* Identify the DCHxRDHRH address*/
    445              dchxrdhrhaddr = (uint16_t)(DAC_BASE + DCH1RDHRH_Offset + DAC_Align);
   \   00000B 5F                    CLRW      X
   \   00000C 97                    LD        XL, A
   \   00000D 1C53A0                ADDW      X, #0x53a0
   \   000010 9093                  LDW       Y, X
    446          
    447              /* Set the DAC channels Dual data holding registers */
    448              *(uint8_t*)(uint16_t)dchxrdhrhaddr = (uint8_t)(((uint16_t)DAC_Data1) >> 8);
   \   000012 BE00                  LDW       X, S:?w0
   \   000014 4F                    CLR       A
   \   000015 01                    RRWA      X, A
   \   000016 9F                    LD        A, XL
   \   000017 90F7                  LD        (Y), A
    449              *(uint8_t*)(uint16_t)(dchxrdhrhaddr + 1) = (uint8_t)DAC_Data1;
   \   000019 93                    LDW       X, Y
   \   00001A 5C                    INCW      X
   \   00001B B600                  LD        A, S:?b1
   \   00001D F7                    LD        (X), A
    450              *(uint8_t*)(uint16_t)(dchxrdhrhaddr + 2) = (uint8_t)(((uint16_t)DAC_Data2) >> 8);
   \   00001E BE00                  LDW       X, S:?w1
   \   000020 4F                    CLR       A
   \   000021 01                    RRWA      X, A
   \   000022 9F                    LD        A, XL
   \   000023 93                    LDW       X, Y
   \   000024 1C0002                ADDW      X, #0x2
   \   000027 F7                    LD        (X), A
    451              *(uint8_t*)(uint16_t)(dchxrdhrhaddr + 3) = (uint8_t)DAC_Data2;
   \   000028 93                    LDW       X, Y
   \   000029 1C0003                ADDW      X, #0x3
   \   00002C B600                  LD        A, S:?b3
   \   00002E F7                    LD        (X), A
   \   00002F 81                    RET
    452            }
    453            else
    454            {
    455              /* Check the parameter */
    456              assert_param(IS_DAC_DATA_08R(DAC_Data1 | DAC_Data2));
    457          
    458              /* Set the DAC channels Dual data holding registers */
    459              DAC->DCH1DHR8 = (uint8_t)(DAC_Data1);
   \                     ??DAC_SetDualChannelData_0:
   \   000030 B600                  LD        A, S:?b1
   \   000032 C753A8                LD        L:0x53a8, A
    460              DAC->DCH2DHR8 = (uint8_t)(DAC_Data2);
   \   000035 B600                  LD        A, S:?b3
   \   000037 C753A9                LD        L:0x53a9, A
    461            }
    462          }
   \   00003A 81                    RET
    463          /**
    464            * @brief  Returns the last data output value of the selected DAC channel.
    465            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
    466            *         enumeration.
    467            * @retval The selected DAC channel data output value.
    468            */

   \                                 In section .near_func.text, align 1
    469          uint16_t DAC_GetDataOutputValue(DAC_Channel_TypeDef DAC_Channel)
    470          {
    471            uint16_t outputdata = 0;
   \                     DAC_GetDataOutputValue:
   \   000000 905F                  CLRW      Y
    472            uint16_t tmp = 0;
   \   000002 5F                    CLRW      X
    473          
    474            /* Check the parameters */
    475            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    476          
    477            if ( DAC_Channel ==  DAC_Channel_1)
   \   000003 4D                    TNZ       A
   \   000004 261C                  JRNE      L:??DAC_GetDataOutputValue_0
    478            {
    479              /* Returns the DAC channel data output register value */
    480              tmp = (uint16_t)((uint16_t)DAC->CH1DORH << 8);
   \   000006 C653AC                LD        A, L:0x53ac
   \   000009 5F                    CLRW      X
   \   00000A 97                    LD        XL, A
   \   00000B 4F                    CLR       A
   \   00000C 02                    RLWA      X, A
    481              outputdata = (uint16_t)(tmp | (DAC->CH1DORL));
   \   00000D C653AD                LD        A, L:0x53ad
   \   000010 905F                  CLRW      Y
   \   000012 9097                  LD        YL, A
   \   000014 90BF00                LDW       S:?w0, Y
   \   000017 01                    RRWA      X, A
   \   000018 BA00                  OR        A, S:?b1
   \   00001A 01                    RRWA      X, A
   \   00001B BA00                  OR        A, S:?b0
   \   00001D 01                    RRWA      X, A
   \   00001E 9093                  LDW       Y, X
   \   000020 201A                  JRA       L:??DAC_GetDataOutputValue_1
    482            }
    483            else
    484            {
    485              /* Returns the DAC channel data output register value */
    486              tmp = (uint16_t)((uint16_t)DAC->CH2DORH << 8);
   \                     ??DAC_GetDataOutputValue_0:
   \   000022 C653B0                LD        A, L:0x53b0
   \   000025 5F                    CLRW      X
   \   000026 97                    LD        XL, A
   \   000027 4F                    CLR       A
   \   000028 02                    RLWA      X, A
    487              outputdata = (uint16_t)(tmp | (DAC->CH2DORL));
   \   000029 C653B1                LD        A, L:0x53b1
   \   00002C 905F                  CLRW      Y
   \   00002E 9097                  LD        YL, A
   \   000030 90BF00                LDW       S:?w0, Y
   \   000033 01                    RRWA      X, A
   \   000034 BA00                  OR        A, S:?b1
   \   000036 01                    RRWA      X, A
   \   000037 BA00                  OR        A, S:?b0
   \   000039 01                    RRWA      X, A
   \   00003A 9093                  LDW       Y, X
    488            }
    489          
    490            /* return the selected DAC channel data output value.*/
    491            return (uint16_t)outputdata;
   \                     ??DAC_GetDataOutputValue_1:
   \   00003C 93                    LDW       X, Y
   \   00003D 81                    RET
    492          }
    493          /**
    494            * @brief  Checks whether the specified DAC flag is set or not.
    495            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
    496            *         enumeration.
    497            * @param  DAC_FLAG : specifies the flag to check from @ref DAC_FLAG_TypeDef
    498            *         enumeration.
    499            * @retval FlagStatus The new state of DAC_FLAG (SET or RESET).
    500            */

   \                                 In section .near_func.text, align 1
    501          FlagStatus DAC_GetFlagStatus(DAC_Channel_TypeDef DAC_Channel, DAC_FLAG_TypeDef DAC_FLAG)
    502          {
    503            FlagStatus flagstatus = RESET;
   \                     DAC_GetFlagStatus:
   \   000000 3F00                  CLR       S:?b2
    504            uint8_t flag = 0;
   \   000002 3F00                  CLR       S:?b1
    505          
    506            /* Check the parameters */
    507            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    508            assert_param(IS_DAC_FLAG(DAC_FLAG));
    509          
    510            flag = (uint8_t)(DAC_FLAG << DAC_Channel);
   \   000004 5F                    CLRW      X
   \   000005 41                    EXG       A, XL
   \   000006 B600                  LD        A, S:?b0
   \   000008 41                    EXG       A, XL
   \   000009 CD0000                CALL      L:?sll16_x_x_a
   \   00000C 9F                    LD        A, XL
   \   00000D B700                  LD        S:?b1, A
    511          
    512            /* Check the status of the specified DAC flag */
    513            if ((DAC->SR & flag ) != (uint8_t)RESET)
   \   00000F B600                  LD        A, S:?b1
   \   000011 C45385                AND       A, L:0x5385
   \   000014 A100                  CP        A, #0x0
   \   000016 2706                  JREQ      L:??DAC_GetFlagStatus_0
    514            {
    515              /* DAC FLAG is set */
    516              flagstatus = SET;
   \   000018 35010000              MOV       S:?b2, #0x1
   \   00001C 2002                  JRA       L:??DAC_GetFlagStatus_1
    517            }
    518            else
    519            {
    520              /* DAC FLAG is reset */
    521              flagstatus = RESET;
   \                     ??DAC_GetFlagStatus_0:
   \   00001E 3F00                  CLR       S:?b2
    522            }
    523          
    524            /* Return the DAC FLAG status */
    525            return  flagstatus;
   \                     ??DAC_GetFlagStatus_1:
   \   000020 B600                  LD        A, S:?b2
   \   000022 81                    RET
    526          }
    527          
    528          /**
    529            * @brief  Clears the DAC channelx's pending flags.
    530            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
    531            *         enumeration.
    532            * @param  DAC_FLAG : specifies the flag to clear from @ref DAC_FLAG_TypeDef
    533            *         enumeration.
    534            * @retval None.
    535            */

   \                                 In section .near_func.text, align 1
    536          void DAC_ClearFlag(DAC_Channel_TypeDef DAC_Channel, DAC_FLAG_TypeDef DAC_FLAG)
    537          {
    538            uint8_t flag = 0;
   \                     DAC_ClearFlag:
   \   000000 3F00                  CLR       S:?b1
    539          
    540            /* Check the parameters */
    541            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    542            assert_param(IS_DAC_FLAG(DAC_FLAG));
    543          
    544            /* identify the selected flag*/
    545            flag = (uint8_t)(DAC_FLAG << DAC_Channel);
   \   000002 5F                    CLRW      X
   \   000003 41                    EXG       A, XL
   \   000004 B600                  LD        A, S:?b0
   \   000006 41                    EXG       A, XL
   \   000007 CD0000                CALL      L:?sll16_x_x_a
   \   00000A 9F                    LD        A, XL
   \   00000B B700                  LD        S:?b1, A
    546          
    547            /* Clear the selected DAC flag */
    548            DAC->SR = (uint8_t)(~flag);
   \   00000D 3300                  CPL       S:?b1
   \   00000F B600                  LD        A, S:?b1
   \   000011 C75385                LD        L:0x5385, A
    549          }
   \   000014 81                    RET
    550          /**
    551            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    552            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
    553            *         enumeration.
    554            * @param  DAC_IT : specifies the DAC interrupt source to check from
    555            *         @ref DAC_IT_TypeDef enumeration.
    556            * @retval ITStatus The new state of DAC_IT (SET or RESET).
    557            */

   \                                 In section .near_func.text, align 1
    558          ITStatus DAC_GetITStatus(DAC_Channel_TypeDef DAC_Channel, DAC_IT_TypeDef DAC_IT)
    559          {
   \                     DAC_GetITStatus:
   \   000000 B700                  LD        S:?b5, A
   \   000002 450000                MOV       S:?b1, S:?b0
    560            ITStatus itstatus = RESET;
   \   000005 3F00                  CLR       S:?b0
    561            uint8_t enablestatus = 0;
   \   000007 3F00                  CLR       S:?b3
    562            uint8_t flagstatus = 0;
   \   000009 3F00                  CLR       S:?b2
    563            uint8_t tempreg = 0;
   \   00000B 3F00                  CLR       S:?b4
    564          
    565            /* Check the parameters */
    566            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    567            assert_param(IS_DAC_IT(DAC_IT));
    568          
    569            /* identify the status of the IT and its correspondent flag*/
    570            tempreg = *(uint8_t*)(uint16_t)(DAC_BASE + CR2_Offset + (uint8_t)((uint8_t)DAC_Channel << 2));
   \   00000D B600                  LD        A, S:?b5
   \   00000F 48                    SLL       A
   \   000010 48                    SLL       A
   \   000011 5F                    CLRW      X
   \   000012 97                    LD        XL, A
   \   000013 1C5381                ADDW      X, #0x5381
   \   000016 F6                    LD        A, (X)
   \   000017 B700                  LD        S:?b4, A
    571            enablestatus = (uint8_t)( tempreg & (uint8_t)((uint8_t)DAC_IT << DAC_Channel));
   \   000019 5F                    CLRW      X
   \   00001A 41                    EXG       A, XL
   \   00001B B600                  LD        A, S:?b1
   \   00001D 41                    EXG       A, XL
   \   00001E B600                  LD        A, S:?b5
   \   000020 CD0000                CALL      L:?sll16_x_x_a
   \   000023 9F                    LD        A, XL
   \   000024 B400                  AND       A, S:?b4
   \   000026 B700                  LD        S:?b3, A
    572            flagstatus = (uint8_t)(DAC->SR & (uint8_t)(DAC_IT >> ((uint8_t)0x05 - DAC_Channel)));
   \   000028 A605                  LD        A, #0x5
   \   00002A B000                  SUB       A, S:?b5
   \   00002C 5F                    CLRW      X
   \   00002D 41                    EXG       A, XL
   \   00002E B600                  LD        A, S:?b1
   \   000030 41                    EXG       A, XL
   \   000031 CD0000                CALL      L:?sra16_x_x_a
   \   000034 9F                    LD        A, XL
   \   000035 C45385                AND       A, L:0x5385
   \   000038 B700                  LD        S:?b2, A
    573          
    574            /* Check the status of the specified DAC interrupt */
    575            if (((flagstatus) != (uint8_t)RESET) && enablestatus)
   \   00003A 3D00                  TNZ       S:?b2
   \   00003C 270A                  JREQ      L:??DAC_GetITStatus_0
   \   00003E 3D00                  TNZ       S:?b3
   \   000040 2706                  JREQ      L:??DAC_GetITStatus_0
    576            {
    577              /* DAC IT is set */
    578              itstatus = SET;
   \   000042 35010000              MOV       S:?b0, #0x1
   \   000046 2002                  JRA       L:??DAC_GetITStatus_1
    579            }
    580            else
    581            {
    582              /* DAC IT is reset */
    583              itstatus = RESET;
   \                     ??DAC_GetITStatus_0:
   \   000048 3F00                  CLR       S:?b0
    584            }
    585          
    586            /* Return the DAC IT status */
    587            return  itstatus;
   \                     ??DAC_GetITStatus_1:
   \   00004A B600                  LD        A, S:?b0
   \   00004C 81                    RET
    588          }
    589          
    590          /**
    591            * @brief   Clears the DAC channelxs interrupt pending bits.
    592            * @param  DAC_Channel : the selected DAC channel from @ref DAC_Channel_TypeDef
    593            *         enumeration.
    594            * @param  DAC_IT : specifies the DAC interrupt pending bit to clear from
    595            *         @ref DAC_IT_TypeDef enumeration.
    596            * @retval None.
    597            */

   \                                 In section .near_func.text, align 1
    598          void DAC_ClearITPendingBit(DAC_Channel_TypeDef DAC_Channel, DAC_IT_TypeDef DAC_IT)
    599          {
   \                     DAC_ClearITPendingBit:
   \   000000 B700                  LD        S:?b1, A
    600            /* Check the parameters */
    601            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    602            assert_param(IS_DAC_IT(DAC_IT));
    603          
    604            /* Clear the selected DAC interrupt pending bits */
    605            DAC->SR = (uint8_t)~(uint8_t)((uint8_t)DAC_IT >> (0x05 - DAC_Channel));
   \   000002 A605                  LD        A, #0x5
   \   000004 B000                  SUB       A, S:?b1
   \   000006 5F                    CLRW      X
   \   000007 41                    EXG       A, XL
   \   000008 B600                  LD        A, S:?b0
   \   00000A 41                    EXG       A, XL
   \   00000B CD0000                CALL      L:?sra16_x_x_a
   \   00000E 9F                    LD        A, XL
   \   00000F 43                    CPL       A
   \   000010 C75385                LD        L:0x5385, A
    606          }
   \   000013 81                    RET
    607          
    608          /**
    609              * @}
    610              */
    611          
    612          /**
    613            * @}
    614            */
    615          
    616          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label             Bytes
     --------------             -----
     DAC_DeInit                  105
     DAC_Init                     52
     DAC_WaveGenerationCmd        39
     DAC_NoiseWaveLFSR            25
     DAC_TriangleWaveAmplitude    25
     DAC_Cmd                      25
     DAC_ITConfig                 30
     DAC_DMACmd                   25
     DAC_SoftwareTriggerCmd       31
     DAC_DualSoftwareTriggerCmd   21
     DAC_SetChannel1Data          45
     DAC_SetChannel2Data          45
     DAC_SetDualChannelData       59
     DAC_GetDataOutputValue       62
     DAC_GetFlagStatus            35
     DAC_ClearFlag                21
     DAC_GetITStatus              77
     DAC_ClearITPendingBit        20

 
 742 bytes in section .near_func.text
 
 742 bytes of CODE memory

Errors: none
Warnings: none
