###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             12/Mar/2014  16:17:10 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_c #
#                    omp.c                                                    #
#    Command line =  "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_c #
#                    omp.c" -e -Ol --no_cse --no_unroll --no_inline           #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model small --data_model medium -o                #
#                    "F:\Skydrive\Final Design\Servo Motor STM8L\Debug\Obj\"  #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.0\stm8\LIB\dlstm8smn.h" -D STM8L15X_MD -lCN            #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Debug\List\" --diag_suppress Pe177,Pe550 -I        #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Project\Discover\inc\" -I "F:\Skydrive\Final       #
#                    Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Dr #
#                    iver\inc\" --vregs 16                                    #
#    List file    =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\List\stm8l15x_comp.lst                       #
#    Object file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\Obj\stm8l15x_comp.o                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\Skydrive\Final Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_comp.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_comp.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the COMP firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_comp.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          
     35          /**
     36            * @addtogroup COMP_Public_Functions
     37            * @{
     38            */
     39          
     40          /**
     41            * @brief  Deinitializes the COMPx peripheral registers to their default reset values.
     42            * @param  None.
     43            * @retval None.
     44            */

   \                                 In section .near_func.text, align 1
     45          void COMP_DeInit(void)
     46          {
     47            /* Set COMP->CSR1 to reset value 0x00 */
     48            COMP->CSR1 = (uint8_t) COMP_CSR1_RESET_VALUE;
   \                     COMP_DeInit:
   \   000000 35005440              MOV       L:0x5440, #0x0
     49          
     50            /* Set COMP->CSR2 to reset value 0x00 */
     51            COMP->CSR2 = (uint8_t) COMP_CSR2_RESET_VALUE;
   \   000004 35005441              MOV       L:0x5441, #0x0
     52          
     53            /* Set COMP->CSR3 to reset value 0xC0 */
     54            COMP->CSR3 = (uint8_t) COMP_CSR3_RESET_VALUE;
   \   000008 35C05442              MOV       L:0x5442, #0xc0
     55          
     56            /* Set COMP->CSR4 to reset value 0x00 */
     57            COMP->CSR4 = (uint8_t) COMP_CSR4_RESET_VALUE;
   \   00000C 35005443              MOV       L:0x5443, #0x0
     58          
     59            /* Set COMP->CSR5 to reset value 0x00 */
     60            COMP->CSR5 = (uint8_t) COMP_CSR5_RESET_VALUE;
   \   000010 35005444              MOV       L:0x5444, #0x0
     61          }
   \   000014 81                    RET
     62          
     63          /**
     64            * @brief  Initializes the comparator inverting input, output and speed.
     65            * @note   This function configures only COMP2.
     66            * @param  COMP_InvertingInput : selects the comparator inverting input and can
     67            *         be any of the @ref COMP_InvertingInput_Typedef enumeration.
     68            * @param  COMP_OutputSelect : selects the comparator output and can be any of
     69            *         the @ref COMP_OutputSelect_Typedef enumeation.
     70            * @param  COMP_Speed selects the comparator speed and can be any of the
     71            *         @ref COMP_Speed_TypeDef enumeration.
     72            * @retval None.
     73            */

   \                                 In section .near_func.text, align 1
     74          void COMP_Init(COMP_InvertingInput_Typedef COMP_InvertingInput,
     75                         COMP_OutputSelect_Typedef COMP_OutputSelect, COMP_Speed_TypeDef COMP_Speed)
     76          {
   \                     COMP_Init:
   \   000000 B700                  LD        S:?b2, A
     77            /* Check the parameters */
     78            assert_param(IS_COMP_INVERTING_INPUT(COMP_InvertingInput));
     79            assert_param(IS_COMP_OUTPUT(COMP_OutputSelect));
     80            assert_param(IS_COMP_SPEED(COMP_Speed));
     81          
     82            /* Reset the INSEL[2:0] bits in CSR3 register */
     83            COMP->CSR3 &= (uint8_t) (~COMP_CSR3_INSEL);
   \   000002 C65442                LD        A, L:0x5442
   \   000005 A4C7                  AND       A, #0xc7
   \   000007 C75442                LD        L:0x5442, A
     84            /* Select the comparator inverting input */
     85            COMP->CSR3 |= (uint8_t) COMP_InvertingInput;
   \   00000A B600                  LD        A, S:?b2
   \   00000C CA5442                OR        A, L:0x5442
   \   00000F C75442                LD        L:0x5442, A
     86          
     87            /* Reset the OUTSEL[1:0] bits in CSR3 register */
     88            COMP->CSR3 &= (uint8_t) (~COMP_CSR3_OUTSEL);
   \   000012 C65442                LD        A, L:0x5442
   \   000015 A43F                  AND       A, #0x3f
   \   000017 C75442                LD        L:0x5442, A
     89            /* Redirect the comparator output */
     90            COMP->CSR3 |= (uint8_t) COMP_OutputSelect;
   \   00001A B600                  LD        A, S:?b0
   \   00001C CA5442                OR        A, L:0x5442
   \   00001F C75442                LD        L:0x5442, A
     91          
     92            /* Reset the comparator speed bit */
     93            COMP->CSR2 &= (uint8_t) (~COMP_CSR2_SPEED);
   \   000022 72155441              BRES      L:0x5441, #0x2
     94            /* Select the comparator speed */
     95            COMP->CSR2 |= (uint8_t) COMP_Speed;
   \   000026 B600                  LD        A, S:?b1
   \   000028 CA5441                OR        A, L:0x5441
   \   00002B C75441                LD        L:0x5441, A
     96          }
   \   00002E 81                    RET
     97          
     98          /**
     99            * @brief  Enables or disables connection between VREFINT and COMP1 inverting input.
    100            * @param  NewState new state of the VREFINT connection to COMP1 inverting input.
    101            *         This parameter can be ENABLE or DISABLE.
    102            * @retval None
    103            */

   \                                 In section .near_func.text, align 1
    104          void COMP_VrefintToCOMP1Connect(FunctionalState NewState)
    105          {
    106            /* Check the parameters */
    107            assert_param(IS_FUNCTIONAL_STATE(NewState));
    108          
    109            if (NewState != DISABLE)
   \                     COMP_VrefintToCOMP1Connect:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??COMP_VrefintToCOMP1Connect_0
    110            {
    111              /* Enable the comparator */
    112              COMP->CSR3 |= COMP_CSR3_VREFEN;
   \   000003 72145442              BSET      L:0x5442, #0x2
   \   000007 81                    RET
    113            }
    114            else
    115            {
    116              /* Disable the comparator */
    117              COMP->CSR3 &= (uint8_t)(~COMP_CSR3_VREFEN);
   \                     ??COMP_VrefintToCOMP1Connect_0:
   \   000008 72155442              BRES      L:0x5442, #0x2
    118            }
    119          }
   \   00000C 81                    RET
    120          
    121          /**
    122            * @brief  Configures the COMP edge detection.
    123            * @param  COMP_Selection : selects the comparator and can be any of the
    124            *         @ref COMP_Selection_TypeDef enum.
    125            * @param  COMP_Edge : can be any of the @ref COMP_Edge_TypeDef enumeration
    126            * @retval None.
    127            */

   \                                 In section .near_func.text, align 1
    128          void COMP_EdgeConfig(COMP_Selection_TypeDef COMP_Selection, COMP_Edge_TypeDef COMP_Edge)
    129          {
    130            /* Check the parameters */
    131            assert_param(IS_COMP_ALL_PERIPH(COMP_Selection));
    132            assert_param(IS_COMP_EDGE(COMP_Edge));
    133          
    134            /* Check if comparator 1 is selected */
    135            if (COMP_Selection == COMP_Selection_COMP1)
   \                     COMP_EdgeConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 2611                  JRNE      L:??COMP_EdgeConfig_0
    136            {
    137              /* Reset the comparator 1 edge control bits */
    138              COMP->CSR1 &= (uint8_t) (~COMP_CSR1_CMP1);
   \   000004 C65440                LD        A, L:0x5440
   \   000007 A4FC                  AND       A, #0xfc
   \   000009 C75440                LD        L:0x5440, A
    139          
    140              /* Select the edge detection of comparator 1 output */
    141              COMP->CSR1 |= (uint8_t) COMP_Edge;
   \   00000C B600                  LD        A, S:?b0
   \   00000E CA5440                OR        A, L:0x5440
   \   000011 C75440                LD        L:0x5440, A
   \   000014 81                    RET
    142            }
    143            /* The comparator 2 is selected */
    144            else
    145            {
    146              /* Reset the comparator 2 edge control bits */
    147              COMP->CSR2 &= (uint8_t) (~COMP_CSR2_CMP2);
   \                     ??COMP_EdgeConfig_0:
   \   000015 C65441                LD        A, L:0x5441
   \   000018 A4FC                  AND       A, #0xfc
   \   00001A C75441                LD        L:0x5441, A
    148          
    149              /* Select the edge detection of comparator 2 output */
    150              COMP->CSR2 |= (uint8_t) COMP_Edge;
   \   00001D B600                  LD        A, S:?b0
   \   00001F CA5441                OR        A, L:0x5441
   \   000022 C75441                LD        L:0x5441, A
    151            }
    152          }
   \   000025 81                    RET
    153          
    154          /**
    155            * @brief  Returns the output level of the comparator.
    156            * @param  COMP_Selection : selects the comparator and can be any of the
    157            *         @ref COMP_Selection_TypeDef enum.
    158            * @retval Returns the comparator output level and can be any of the
    159            *         @ref COMP_OutputLevel_TypeDef enum.
    160            */

   \                                 In section .near_func.text, align 1
    161          COMP_OutputLevel_TypeDef COMP_GetOutputLevel(COMP_Selection_TypeDef COMP_Selection)
    162          {
    163            uint8_t compout;
    164          
    165            /* Check the parameters */
    166            assert_param(IS_COMP_ALL_PERIPH(COMP_Selection));
    167          
    168            /* Check if Comparator 1 is selected */
    169            if (COMP_Selection == COMP_Selection_COMP1)
   \                     COMP_GetOutputLevel:
   \   000000 A101                  CP        A, #0x1
   \   000002 260A                  JRNE      L:??COMP_GetOutputLevel_0
    170            {
    171              /* Check if comparator 1 output level is high */
    172              if ((COMP->CSR1 & COMP_CSR1_CMP1OUT) != (uint8_t) RESET)
   \   000004 7207544003            BTJF      L:0x5440, #0x3, L:??COMP_GetOutputLevel_1
    173              {
    174                /* Get Comparator 1 output level */
    175                compout = (COMP_OutputLevel_TypeDef) COMP_OutputLevel_High;
   \   000009 A601                  LD        A, #0x1
   \   00000B 81                    RET
    176              }
    177              /* comparator 1 output level is low */
    178              else
    179              {
    180                /* Get Comparator 1 output level */
    181                compout = (COMP_OutputLevel_TypeDef) COMP_OutputLevel_Low;
   \                     ??COMP_GetOutputLevel_1:
   \   00000C 4F                    CLR       A
   \   00000D 81                    RET
    182              }
    183            }
    184            /* Comparator 2 is selected */
    185            else
    186            {
    187              /* Check if comparator 2 output level is high */
    188              if ((COMP->CSR2 & COMP_CSR2_CMP2OUT) != (uint8_t) RESET)
   \                     ??COMP_GetOutputLevel_0:
   \   00000E 7207544103            BTJF      L:0x5441, #0x3, L:??COMP_GetOutputLevel_2
    189              {
    190                /* Get Comparator output level */
    191                compout = (COMP_OutputLevel_TypeDef) COMP_OutputLevel_High;
   \   000013 A601                  LD        A, #0x1
   \   000015 81                    RET
    192              }
    193              /* comparator 2 output level is low */
    194              else
    195              {
    196                /* Get Comparator 2 output level */
    197                compout = (COMP_OutputLevel_TypeDef) COMP_OutputLevel_Low;
   \                     ??COMP_GetOutputLevel_2:
   \   000016 4F                    CLR       A
    198              }
    199            }
    200          
    201            /* Return the comparator output level */
    202            return (COMP_OutputLevel_TypeDef)(compout);
   \   000017 81                    RET
    203          }
    204          
    205          /**
    206            * @brief  Enables or disables the window mode.
    207            * @param  NewState new state of the window mode.
    208            *         This parameter can be ENABLE or DISABLE.
    209            * @retval None
    210            */

   \                                 In section .near_func.text, align 1
    211          void COMP_WindowCmd(FunctionalState NewState)
    212          {
    213            /* Check the parameters */
    214            assert_param(IS_FUNCTIONAL_STATE(NewState));
    215          
    216            if (NewState != DISABLE)
   \                     COMP_WindowCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??COMP_WindowCmd_0
    217            {
    218              /* Enable the window mode */
    219              COMP->CSR3 |= (uint8_t) COMP_CSR3_WNDWE;
   \   000003 72125442              BSET      L:0x5442, #0x1
   \   000007 81                    RET
    220            }
    221            else
    222            {
    223              /* Disable the window mode */
    224              COMP->CSR3 &= (uint8_t)(~COMP_CSR3_WNDWE);
   \                     ??COMP_WindowCmd_0:
   \   000008 72135442              BRES      L:0x5442, #0x1
    225            }
    226          }
   \   00000C 81                    RET
    227          
    228          /**
    229            * @brief  Enables or disables the interrupt generation when an event is detected.
    230            * @param  COMP_Selection : selects the comparator and can be any of the
    231            *         @ref COMP_Selection_TypeDef enum.
    232            * @param  NewState : new state of the COMPx peripheral.
    233            *         This parameter can be: ENABLE or DISABLE.
    234            * @retval None
    235            */

   \                                 In section .near_func.text, align 1
    236          void COMP_ITConfig(COMP_Selection_TypeDef COMP_Selection, FunctionalState NewState)
    237          {
    238            /* Check the parameters */
    239            assert_param(IS_COMP_ALL_PERIPH(COMP_Selection));
    240            assert_param(IS_FUNCTIONAL_STATE(NewState));
    241          
    242            /* Check if Comparator 1 is selected */
    243            if (COMP_Selection == COMP_Selection_COMP1)
   \                     COMP_ITConfig:
   \   000000 A101                  CP        A, #0x1
   \   000002 260E                  JRNE      L:??COMP_ITConfig_0
    244            {
    245              if (NewState != DISABLE)
   \   000004 3D00                  TNZ       S:?b0
   \   000006 2705                  JREQ      L:??COMP_ITConfig_1
    246              {
    247                /* Enable the COMP1 Interrupt source */
    248                COMP->CSR1 |= (uint8_t) COMP_CSR1_IE1;
   \   000008 721A5440              BSET      L:0x5440, #0x5
   \   00000C 81                    RET
    249              }
    250              else
    251              {
    252                /* Disable the COMP1 Interrupt source */
    253                COMP->CSR1 &= (uint8_t)(~COMP_CSR1_IE1);
   \                     ??COMP_ITConfig_1:
   \   00000D 721B5440              BRES      L:0x5440, #0x5
   \   000011 81                    RET
    254              }
    255            }
    256            else /* Comparator 2 is selected */
    257            {
    258              if (NewState != DISABLE)
   \                     ??COMP_ITConfig_0:
   \   000012 3D00                  TNZ       S:?b0
   \   000014 2705                  JREQ      L:??COMP_ITConfig_2
    259              {
    260                /* Enable the COMP2 Interrupt source */
    261                COMP->CSR2 |= (uint8_t) COMP_CSR2_IE2;
   \   000016 721A5441              BSET      L:0x5441, #0x5
   \   00001A 81                    RET
    262              }
    263              else
    264              {
    265                /* Disable the COMP2 Interrupt source */
    266                COMP->CSR2 &= (uint8_t)(~COMP_CSR2_IE2);
   \                     ??COMP_ITConfig_2:
   \   00001B 721B5441              BRES      L:0x5441, #0x5
    267              }
    268            }
    269          }
   \   00001F 81                    RET
    270          
    271          /**
    272            * @brief  Enables or disables trigger on the specified input/output group.
    273            * @param  COMP_TriggerGroup : specifies the input/output group
    274            *         This parameter can be a value @ref COMP_TriggerGroup_TypeDef
    275            * @param  COMP_TriggerPin : specifies the pin(s) within the input/output group
    276            *         This parameter can be a value @ref COMP_TriggerPin_TypeDef
    277            * @param  NewState : enable or disable the trigger on the selected pin(s)
    278            *         This parameter can be: ENABLE or DISABLE.
    279            * @retval None
    280            */

   \                                 In section .near_func.text, align 1
    281          void COMP_TriggerConfig(COMP_TriggerGroup_TypeDef COMP_TriggerGroup,
    282                                  COMP_TriggerPin_TypeDef COMP_TriggerPin,
    283                                  FunctionalState NewState)
    284          {
    285            /* Check the parameters */
    286            assert_param(IS_COMP_TRIGGERGROUP(COMP_TriggerGroup));
    287            assert_param(IS_COMP_TRIGGERPIN(COMP_TriggerPin));
    288          
    289            switch (COMP_TriggerGroup)
   \                     COMP_TriggerConfig:
   \   000000 4A                    DEC       A
   \   000001 270A                  JREQ      L:??COMP_TriggerConfig_0
   \   000003 4A                    DEC       A
   \   000004 271F                  JREQ      L:??COMP_TriggerConfig_1
   \   000006 4A                    DEC       A
   \   000007 2739                  JREQ      L:??COMP_TriggerConfig_2
   \   000009 4A                    DEC       A
   \   00000A 274E                  JREQ      L:??COMP_TriggerConfig_3
   \   00000C 81                    RET
    290            {
    291              case COMP_TriggerGroup_InvertingInput:
    292          
    293                if (NewState != DISABLE)
   \                     ??COMP_TriggerConfig_0:
   \   00000D 3D00                  TNZ       S:?b1
   \   00000F 270B                  JREQ      L:??COMP_TriggerConfig_4
    294                {
    295                  COMP->CSR4 &= (uint8_t) ~COMP_TriggerPin;
   \   000011 3300                  CPL       S:?b0
   \   000013 B600                  LD        A, S:?b0
   \   000015 C45443                AND       A, L:0x5443
   \   000018 C75443                LD        L:0x5443, A
   \   00001B 81                    RET
    296                }
    297                else
    298                {
    299                  COMP->CSR4 |= (uint8_t) COMP_TriggerPin;
   \                     ??COMP_TriggerConfig_4:
   \   00001C B600                  LD        A, S:?b0
   \   00001E CA5443                OR        A, L:0x5443
   \   000021 C75443                LD        L:0x5443, A
    300                }
    301                break;
   \   000024 81                    RET
    302          
    303              case COMP_TriggerGroup_NonInvertingInput:
    304                if (NewState != DISABLE)
   \                     ??COMP_TriggerConfig_1:
   \   000025 3D00                  TNZ       S:?b1
   \   000027 270D                  JREQ      L:??COMP_TriggerConfig_5
    305                {
    306                  COMP->CSR4 &= (uint8_t) ~((uint8_t)(COMP_TriggerPin << 3));
   \   000029 B600                  LD        A, S:?b0
   \   00002B 48                    SLL       A
   \   00002C 48                    SLL       A
   \   00002D 48                    SLL       A
   \   00002E 43                    CPL       A
   \   00002F C45443                AND       A, L:0x5443
   \   000032 C75443                LD        L:0x5443, A
   \   000035 81                    RET
    307                }
    308                else
    309                {
    310                  COMP->CSR4 |= (uint8_t) (COMP_TriggerPin << 3);
   \                     ??COMP_TriggerConfig_5:
   \   000036 B600                  LD        A, S:?b0
   \   000038 48                    SLL       A
   \   000039 48                    SLL       A
   \   00003A 48                    SLL       A
   \   00003B CA5443                OR        A, L:0x5443
   \   00003E C75443                LD        L:0x5443, A
    311                }
    312                break;
   \   000041 81                    RET
    313          
    314              case COMP_TriggerGroup_VREFINTOutput:
    315                if (NewState != DISABLE)
   \                     ??COMP_TriggerConfig_2:
   \   000042 3D00                  TNZ       S:?b1
   \   000044 270B                  JREQ      L:??COMP_TriggerConfig_6
    316                {
    317                  COMP->CSR5 &= (uint8_t) ~COMP_TriggerPin;
   \   000046 3300                  CPL       S:?b0
   \   000048 B600                  LD        A, S:?b0
   \   00004A C45444                AND       A, L:0x5444
   \   00004D C75444                LD        L:0x5444, A
   \   000050 81                    RET
    318                }
    319                else
    320                {
    321                  COMP->CSR5 |= (uint8_t) COMP_TriggerPin;
   \                     ??COMP_TriggerConfig_6:
   \   000051 B600                  LD        A, S:?b0
   \   000053 CA5444                OR        A, L:0x5444
   \   000056 C75444                LD        L:0x5444, A
    322                }
    323                break;
   \   000059 81                    RET
    324          
    325              case COMP_TriggerGroup_DACOutput:
    326                if (NewState != DISABLE)
   \                     ??COMP_TriggerConfig_3:
   \   00005A 3D00                  TNZ       S:?b1
   \   00005C 270D                  JREQ      L:??COMP_TriggerConfig_7
    327                {
    328                  COMP->CSR5 &= (uint8_t) ~((uint8_t)(COMP_TriggerPin << 3));
   \   00005E B600                  LD        A, S:?b0
   \   000060 48                    SLL       A
   \   000061 48                    SLL       A
   \   000062 48                    SLL       A
   \   000063 43                    CPL       A
   \   000064 C45444                AND       A, L:0x5444
   \   000067 C75444                LD        L:0x5444, A
   \   00006A 81                    RET
    329                }
    330                else
    331                {
    332                  COMP->CSR5 |= (uint8_t) (COMP_TriggerPin << 3);
   \                     ??COMP_TriggerConfig_7:
   \   00006B B600                  LD        A, S:?b0
   \   00006D 48                    SLL       A
   \   00006E 48                    SLL       A
   \   00006F 48                    SLL       A
   \   000070 CA5444                OR        A, L:0x5444
   \   000073 C75444                LD        L:0x5444, A
    333                }
    334                break;
    335          
    336              default:
    337                break;
    338            }
    339          }
   \   000076 81                    RET
    340          
    341          /**
    342            * @brief  Enables or disables the output of the internal reference voltage.
    343            * @param  NewState : new state of the Vrefint output.
    344            *         This parameter can be: ENABLE or DISABLE.
    345            * @retval None
    346            */

   \                                 In section .near_func.text, align 1
    347          void COMP_VrefintOutputCmd(FunctionalState NewState)
    348          {
    349            /* Check the parameters */
    350            assert_param(IS_FUNCTIONAL_STATE(NewState));
    351          
    352            if (NewState != DISABLE)
   \                     COMP_VrefintOutputCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??COMP_VrefintOutputCmd_0
    353            {
    354              /* Enable the output of internal reference voltage */
    355              COMP->CSR3 |= (uint8_t) COMP_CSR3_VREFOUTEN;
   \   000003 72105442              BSET      L:0x5442, #0x0
   \   000007 81                    RET
    356            }
    357            else
    358            {
    359              /* Disable the output of internal reference voltage */
    360              COMP->CSR3 &= (uint8_t) (~COMP_CSR3_VREFOUTEN);
   \                     ??COMP_VrefintOutputCmd_0:
   \   000008 72115442              BRES      L:0x5442, #0x0
    361            }
    362          }
   \   00000C 81                    RET
    363          
    364          /**
    365            * @brief  Enables or disables the schmitt trigger.
    366            * @param  NewState : new state of the schmitt trigger.
    367            *         This parameter can be: ENABLE or DISABLE.
    368            * @retval None
    369            */

   \                                 In section .near_func.text, align 1
    370          void COMP_SchmittTriggerCmd(FunctionalState NewState)
    371          {
    372            /* Check the parameters */
    373            assert_param(IS_FUNCTIONAL_STATE(NewState));
    374          
    375            if (NewState != DISABLE)
   \                     COMP_SchmittTriggerCmd:
   \   000000 4D                    TNZ       A
   \   000001 2705                  JREQ      L:??COMP_SchmittTriggerCmd_0
    376            {
    377              /* Enable Schmitt trigger on Input Output switches Channels */
    378              COMP->CSR1 |= (uint8_t) COMP_CSR1_STE;
   \   000003 72145440              BSET      L:0x5440, #0x2
   \   000007 81                    RET
    379            }
    380            else
    381            {
    382              /* Enable Schmitt trigger on Input Output switches Channels */
    383              COMP->CSR1 &= (uint8_t) (~COMP_CSR1_STE);
   \                     ??COMP_SchmittTriggerCmd_0:
   \   000008 72155440              BRES      L:0x5440, #0x2
    384            }
    385          }
   \   00000C 81                    RET
    386          
    387          /**
    388            * @brief  Checks whether the comparator flag is set or not.
    389            * @param  COMP_Selection : selects the comparator and can be any of the
    390            *         @ref COMP_Selection_TypeDef enum.
    391            * @retval The new state of COMPx event flag (SET or RESET).
    392            */

   \                                 In section .near_func.text, align 1
    393          FlagStatus COMP_GetFlagStatus(COMP_Selection_TypeDef COMP_Selection)
    394          {
    395            FlagStatus bitstatus = RESET;
   \                     COMP_GetFlagStatus:
   \   000000 3F00                  CLR       S:?b0
    396          
    397            /* Check the parameters */
    398            assert_param(IS_COMP_ALL_PERIPH(COMP_Selection));
    399          
    400            /* Check if COMP1 is selected */
    401            if (COMP_Selection == COMP_Selection_COMP1)
   \   000002 A101                  CP        A, #0x1
   \   000004 260F                  JRNE      L:??COMP_GetFlagStatus_0
    402            {
    403              if ((COMP->CSR1 & COMP_CSR1_EF1) != (uint8_t) RESET)
   \   000006 7209544006            BTJF      L:0x5440, #0x4, L:??COMP_GetFlagStatus_1
    404              {
    405                /* The comparator 1 event flag is set */
    406                bitstatus = SET;
   \   00000B 35010000              MOV       S:?b0, #0x1
   \   00000F 2011                  JRA       L:??COMP_GetFlagStatus_2
    407              }
    408              else
    409              {
    410                /* The comparator 1 event flag is reset */
    411                bitstatus = RESET;
   \                     ??COMP_GetFlagStatus_1:
   \   000011 3F00                  CLR       S:?b0
   \   000013 200D                  JRA       L:??COMP_GetFlagStatus_2
    412              }
    413            }
    414            else   /* COMP2 is selected */
    415            {
    416              if ((COMP->CSR2 & COMP_CSR2_EF2) != (uint8_t) RESET)
   \                     ??COMP_GetFlagStatus_0:
   \   000015 7209544106            BTJF      L:0x5441, #0x4, L:??COMP_GetFlagStatus_3
    417              {
    418                /* The comparator 2 event flag is set */
    419                bitstatus = SET;
   \   00001A 35010000              MOV       S:?b0, #0x1
   \   00001E 2002                  JRA       L:??COMP_GetFlagStatus_2
    420              }
    421              else
    422              {
    423                /* The comparator 2 event flag is reset */
    424                bitstatus = RESET;
   \                     ??COMP_GetFlagStatus_3:
   \   000020 3F00                  CLR       S:?b0
    425              }
    426            }
    427          
    428            /* return the comparator event flag status */
    429            return (FlagStatus)(bitstatus);
   \                     ??COMP_GetFlagStatus_2:
   \   000022 B600                  LD        A, S:?b0
   \   000024 81                    RET
    430          }
    431          
    432          /**
    433            * @brief  Clears the comparator’s pending flag.
    434            * @param  COMP_Selection : selects the comparator and can be any of the
    435            *         @ref COMP_Selection_TypeDef enum.
    436            * @retval None.
    437            */

   \                                 In section .near_func.text, align 1
    438          void COMP_ClearFlag(COMP_Selection_TypeDef COMP_Selection)
    439          {
    440            /* Check the parameters */
    441            assert_param(IS_COMP_ALL_PERIPH(COMP_Selection));
    442          
    443            if (COMP_Selection == COMP_Selection_COMP1)
   \                     COMP_ClearFlag:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??COMP_ClearFlag_0
    444            {
    445              /* Clear the flag EF1 (rc_w0) clear this bit by writing 0. */
    446              COMP->CSR1 &= (uint8_t) (~COMP_CSR1_EF1);
   \   000004 72195440              BRES      L:0x5440, #0x4
   \   000008 81                    RET
    447            }
    448            else
    449            {
    450              /* Clear the flag EF2 (rc_w0) clear this bit by writing 0. */
    451              COMP->CSR2 &= (uint8_t) (~COMP_CSR2_EF2);
   \                     ??COMP_ClearFlag_0:
   \   000009 72195441              BRES      L:0x5441, #0x4
    452            }
    453          }
   \   00000D 81                    RET
    454          
    455          /**
    456            * @brief  Checks whether the comparator interrupt has occurred or not.
    457            * @param  COMP_Selection : selects the comparator and can be any of the
    458            *         @ref COMP_Selection_TypeDef enum.
    459            * @retval ITStatus : The state of the COMPx event flag (SET or RESET).
    460            */

   \                                 In section .near_func.text, align 1
    461          ITStatus COMP_GetITStatus(COMP_Selection_TypeDef COMP_Selection)
    462          {
    463            ITStatus bitstatus = RESET;
   \                     COMP_GetITStatus:
   \   000000 3F00                  CLR       S:?b0
    464            uint8_t itstatus = 0x00, itenable = 0x00;
   \   000002 3F00                  CLR       S:?b2
   \   000004 3F00                  CLR       S:?b1
    465          
    466            /* Check the parameters */
    467            assert_param(IS_COMP_ALL_PERIPH(COMP_Selection));
    468          
    469            if (COMP_Selection == COMP_Selection_COMP1)
   \   000006 A101                  CP        A, #0x1
   \   000008 2620                  JRNE      L:??COMP_GetITStatus_0
    470            {
    471              /* Get the EF1 comparator event falg status */
    472              itstatus = (uint8_t) (COMP->CSR1 & COMP_CSR1_EF1);
   \   00000A C65440                LD        A, L:0x5440
   \   00000D A410                  AND       A, #0x10
   \   00000F B700                  LD        S:?b2, A
    473          
    474              /* Get the IE1 interrupt enable bit status */
    475              itenable = (uint8_t) (COMP->CSR1 & COMP_CSR1_IE1);
   \   000011 C65440                LD        A, L:0x5440
   \   000014 A420                  AND       A, #0x20
   \   000016 B700                  LD        S:?b1, A
    476          
    477              if ((itstatus != (uint8_t) RESET) && (itenable != (uint8_t) RESET))
   \   000018 3D00                  TNZ       S:?b2
   \   00001A 270A                  JREQ      L:??COMP_GetITStatus_1
   \   00001C 3D00                  TNZ       S:?b1
   \   00001E 2706                  JREQ      L:??COMP_GetITStatus_1
    478              {
    479                /* the EF1 and IE1 are set */
    480                bitstatus = SET;
   \   000020 35010000              MOV       S:?b0, #0x1
   \   000024 2022                  JRA       L:??COMP_GetITStatus_2
    481              }
    482              else
    483              {
    484                /* the EF1 or IE1 is reset */
    485                bitstatus = RESET;
   \                     ??COMP_GetITStatus_1:
   \   000026 3F00                  CLR       S:?b0
   \   000028 201E                  JRA       L:??COMP_GetITStatus_2
    486              }
    487            }
    488            else
    489            {
    490              /* Get the EF2 comparator event falg value */
    491              itstatus = (uint8_t) (COMP->CSR2 & COMP_CSR2_EF2);
   \                     ??COMP_GetITStatus_0:
   \   00002A C65441                LD        A, L:0x5441
   \   00002D A410                  AND       A, #0x10
   \   00002F B700                  LD        S:?b2, A
    492          
    493              /* Get the IE2 interrupt enable bit value */
    494              itenable = (uint8_t) (COMP->CSR2 & COMP_CSR2_IE2);
   \   000031 C65441                LD        A, L:0x5441
   \   000034 A420                  AND       A, #0x20
   \   000036 B700                  LD        S:?b1, A
    495          
    496              if ((itstatus != (uint8_t)RESET) && (itenable != (uint8_t)RESET))
   \   000038 3D00                  TNZ       S:?b2
   \   00003A 270A                  JREQ      L:??COMP_GetITStatus_3
   \   00003C 3D00                  TNZ       S:?b1
   \   00003E 2706                  JREQ      L:??COMP_GetITStatus_3
    497              {
    498                /* The EF2 and IE2 are set */
    499                bitstatus = SET;
   \   000040 35010000              MOV       S:?b0, #0x1
   \   000044 2002                  JRA       L:??COMP_GetITStatus_2
    500              }
    501              else
    502              {
    503                /* The EF2 or IE2 is reset */
    504                bitstatus = RESET;
   \                     ??COMP_GetITStatus_3:
   \   000046 3F00                  CLR       S:?b0
    505              }
    506            }
    507          
    508            /* Return the COMP interrupt status */
    509            return (ITStatus) bitstatus;
   \                     ??COMP_GetITStatus_2:
   \   000048 B600                  LD        A, S:?b0
   \   00004A 81                    RET
    510          }
    511          
    512          /**
    513            * @brief  Clears the interrupt pending bits of the comparator.
    514            * @param  COMP_Selection : selects the comparator and can be any of the
    515            *         @ref COMP_Selection_TypeDef enum.
    516            * @retval None
    517            */

   \                                 In section .near_func.text, align 1
    518          void COMP_ClearITPendingBit(COMP_Selection_TypeDef COMP_Selection)
    519          {
    520            /* Check the parameters */
    521            assert_param(IS_COMP_ALL_PERIPH(COMP_Selection));
    522          
    523            if (COMP_Selection == COMP_Selection_COMP1)
   \                     COMP_ClearITPendingBit:
   \   000000 A101                  CP        A, #0x1
   \   000002 2605                  JRNE      L:??COMP_ClearITPendingBit_0
    524            {
    525              /* Clear the flag EF1 (rc_w0) clear this bit by writing 0. */
    526              COMP->CSR1 &= (uint8_t) (~COMP_CSR1_EF1);
   \   000004 72195440              BRES      L:0x5440, #0x4
   \   000008 81                    RET
    527            }
    528            else
    529            {
    530              /* Clear the flag EF2 (rc_w0) clear this bit by writing 0. */
    531              COMP->CSR2 &= (uint8_t) (~COMP_CSR2_EF2);
   \                     ??COMP_ClearITPendingBit_0:
   \   000009 72195441              BRES      L:0x5441, #0x4
    532            }
    533          }
   \   00000D 81                    RET
    534          
    535          /**
    536            * @}
    537            */
    538          
    539          /**
    540            * @}
    541            */
    542          
    543          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label             Bytes
     --------------             -----
     COMP_DeInit                  21
     COMP_Init                    47
     COMP_VrefintToCOMP1Connect   13
     COMP_EdgeConfig              38
     COMP_GetOutputLevel          24
     COMP_WindowCmd               13
     COMP_ITConfig                32
     COMP_TriggerConfig          119
     COMP_VrefintOutputCmd        13
     COMP_SchmittTriggerCmd       13
     COMP_GetFlagStatus           37
     COMP_ClearFlag               14
     COMP_GetITStatus             75
     COMP_ClearITPendingBit       14

 
 473 bytes in section .near_func.text
 
 473 bytes of CODE memory

Errors: none
Warnings: none
