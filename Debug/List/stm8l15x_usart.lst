###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.1.50036 for STM8             12/Mar/2014  19:56:53 #
# Copyright 2010-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_u #
#                    sart.c                                                   #
#    Command line =  "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_u #
#                    sart.c" -e -Ol --no_cse --no_unroll --no_inline          #
#                    --no_code_motion --no_tbaa --no_cross_call --debug       #
#                    --code_model small --data_model medium -o                #
#                    "F:\Skydrive\Final Design\Servo Motor STM8L\Debug\Obj\"  #
#                    --dlib_config "D:\IAR Systems\Embedded Workbench         #
#                    6.0\stm8\LIB\dlstm8smn.h" -D STM8L15X_MD -lCN            #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Debug\List\" --diag_suppress Pe177,Pe550 -I        #
#                    "F:\Skydrive\Final Design\Servo Motor                    #
#                    STM8L\Project\Discover\inc\" -I "F:\Skydrive\Final       #
#                    Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Dr #
#                    iver\inc\" --vregs 16                                    #
#    List file    =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\List\stm8l15x_usart.lst                      #
#    Object file  =  F:\Skydrive\Final Design\Servo Motor                     #
#                    STM8L\Debug\Obj\stm8l15x_usart.o                         #
#                                                                             #
#                                                                             #
###############################################################################

F:\Skydrive\Final Design\Servo Motor STM8L\Libraries\STM8L15x_StdPeriph_Driver\src\stm8l15x_usart.c
      1          /**
      2            ********************************************************************************
      3            * @file    stm8l15x_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the USART firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_usart.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          /* Public functions ----------------------------------------------------------*/
     35          
     36          /** @}
     37            * @addtogroup USART_Public_Functions
     38            * @{
     39            */
     40          
     41          /**
     42            * @brief   Deinitializes the USART peripheral.
     43            * @param  USARTx : where x can be 1, 2 or 3 to select the specified USART peripheral.
     44            * @retval None
     45            */

   \                                 In section .near_func.text, align 1
     46          void USART_DeInit(USART_TypeDef* USARTx)
     47          {
     48          
     49            /* Clear the Idle Line Detected bit in the status rerister by a read
     50                to the USART_SR register followed by a Read to the USART_DR register */
     51            (void) USARTx->SR;
   \                     USART_DeInit:
   \   000000 F6                    LD        A, (X)
   \   000001 B700                  LD        S:?b1, A
     52            (void) USARTx->DR;
   \   000003 9093                  LDW       Y, X
   \   000005 905C                  INCW      Y
   \   000007 90F6                  LD        A, (Y)
   \   000009 B700                  LD        S:?b0, A
     53          
     54            USARTx->BRR2 = USART_BRR2_RESET_VALUE;  /* Set USART_BRR2 to reset value 0x00 */
   \   00000B 9093                  LDW       Y, X
   \   00000D 72A90003              ADDW      Y, #0x3
   \   000011 4F                    CLR       A
   \   000012 90F7                  LD        (Y), A
     55            USARTx->BRR1 = USART_BRR1_RESET_VALUE;  /* Set USART_BRR1 to reset value 0x00 */
   \   000014 9093                  LDW       Y, X
   \   000016 72A90002              ADDW      Y, #0x2
   \   00001A 4F                    CLR       A
   \   00001B 90F7                  LD        (Y), A
     56          
     57            USARTx->CR1 = USART_CR1_RESET_VALUE;  /* Set USART_CR1 to reset value 0x00 */
   \   00001D 9093                  LDW       Y, X
   \   00001F 72A90004              ADDW      Y, #0x4
   \   000023 4F                    CLR       A
   \   000024 90F7                  LD        (Y), A
     58            USARTx->CR2 = USART_CR2_RESET_VALUE;  /* Set USART_CR2 to reset value 0x00 */
   \   000026 9093                  LDW       Y, X
   \   000028 72A90005              ADDW      Y, #0x5
   \   00002C 4F                    CLR       A
   \   00002D 90F7                  LD        (Y), A
     59            USARTx->CR3 = USART_CR3_RESET_VALUE;  /* Set USART_CR3 to reset value 0x00 */
   \   00002F 9093                  LDW       Y, X
   \   000031 72A90006              ADDW      Y, #0x6
   \   000035 4F                    CLR       A
   \   000036 90F7                  LD        (Y), A
     60            USARTx->CR4 = USART_CR4_RESET_VALUE;  /* Set USART_CR4 to reset value 0x00 */
   \   000038 1C0007                ADDW      X, #0x7
   \   00003B 4F                    CLR       A
   \   00003C F7                    LD        (X), A
     61          }
   \   00003D 81                    RET
     62          
     63          /**
     64            * @brief  Initializes the USART according to the specified parameters.
     65            * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
     66            *         correct I/O Port register according the product package and line
     67            *         configuration
     68            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
     69            * @param  BaudRate : The baudrate.
     70            * @param  USART_WordLength : This parameter can be any of the
     71            *         @ref USART_WordLength_TypeDef enumeration.
     72            * @param  USART_StopBits : This parameter can be any of the
     73            *         @ref USART_StopBits_TypeDef enumeration.
     74            * @param  USART_Parity : This parameter can be any of the
     75            *         @ref USART_Parity_TypeDef enumeration.
     76            * @param  USART_Mode : This parameter can be any of the @ref USART_Mode_TypeDef values
     77            * @retval None
     78            */

   \                                 In section .near_func.text, align 1
     79          void USART_Init(USART_TypeDef* USARTx, uint32_t BaudRate, USART_WordLength_TypeDef
     80                          USART_WordLength, USART_StopBits_TypeDef USART_StopBits,
     81                          USART_Parity_TypeDef USART_Parity,  USART_Mode_TypeDef USART_Mode)
     82          {
   \                     USART_Init:
   \   000000 CD0000                CALL      L:?push_l2
   \   000003 CD0000                CALL      L:?push_l3
   \   000006 5204                  SUB       SP, #0x4
   \   000008 BF00                  LDW       S:?w4, X
   \   00000A CD0000                CALL      L:?mov_l3_l0
   \   00000D B700                  LD        S:?b0, A
   \   00000F 450000                MOV       S:?b10, S:?b6
     83            uint32_t BaudRate_Mantissa = 0;
   \   000012 AE0000                LDW       X, #0x0
   \   000015 1F01                  LDW       (0x1,SP), X
   \   000017 AE0000                LDW       X, #0x0
   \   00001A 1F03                  LDW       (0x3,SP), X
     84          
     85            /* Check the parameters */
     86            assert_param(IS_USART_BAUDRATE(BaudRate));
     87          
     88            assert_param(IS_USART_WORDLENGTH(USART_WordLength));
     89          
     90            assert_param(IS_USART_STOPBITS(USART_StopBits));
     91          
     92            assert_param(IS_USART_PARITY(USART_Parity));
     93          
     94            assert_param(IS_USART_MODE(USART_Mode));
     95          
     96            /* Clear the word length and Parity Control bits */
     97            USARTx->CR1 &= (uint8_t)(~(USART_CR1_PCEN | USART_CR1_PS | USART_CR1_M));
   \   00001C BE00                  LDW       X, S:?w4
   \   00001E 1C0004                ADDW      X, #0x4
   \   000021 F6                    LD        A, (X)
   \   000022 A4E9                  AND       A, #0xe9
   \   000024 BE00                  LDW       X, S:?w4
   \   000026 1C0004                ADDW      X, #0x4
   \   000029 F7                    LD        (X), A
     98            /* Set the word length bit according to USART_WordLength value */
     99            /* Set the Parity Control bit to USART_Parity value */
    100            USARTx->CR1 |= (uint8_t)((uint8_t)USART_WordLength | (uint8_t)USART_Parity);
   \   00002A B600                  LD        A, S:?b5
   \   00002C BA00                  OR        A, S:?b0
   \   00002E BE00                  LDW       X, S:?w4
   \   000030 1C0004                ADDW      X, #0x4
   \   000033 FA                    OR        A, (X)
   \   000034 BE00                  LDW       X, S:?w4
   \   000036 1C0004                ADDW      X, #0x4
   \   000039 F7                    LD        (X), A
    101          
    102            /* Clear the STOP bits */
    103            USARTx->CR3 &= (uint8_t)(~USART_CR3_STOP);
   \   00003A BE00                  LDW       X, S:?w4
   \   00003C 1C0006                ADDW      X, #0x6
   \   00003F F6                    LD        A, (X)
   \   000040 A4CF                  AND       A, #0xcf
   \   000042 BE00                  LDW       X, S:?w4
   \   000044 1C0006                ADDW      X, #0x6
   \   000047 F7                    LD        (X), A
    104            /* Set the STOP bits number according to USART_StopBits value */
    105            USARTx->CR3 |= (uint8_t)USART_StopBits;
   \   000048 BE00                  LDW       X, S:?w4
   \   00004A 1C0006                ADDW      X, #0x6
   \   00004D B600                  LD        A, S:?b4
   \   00004F FA                    OR        A, (X)
   \   000050 BE00                  LDW       X, S:?w4
   \   000052 1C0006                ADDW      X, #0x6
   \   000055 F7                    LD        (X), A
    106          
    107            /* Clear the LSB mantissa of USARTDIV */
    108            USARTx->BRR1 &= (uint8_t)(~USART_BRR1_DIVM);
   \   000056 BE00                  LDW       X, S:?w4
   \   000058 1C0002                ADDW      X, #0x2
   \   00005B F6                    LD        A, (X)
   \   00005C B700                  LD        S:?b11, A
   \   00005E BE00                  LDW       X, S:?w4
   \   000060 1C0002                ADDW      X, #0x2
   \   000063 4F                    CLR       A
   \   000064 F7                    LD        (X), A
    109            /* Clear the MSB mantissa of USARTDIV */
    110            USARTx->BRR2 &= (uint8_t)(~USART_BRR2_DIVM);
   \   000065 BE00                  LDW       X, S:?w4
   \   000067 1C0003                ADDW      X, #0x3
   \   00006A F6                    LD        A, (X)
   \   00006B A40F                  AND       A, #0xf
   \   00006D BE00                  LDW       X, S:?w4
   \   00006F 1C0003                ADDW      X, #0x3
   \   000072 F7                    LD        (X), A
    111            /* Clear the Fraction bits of USARTDIV */
    112            USARTx->BRR2 &= (uint8_t)(~USART_BRR2_DIVF);
   \   000073 BE00                  LDW       X, S:?w4
   \   000075 1C0003                ADDW      X, #0x3
   \   000078 F6                    LD        A, (X)
   \   000079 A4F0                  AND       A, #0xf0
   \   00007B BE00                  LDW       X, S:?w4
   \   00007D 1C0003                ADDW      X, #0x3
   \   000080 F7                    LD        (X), A
    113          
    114            BaudRate_Mantissa  = (uint32_t)(CLK_GetClockFreq() / BaudRate );
   \   000081 CD0000                CALL      L:CLK_GetClockFreq
   \   000084 CD0000                CALL      L:?mov_l1_l3
   \   000087 CD0000                CALL      L:?udiv32_l0_l0_l1
   \   00008A CD0000                CALL      L:?load32_dbsp_l0
   \   00008D 01                    DC8       0x1
    115            /* Set the fraction of USARTDIV */
    116            USARTx->BRR2 = (uint8_t)((BaudRate_Mantissa >> (uint8_t)8) & (uint8_t)0xF0);
   \   00008E 1E03                  LDW       X, (0x3,SP)
   \   000090 4F                    CLR       A
   \   000091 01                    RRWA      X, A
   \   000092 9F                    LD        A, XL
   \   000093 A4F0                  AND       A, #0xf0
   \   000095 BE00                  LDW       X, S:?w4
   \   000097 1C0003                ADDW      X, #0x3
   \   00009A F7                    LD        (X), A
    117            /* Set the MSB mantissa of USARTDIV */
    118            USARTx->BRR2 |= (uint8_t)(BaudRate_Mantissa & (uint8_t)0x0F);
   \   00009B 1E03                  LDW       X, (0x3,SP)
   \   00009D 9F                    LD        A, XL
   \   00009E A40F                  AND       A, #0xf
   \   0000A0 BE00                  LDW       X, S:?w4
   \   0000A2 1C0003                ADDW      X, #0x3
   \   0000A5 FA                    OR        A, (X)
   \   0000A6 BE00                  LDW       X, S:?w4
   \   0000A8 1C0003                ADDW      X, #0x3
   \   0000AB F7                    LD        (X), A
    119            /* Set the LSB mantissa of USARTDIV */
    120            USARTx->BRR1 = (uint8_t)(BaudRate_Mantissa >> (uint8_t)4);
   \   0000AC 1E03                  LDW       X, (0x3,SP)
   \   0000AE CD0000                CALL      L:?srl16_x_x_4
   \   0000B1 9F                    LD        A, XL
   \   0000B2 BE00                  LDW       X, S:?w4
   \   0000B4 1C0002                ADDW      X, #0x2
   \   0000B7 F7                    LD        (X), A
    121          
    122            /* Disable the Transmitter and Receiver */
    123            USARTx->CR2 &= (uint8_t)~(USART_CR2_TEN | USART_CR2_REN);
   \   0000B8 BE00                  LDW       X, S:?w4
   \   0000BA 1C0005                ADDW      X, #0x5
   \   0000BD F6                    LD        A, (X)
   \   0000BE A4F3                  AND       A, #0xf3
   \   0000C0 BE00                  LDW       X, S:?w4
   \   0000C2 1C0005                ADDW      X, #0x5
   \   0000C5 F7                    LD        (X), A
    124            /* Set TEN and REN bits according to USART_Mode value */
    125            USARTx->CR2 |= (uint8_t)USART_Mode;
   \   0000C6 BE00                  LDW       X, S:?w4
   \   0000C8 1C0005                ADDW      X, #0x5
   \   0000CB B600                  LD        A, S:?b10
   \   0000CD FA                    OR        A, (X)
   \   0000CE BE00                  LDW       X, S:?w4
   \   0000D0 1C0005                ADDW      X, #0x5
   \   0000D3 F7                    LD        (X), A
    126          }
   \   0000D4 5B04                  ADD       SP, #0x4
   \   0000D6 CC0000                JP        L:?epilogue_l2_l3
    127          
    128          /**
    129            * @brief  Initializes the USART Clock according to the specified parameters.
    130            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    131            * @param  USART_Clock : This parameter can be any of the @ref USART_Clock_TypeDef
    132            *         enumeration.
    133            * @param  USART_CPOL : This parameter can be any of the @ref USART_CPOL_TypeDef
    134            *         enumeration.
    135            * @param  USART_CPHA : This parameter can be any of the @ref USART_CPHA_TypeDef
    136            *         enumeration.
    137            * @param  USART_LastBit : This parameter can be any of the @ref USART_LastBit_TypeDef
    138            *         enumeration.
    139            * @retval None
    140            */
    141          

   \                                 In section .near_func.text, align 1
    142          void USART_ClockInit(USART_TypeDef* USARTx, USART_Clock_TypeDef USART_Clock,
    143                               USART_CPOL_TypeDef USART_CPOL, USART_CPHA_TypeDef USART_CPHA,
    144                               USART_LastBit_TypeDef USART_LastBit)
    145          {
   \                     USART_ClockInit:
   \   000000 B700                  LD        S:?b3, A
    146            /* Check the parameters */
    147            assert_param(IS_USART_CLOCK(USART_Clock));
    148            assert_param(IS_USART_CPOL(USART_CPOL));
    149            assert_param(IS_USART_CPHA(USART_CPHA));
    150            assert_param(IS_USART_LASTBIT(USART_LastBit));
    151          
    152            /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    153            USARTx->CR3 &= (uint8_t)~(USART_CR3_CPOL | USART_CR3_CPHA | USART_CR3_LBCL);
   \   000002 9093                  LDW       Y, X
   \   000004 72A90006              ADDW      Y, #0x6
   \   000008 90F6                  LD        A, (Y)
   \   00000A A4F8                  AND       A, #0xf8
   \   00000C 9093                  LDW       Y, X
   \   00000E 72A90006              ADDW      Y, #0x6
   \   000012 90F7                  LD        (Y), A
    154            /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    155            USARTx->CR3 |= (uint8_t)((uint8_t)((uint8_t)(USART_CPOL | (uint8_t)USART_CPHA ) | USART_LastBit));
   \   000014 B600                  LD        A, S:?b1
   \   000016 BA00                  OR        A, S:?b0
   \   000018 BA00                  OR        A, S:?b2
   \   00001A 9093                  LDW       Y, X
   \   00001C 72A90006              ADDW      Y, #0x6
   \   000020 90FA                  OR        A, (Y)
   \   000022 9093                  LDW       Y, X
   \   000024 72A90006              ADDW      Y, #0x6
   \   000028 90F7                  LD        (Y), A
    156          
    157            if (USART_Clock != USART_Clock_Disable)
   \   00002A 3D00                  TNZ       S:?b3
   \   00002C 270F                  JREQ      L:??USART_ClockInit_0
    158            {
    159              USARTx->CR3 |= (uint8_t)(USART_CR3_CLKEN); /* Set the Clock Enable bit */
   \   00002E 9093                  LDW       Y, X
   \   000030 72A90006              ADDW      Y, #0x6
   \   000034 90F6                  LD        A, (Y)
   \   000036 AA08                  OR        A, #0x8
   \   000038 1C0006                ADDW      X, #0x6
   \   00003B F7                    LD        (X), A
   \   00003C 81                    RET
    160            }
    161            else
    162            {
    163              USARTx->CR3 &= (uint8_t)(~USART_CR3_CLKEN); /* Clear the Clock Enable bit */
   \                     ??USART_ClockInit_0:
   \   00003D 9093                  LDW       Y, X
   \   00003F 72A90006              ADDW      Y, #0x6
   \   000043 90F6                  LD        A, (Y)
   \   000045 A4F7                  AND       A, #0xf7
   \   000047 1C0006                ADDW      X, #0x6
   \   00004A F7                    LD        (X), A
    164            }
    165          }
   \   00004B 81                    RET
    166          
    167          /**
    168            * @brief  Enable the USART peripheral.
    169            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    170            * @param  NewState : The new state of the USART Communication.
    171            *         This parameter can be any of the @ref FunctionalState enumeration.
    172            * @retval None
    173            */

   \                                 In section .near_func.text, align 1
    174          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    175          {
    176            if (NewState != DISABLE)
   \                     USART_Cmd:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??USART_Cmd_0
    177            {
    178              USARTx->CR1 &= (uint8_t)(~USART_CR1_USARTD); /**< USART Enable */
   \   000003 9093                  LDW       Y, X
   \   000005 72A90004              ADDW      Y, #0x4
   \   000009 90F6                  LD        A, (Y)
   \   00000B A4DF                  AND       A, #0xdf
   \   00000D 1C0004                ADDW      X, #0x4
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    179            }
    180            else
    181            {
    182              USARTx->CR1 |= USART_CR1_USARTD;  /**< USART Disable (for low power consumption) */
   \                     ??USART_Cmd_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A90004              ADDW      Y, #0x4
   \   000018 90F6                  LD        A, (Y)
   \   00001A AA20                  OR        A, #0x20
   \   00001C 1C0004                ADDW      X, #0x4
   \   00001F F7                    LD        (X), A
    183            }
    184          }
   \   000020 81                    RET
    185          
    186          /**
    187            * @brief  Enables or disables the specified USART interrupts.
    188            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    189            * @param  USART_IT specifies the USART interrupt sources to be enabled or disabled.
    190            *         This parameter can be one of the following values:
    191            *         - USART_IT_TXE:  Tansmit Data Register empty interrupt
    192            *         - USART_IT_TC:   Transmission complete interrupt
    193            *         - USART_IT_RXNE: Receive Data register not empty interrupt
    194            *         - USART_IT_OR: Overrun error interrupt
    195            *         - USART_IT_IDLE: Idle line detection interrupt
    196            *         - USART_IT_ERR:  Error interrupt
    197            * @param  NewState new state of the specified USART interrupts.
    198            *         This parameter can be: ENABLE or DISABLE.
    199            * @retval None
    200            */

   \                                 In section .near_func.text, align 1
    201          void USART_ITConfig(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT, FunctionalState NewState)
    202          {
   \                     USART_ITConfig:
   \   000000 BF00                  LDW       S:?w0, X
   \   000002 B700                  LD        S:?b4, A
    203            uint8_t usartreg, itpos = 0x00;
   \   000004 3F00                  CLR       S:?b3
    204            assert_param(IS_USART_CONFIG_IT(USART_IT));
    205            assert_param(IS_FUNCTIONAL_STATE(NewState));
    206          
    207            /* Get the USART register index */
    208            usartreg = (uint8_t)((uint16_t)USART_IT >> 0x08);
   \   000006 93                    LDW       X, Y
   \   000007 4F                    CLR       A
   \   000008 01                    RRWA      X, A
   \   000009 41                    EXG       A, XL
   \   00000A B700                  LD        S:?b2, A
   \   00000C 41                    EXG       A, XL
    209            /* Get the USART IT index */
    210            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)USART_IT & (uint8_t)0x0F));
   \   00000D 909F                  LD        A, YL
   \   00000F A40F                  AND       A, #0xf
   \   000011 5F                    CLRW      X
   \   000012 5C                    INCW      X
   \   000013 CD0000                CALL      L:?sll16_x_x_a
   \   000016 9F                    LD        A, XL
   \   000017 B700                  LD        S:?b3, A
    211          
    212            if (NewState != DISABLE)
   \   000019 3D00                  TNZ       S:?b4
   \   00001B 2739                  JREQ      L:??USART_ITConfig_0
    213            {
    214              /**< Enable the Interrupt bits according to USART_IT mask */
    215              if (usartreg == 0x01)
   \   00001D B600                  LD        A, S:?b2
   \   00001F A101                  CP        A, #0x1
   \   000021 260F                  JRNE      L:??USART_ITConfig_1
    216              {
    217                USARTx->CR1 |= itpos;
   \   000023 BE00                  LDW       X, S:?w0
   \   000025 1C0004                ADDW      X, #0x4
   \   000028 B600                  LD        A, S:?b3
   \   00002A FA                    OR        A, (X)
   \   00002B BE00                  LDW       X, S:?w0
   \   00002D 1C0004                ADDW      X, #0x4
   \   000030 F7                    LD        (X), A
   \   000031 81                    RET
    218              }
    219              else if (usartreg == 0x05)
   \                     ??USART_ITConfig_1:
   \   000032 B600                  LD        A, S:?b2
   \   000034 A105                  CP        A, #0x5
   \   000036 260F                  JRNE      L:??USART_ITConfig_2
    220              {
    221                USARTx->CR5 |= itpos;
   \   000038 BE00                  LDW       X, S:?w0
   \   00003A 1C0008                ADDW      X, #0x8
   \   00003D B600                  LD        A, S:?b3
   \   00003F FA                    OR        A, (X)
   \   000040 BE00                  LDW       X, S:?w0
   \   000042 1C0008                ADDW      X, #0x8
   \   000045 F7                    LD        (X), A
   \   000046 81                    RET
    222              }
    223              /*uartreg =0x02*/
    224              else
    225              {
    226                USARTx->CR2 |= itpos;
   \                     ??USART_ITConfig_2:
   \   000047 BE00                  LDW       X, S:?w0
   \   000049 1C0005                ADDW      X, #0x5
   \   00004C B600                  LD        A, S:?b3
   \   00004E FA                    OR        A, (X)
   \   00004F BE00                  LDW       X, S:?w0
   \   000051 1C0005                ADDW      X, #0x5
   \   000054 F7                    LD        (X), A
   \   000055 81                    RET
    227              }
    228            }
    229            else
    230            {
    231              /**< Disable the interrupt bits according to USART_IT mask */
    232              if (usartreg == 0x01)
   \                     ??USART_ITConfig_0:
   \   000056 B600                  LD        A, S:?b2
   \   000058 A101                  CP        A, #0x1
   \   00005A 2611                  JRNE      L:??USART_ITConfig_3
    233              {
    234                USARTx->CR1 &= (uint8_t)(~itpos);
   \   00005C BE00                  LDW       X, S:?w0
   \   00005E 1C0004                ADDW      X, #0x4
   \   000061 3300                  CPL       S:?b3
   \   000063 B600                  LD        A, S:?b3
   \   000065 F4                    AND       A, (X)
   \   000066 BE00                  LDW       X, S:?w0
   \   000068 1C0004                ADDW      X, #0x4
   \   00006B F7                    LD        (X), A
   \   00006C 81                    RET
    235              }
    236              else if (usartreg == 0x05)
   \                     ??USART_ITConfig_3:
   \   00006D B600                  LD        A, S:?b2
   \   00006F A105                  CP        A, #0x5
   \   000071 2611                  JRNE      L:??USART_ITConfig_4
    237              {
    238                USARTx->CR5 &= (uint8_t)(~itpos);
   \   000073 BE00                  LDW       X, S:?w0
   \   000075 1C0008                ADDW      X, #0x8
   \   000078 3300                  CPL       S:?b3
   \   00007A B600                  LD        A, S:?b3
   \   00007C F4                    AND       A, (X)
   \   00007D BE00                  LDW       X, S:?w0
   \   00007F 1C0008                ADDW      X, #0x8
   \   000082 F7                    LD        (X), A
   \   000083 81                    RET
    239              }
    240              /*uartreg =0x02*/
    241              else
    242              {
    243                USARTx->CR2 &= (uint8_t)(~itpos);
   \                     ??USART_ITConfig_4:
   \   000084 BE00                  LDW       X, S:?w0
   \   000086 1C0005                ADDW      X, #0x5
   \   000089 3300                  CPL       S:?b3
   \   00008B B600                  LD        A, S:?b3
   \   00008D F4                    AND       A, (X)
   \   00008E BE00                  LDW       X, S:?w0
   \   000090 1C0005                ADDW      X, #0x5
   \   000093 F7                    LD        (X), A
    244              }
    245            }
    246          
    247          }
   \   000094 81                    RET
    248          /**
    249            * @brief  Enables or disables the USART’s Half Duplex communication.
    250            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    251            * @param  NewState new state of the USART Communication.
    252            *         This parameter can be: ENABLE or DISABLE.
    253            * @retval None
    254            */

   \                                 In section .near_func.text, align 1
    255          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    256          {
    257            assert_param(IS_FUNCTIONAL_STATE(NewState));
    258          
    259            if (NewState != DISABLE)
   \                     USART_HalfDuplexCmd:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??USART_HalfDuplexCmd_0
    260            {
    261              USARTx->CR5 |= USART_CR5_HDSEL;  /**< USART Half Duplex Enable  */
   \   000003 9093                  LDW       Y, X
   \   000005 72A90008              ADDW      Y, #0x8
   \   000009 90F6                  LD        A, (Y)
   \   00000B AA08                  OR        A, #0x8
   \   00000D 1C0008                ADDW      X, #0x8
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    262            }
    263            else
    264            {
    265              USARTx->CR5 &= (uint8_t)~USART_CR5_HDSEL; /**< USART Half Duplex Disable */
   \                     ??USART_HalfDuplexCmd_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A90008              ADDW      Y, #0x8
   \   000018 90F6                  LD        A, (Y)
   \   00001A A4F7                  AND       A, #0xf7
   \   00001C 1C0008                ADDW      X, #0x8
   \   00001F F7                    LD        (X), A
    266            }
    267          }
   \   000020 81                    RET
    268          
    269          /**
    270            * @brief  Configures the USART’s IrDA interface.
    271            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    272            * @param  USART_IrDAMode specifies the IrDA mode.
    273            *         This parameter can be any of the @ref USART_IrDAMode_TypeDef values.
    274            * @retval None
    275            */

   \                                 In section .near_func.text, align 1
    276          void USART_IrDAConfig(USART_TypeDef* USARTx, USART_IrDAMode_TypeDef USART_IrDAMode)
    277          {
    278            assert_param(IS_USART_IRDAMODE(USART_IrDAMode));
    279          
    280            if (USART_IrDAMode != USART_IrDAMode_Normal)
   \                     USART_IrDAConfig:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??USART_IrDAConfig_0
    281            {
    282              USARTx->CR5 |= USART_CR5_IRLP;
   \   000003 9093                  LDW       Y, X
   \   000005 72A90008              ADDW      Y, #0x8
   \   000009 90F6                  LD        A, (Y)
   \   00000B AA04                  OR        A, #0x4
   \   00000D 1C0008                ADDW      X, #0x8
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    283            }
    284            else
    285            {
    286              USARTx->CR5 &= ((uint8_t)~USART_CR5_IRLP);
   \                     ??USART_IrDAConfig_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A90008              ADDW      Y, #0x8
   \   000018 90F6                  LD        A, (Y)
   \   00001A A4FB                  AND       A, #0xfb
   \   00001C 1C0008                ADDW      X, #0x8
   \   00001F F7                    LD        (X), A
    287            }
    288          }
   \   000020 81                    RET
    289          
    290          /**
    291            * @brief  Enables or disables the USART’s IrDA interface.
    292            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    293            * @param  NewState new state of the IrDA mode.
    294            *         This parameter can be: ENABLE or DISABLE.
    295            * @retval None
    296            */

   \                                 In section .near_func.text, align 1
    297          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
    298          {
    299          
    300            /* Check parameters */
    301            assert_param(IS_FUNCTIONAL_STATE(NewState));
    302          
    303            if (NewState != DISABLE)
   \                     USART_IrDACmd:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??USART_IrDACmd_0
    304            {
    305              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    306              USARTx->CR5 |= USART_CR5_IREN;
   \   000003 9093                  LDW       Y, X
   \   000005 72A90008              ADDW      Y, #0x8
   \   000009 90F6                  LD        A, (Y)
   \   00000B AA02                  OR        A, #0x2
   \   00000D 1C0008                ADDW      X, #0x8
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    307            }
    308            else
    309            {
    310              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    311              USARTx->CR5 &= ((uint8_t)~USART_CR5_IREN);
   \                     ??USART_IrDACmd_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A90008              ADDW      Y, #0x8
   \   000018 90F6                  LD        A, (Y)
   \   00001A A4FD                  AND       A, #0xfd
   \   00001C 1C0008                ADDW      X, #0x8
   \   00001F F7                    LD        (X), A
    312            }
    313          }
   \   000020 81                    RET
    314          /**
    315            * @brief  Enables or disables the USART Smart Card mode.
    316            * @param  USARTx: Select the USARTx peripheral.
    317            * @param  NewState: new state of the Smart Card mode.
    318            *         This parameter can be: ENABLE or DISABLE.
    319            * @retval None
    320            */

   \                                 In section .near_func.text, align 1
    321          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    322          {
    323            assert_param(IS_FUNCTIONAL_STATE(NewState));
    324          
    325            if (NewState != DISABLE)
   \                     USART_SmartCardCmd:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??USART_SmartCardCmd_0
    326            {
    327              /* Enable the SC mode by setting the SCEN bit in the CR5 register */
    328              USARTx->CR5 |= USART_CR5_SCEN;
   \   000003 9093                  LDW       Y, X
   \   000005 72A90008              ADDW      Y, #0x8
   \   000009 90F6                  LD        A, (Y)
   \   00000B AA20                  OR        A, #0x20
   \   00000D 1C0008                ADDW      X, #0x8
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    329            }
    330            else
    331            {
    332              /* Disable the SC mode by clearing the SCEN bit in the CR5 register */
    333              USARTx->CR5 &= ((uint8_t)(~USART_CR5_SCEN));
   \                     ??USART_SmartCardCmd_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A90008              ADDW      Y, #0x8
   \   000018 90F6                  LD        A, (Y)
   \   00001A A4DF                  AND       A, #0xdf
   \   00001C 1C0008                ADDW      X, #0x8
   \   00001F F7                    LD        (X), A
    334            }
    335          }
   \   000020 81                    RET
    336          
    337          /**
    338            * @brief  Enables or disables NACK transmission.
    339            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    340            * @param  NewState: new state of the Smart Card mode.
    341            *         This parameter can be: ENABLE or DISABLE.
    342            * @retval None
    343            */

   \                                 In section .near_func.text, align 1
    344          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    345          {
    346            assert_param(IS_FUNCTIONAL_STATE(NewState));
    347          
    348            if (NewState != DISABLE)
   \                     USART_SmartCardNACKCmd:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??USART_SmartCardNACKCmd_0
    349            {
    350              /* Enable the NACK transmission by setting the NACK bit in the CR5 register */
    351              USARTx->CR5 |= USART_CR5_NACK;
   \   000003 9093                  LDW       Y, X
   \   000005 72A90008              ADDW      Y, #0x8
   \   000009 90F6                  LD        A, (Y)
   \   00000B AA10                  OR        A, #0x10
   \   00000D 1C0008                ADDW      X, #0x8
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    352            }
    353            else
    354            {
    355              /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */
    356              USARTx->CR5 &= ((uint8_t)~(USART_CR5_NACK));
   \                     ??USART_SmartCardNACKCmd_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A90008              ADDW      Y, #0x8
   \   000018 90F6                  LD        A, (Y)
   \   00001A A4EF                  AND       A, #0xef
   \   00001C 1C0008                ADDW      X, #0x8
   \   00001F F7                    LD        (X), A
    357            }
    358          }
   \   000020 81                    RET
    359          /**
    360            * @brief  Sets the specified USART guard time.
    361            * @note   SmartCard Mode should be Enabled
    362            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    363            * @param  USART_GuardTime: specifies the guard time.
    364            * @retval None
    365            */

   \                                 In section .near_func.text, align 1
    366          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    367          {
    368            /* Set the USART guard time */
    369            USARTx->GTR = USART_GuardTime;
   \                     USART_SetGuardTime:
   \   000000 1C0009                ADDW      X, #0x9
   \   000003 F7                    LD        (X), A
    370          }
   \   000004 81                    RET
    371          
    372          /**
    373            * @brief  Sets the system clock prescaler.
    374            * @note   IrDA Low Power mode or smartcard mode should be enabled
    375            * @note   This function is related to SmartCard and IrDa mode.
    376            * @param  USARTx: Select the USARTx peripheral.
    377            * @param  USART_Prescaler: specifies the prescaler clock.
    378            *         This parameter can be one of the following values:
    379            *         @par IrDA Low Power Mode
    380            *         The clock source is diveded by the value given in the register (8 bits)
    381            *         - 0000 0000 Reserved
    382            *         - 0000 0001 divides the clock source by 1
    383            *         - 0000 0010 divides the clock source by 2
    384            *         - ...........................................................
    385            *        @par Smart Card Mode
    386            *        The clock source is diveded by the value given in the register
    387            *        (5 significant bits) multipied by 2
    388            *         - 0 0000 Reserved
    389            *         - 0 0001 divides the clock source by 2
    390            *         - 0 0010 divides the clock source by 4
    391            *         - 0 0011 divides the clock source by 6
    392            *         - ...........................................................
    393            * @retval None
    394            */

   \                                 In section .near_func.text, align 1
    395          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    396          {
    397            /* Load the USART prescaler value*/
    398            USARTx->PSCR = USART_Prescaler;
   \                     USART_SetPrescaler:
   \   000000 1C000A                ADDW      X, #0xa
   \   000003 F7                    LD        (X), A
    399          }
   \   000004 81                    RET
    400          
    401          /**
    402            * @brief  Returns the most recent received data by the USART peripheral.
    403            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    404            * @retval The received data.
    405            */

   \                                 In section .near_func.text, align 1
    406          uint8_t USART_ReceiveData8(USART_TypeDef* USARTx)
    407          {
    408            return USARTx->DR;
   \                     USART_ReceiveData8:
   \   000000 5C                    INCW      X
   \   000001 F6                    LD        A, (X)
   \   000002 81                    RET
    409          }
    410          
    411          
    412          /**
    413            * @brief  Returns the most recent received data by the USART peripheral.
    414            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    415            * @retval The received data.
    416            */

   \                                 In section .near_func.text, align 1
    417          uint16_t USART_ReceiveData9(USART_TypeDef* USARTx)
    418          {
   \                     USART_ReceiveData9:
   \   000000 9093                  LDW       Y, X
    419            uint16_t temp = 0;
   \   000002 3F00                  CLR       S:?b1
   \   000004 3F00                  CLR       S:?b0
    420          
    421            temp = ((uint16_t)(((uint16_t)((uint16_t)USARTx->CR1 & (uint16_t)USART_CR1_R8)) << 1));
   \   000006 93                    LDW       X, Y
   \   000007 1C0004                ADDW      X, #0x4
   \   00000A F6                    LD        A, (X)
   \   00000B 5F                    CLRW      X
   \   00000C 97                    LD        XL, A
   \   00000D 02                    RLWA      X, A
   \   00000E A400                  AND       A, #0x0
   \   000010 02                    RLWA      X, A
   \   000011 A480                  AND       A, #0x80
   \   000013 02                    RLWA      X, A
   \   000014 58                    SLLW      X
   \   000015 BF00                  LDW       S:?w0, X
    422            return (uint16_t)( ((uint16_t)((uint16_t)USARTx->DR) | temp) & ((uint16_t)0x01FF));
   \   000017 93                    LDW       X, Y
   \   000018 5C                    INCW      X
   \   000019 F6                    LD        A, (X)
   \   00001A 5F                    CLRW      X
   \   00001B 97                    LD        XL, A
   \   00001C 01                    RRWA      X, A
   \   00001D BA00                  OR        A, S:?b1
   \   00001F 01                    RRWA      X, A
   \   000020 BA00                  OR        A, S:?b0
   \   000022 01                    RRWA      X, A
   \   000023 02                    RLWA      X, A
   \   000024 A401                  AND       A, #0x1
   \   000026 02                    RLWA      X, A
   \   000027 A4FF                  AND       A, #0xff
   \   000029 02                    RLWA      X, A
   \   00002A 81                    RET
    423          }
    424          
    425          /**
    426            * @brief  Determines if the USART is in mute mode or not.
    427            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    428            * @param  NewState : The new state of the USART mode.
    429            *         This parameter can be any of the @ref FunctionalState enumeration.
    430            * @retval None
    431            */

   \                                 In section .near_func.text, align 1
    432          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    433          {
    434            assert_param(IS_FUNCTIONAL_STATE(NewState));
    435          
    436            if (NewState != DISABLE)
   \                     USART_ReceiverWakeUpCmd:
   \   000000 4D                    TNZ       A
   \   000001 270F                  JREQ      L:??USART_ReceiverWakeUpCmd_0
    437            {
    438              /* Enable the mute mode USART by setting the RWU bit in the CR2 register */
    439              USARTx->CR2 |= USART_CR2_RWU;
   \   000003 9093                  LDW       Y, X
   \   000005 72A90005              ADDW      Y, #0x5
   \   000009 90F6                  LD        A, (Y)
   \   00000B AA02                  OR        A, #0x2
   \   00000D 1C0005                ADDW      X, #0x5
   \   000010 F7                    LD        (X), A
   \   000011 81                    RET
    440            }
    441            else
    442            {
    443              /* Disable the mute mode USART by clearing the RWU bit in the CR1 register */
    444              USARTx->CR2 &= ((uint8_t)~USART_CR2_RWU);
   \                     ??USART_ReceiverWakeUpCmd_0:
   \   000012 9093                  LDW       Y, X
   \   000014 72A90005              ADDW      Y, #0x5
   \   000018 90F6                  LD        A, (Y)
   \   00001A A4FD                  AND       A, #0xfd
   \   00001C 1C0005                ADDW      X, #0x5
   \   00001F F7                    LD        (X), A
    445            }
    446          }
   \   000020 81                    RET
    447          
    448          /**
    449            * @brief  Transmits break characters.
    450            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    451            * @retval None
    452            */

   \                                 In section .near_func.text, align 1
    453          void USART_SendBreak(USART_TypeDef* USARTx)
    454          {
    455            USARTx->CR2 |= USART_CR2_SBK;
   \                     USART_SendBreak:
   \   000000 9093                  LDW       Y, X
   \   000002 72A90005              ADDW      Y, #0x5
   \   000006 90F6                  LD        A, (Y)
   \   000008 AA01                  OR        A, #0x1
   \   00000A 1C0005                ADDW      X, #0x5
   \   00000D F7                    LD        (X), A
    456          }
   \   00000E 81                    RET
    457          
    458          /**
    459            * @brief  Transmits 8 bit data through the USART peripheral.
    460            * @param  Data: The data to transmit.
    461            * @retval None
    462            */

   \                                 In section .near_func.text, align 1
    463          void USART_SendData8(USART_TypeDef* USARTx, uint8_t Data)
    464          {
    465            /* Transmit Data */
    466            USARTx->DR = Data;
   \                     USART_SendData8:
   \   000000 5C                    INCW      X
   \   000001 F7                    LD        (X), A
    467          }
   \   000002 81                    RET
    468          
    469          /**
    470            * @brief  Transmits 9 bit data through the USART peripheral.
    471            * @param  USARTx: Select the USARTx peripheral.
    472            * @param  Data : The data to transmit.
    473            *         This parameter should be lower than 0x1FF.
    474            * @retval None
    475            */

   \                                 In section .near_func.text, align 1
    476          void USART_SendData9(USART_TypeDef* USARTx, uint16_t Data)
    477          {
   \                     USART_SendData9:
   \   000000 BF00                  LDW       S:?w0, X
    478            assert_param(IS_USART_DATA_9BITS(Data));
    479          
    480            /* Clear the transmit data bit 8     */
    481            USARTx->CR1 &= ((uint8_t)~USART_CR1_T8);
   \   000002 BE00                  LDW       X, S:?w0
   \   000004 1C0004                ADDW      X, #0x4
   \   000007 F6                    LD        A, (X)
   \   000008 A4BF                  AND       A, #0xbf
   \   00000A BE00                  LDW       X, S:?w0
   \   00000C 1C0004                ADDW      X, #0x4
   \   00000F F7                    LD        (X), A
    482          
    483            /* Write the transmit data bit [8]   */
    484            USARTx->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & USART_CR1_T8);
   \   000010 93                    LDW       X, Y
   \   000011 54                    SRLW      X
   \   000012 54                    SRLW      X
   \   000013 9F                    LD        A, XL
   \   000014 A440                  AND       A, #0x40
   \   000016 BE00                  LDW       X, S:?w0
   \   000018 1C0004                ADDW      X, #0x4
   \   00001B FA                    OR        A, (X)
   \   00001C BE00                  LDW       X, S:?w0
   \   00001E 1C0004                ADDW      X, #0x4
   \   000021 F7                    LD        (X), A
    485          
    486            /* Write the transmit data bit [0:7] */
    487            USARTx->DR   = (uint8_t)(Data);
   \   000022 BE00                  LDW       X, S:?w0
   \   000024 5C                    INCW      X
   \   000025 909F                  LD        A, YL
   \   000027 F7                    LD        (X), A
    488          }
   \   000028 81                    RET
    489          
    490          /**
    491            * @brief  Sets the address of the USART node.
    492            * @param  USARTx: Select the USARTx peripheral.
    493            * @param  Address : Indicates the address of the USART node.
    494            *         This parameter should be lower than 16
    495            * @retval None
    496            */

   \                                 In section .near_func.text, align 1
    497          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    498          {
   \                     USART_SetAddress:
   \   000000 B700                  LD        S:?b0, A
    499            /* assert_param for USART_Address */
    500            assert_param(IS_USART_ADDRESS(USART_Address));
    501          
    502            /* Clear the USART address */
    503            USARTx->CR4 &= ((uint8_t)~USART_CR4_ADD);
   \   000002 9093                  LDW       Y, X
   \   000004 72A90007              ADDW      Y, #0x7
   \   000008 90F6                  LD        A, (Y)
   \   00000A A4F0                  AND       A, #0xf0
   \   00000C 9093                  LDW       Y, X
   \   00000E 72A90007              ADDW      Y, #0x7
   \   000012 90F7                  LD        (Y), A
    504            /* Set the USART address node */
    505            USARTx->CR4 |= USART_Address;
   \   000014 9093                  LDW       Y, X
   \   000016 72A90007              ADDW      Y, #0x7
   \   00001A B600                  LD        A, S:?b0
   \   00001C 90FA                  OR        A, (Y)
   \   00001E 1C0007                ADDW      X, #0x7
   \   000021 F7                    LD        (X), A
    506          }
   \   000022 81                    RET
    507          
    508          /**
    509            * @brief  Selects the USART WakeUp method.
    510            * @param  USART_WakeUp : Specifies the USART wakeup method.
    511            *         This parameter can be any of the @ref USART_WakeUp_TypeDef values
    512            * @retval None
    513            */

   \                                 In section .near_func.text, align 1
    514          void USART_WakeUpConfig(USART_TypeDef* USARTx, USART_WakeUp_TypeDef USART_WakeUp)
    515          {
   \                     USART_WakeUpConfig:
   \   000000 B700                  LD        S:?b0, A
    516            assert_param(IS_USART_WAKEUP(USART_WakeUp));
    517          
    518            USARTx->CR1 &= ((uint8_t)~USART_CR1_WAKE);
   \   000002 9093                  LDW       Y, X
   \   000004 72A90004              ADDW      Y, #0x4
   \   000008 90F6                  LD        A, (Y)
   \   00000A A4F7                  AND       A, #0xf7
   \   00000C 9093                  LDW       Y, X
   \   00000E 72A90004              ADDW      Y, #0x4
   \   000012 90F7                  LD        (Y), A
    519            USARTx->CR1 |= (uint8_t)USART_WakeUp;
   \   000014 9093                  LDW       Y, X
   \   000016 72A90004              ADDW      Y, #0x4
   \   00001A B600                  LD        A, S:?b0
   \   00001C 90FA                  OR        A, (Y)
   \   00001E 1C0004                ADDW      X, #0x4
   \   000021 F7                    LD        (X), A
    520          }
   \   000022 81                    RET
    521          
    522          /**
    523            * @brief  Enables or disables the USART DMA interface.
    524            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    525            * @param  USART_DMAReq Specifies the USART DMA transfer request to be enabled or disabled.
    526            *         This parameter can be any of the @ref USART_DMAReq_TypeDef enumeration.
    527            * @param  NewState Indicates the new state of the USART DMA request.
    528            *         This parameter can be any of the @ref FunctionalState enumeration.
    529            * @retval None
    530            */

   \                                 In section .near_func.text, align 1
    531          void USART_DMACmd(USART_TypeDef* USARTx, USART_DMAReq_TypeDef USART_DMAReq,
    532                            FunctionalState NewState)
    533          {
    534            /* Check the parameters */
    535            assert_param(IS_USART_DMAREQ(USART_DMAReq));
    536            assert_param(IS_FUNCTIONAL_STATE(NewState));
    537          
    538            if (NewState != DISABLE)
   \                     USART_DMACmd:
   \   000000 3D00                  TNZ       S:?b0
   \   000002 270D                  JREQ      L:??USART_DMACmd_0
    539            {
    540              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
    541                 DMAR bits in the USART CR5 register */
    542              USARTx->CR5 |= (uint8_t) USART_DMAReq;
   \   000004 9093                  LDW       Y, X
   \   000006 72A90008              ADDW      Y, #0x8
   \   00000A 90FA                  OR        A, (Y)
   \   00000C 1C0008                ADDW      X, #0x8
   \   00000F F7                    LD        (X), A
   \   000010 81                    RET
    543            }
    544            else
    545            {
    546              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
    547                 DMAR bits in the USART CR5 register */
    548              USARTx->CR5 &= (uint8_t)~USART_DMAReq;
   \                     ??USART_DMACmd_0:
   \   000011 9093                  LDW       Y, X
   \   000013 72A90008              ADDW      Y, #0x8
   \   000017 43                    CPL       A
   \   000018 90F4                  AND       A, (Y)
   \   00001A 1C0008                ADDW      X, #0x8
   \   00001D F7                    LD        (X), A
    549            }
    550          }
   \   00001E 81                    RET
    551          
    552          /**
    553            * @brief  Checks whether the specified USART flag is set or not.
    554            * @param  USARTx: Select the USARTx peripheral.
    555            * @param  USART_FLAG specifies the flag to check.
    556            *         This parameter can be any of the @ref USART_FLAG_TypeDef enumeration.
    557            * @retval FlagStatus (SET or RESET)
    558            */

   \                                 In section .near_func.text, align 1
    559          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG)
    560          {
    561            FlagStatus status = RESET;
   \                     USART_GetFlagStatus:
   \   000000 4F                    CLR       A
    562          
    563            /* Check parameters */
    564            assert_param(IS_USART_FLAG(USART_FLAG));
    565          
    566            if (USART_FLAG == USART_FLAG_SBK)
   \   000001 90A30101              CPW       Y, #0x101
   \   000005 260F                  JRNE      L:??USART_GetFlagStatus_0
    567            {
    568              if ((USARTx->CR2 & (uint8_t)USART_FLAG) != (uint8_t)0x00)
   \   000007 1C0005                ADDW      X, #0x5
   \   00000A 909F                  LD        A, YL
   \   00000C F4                    AND       A, (X)
   \   00000D A100                  CP        A, #0x0
   \   00000F 2703                  JREQ      L:??USART_GetFlagStatus_1
    569              {
    570                /* USART_FLAG is set*/
    571                status = SET;
   \   000011 A601                  LD        A, #0x1
   \   000013 81                    RET
    572              }
    573              else
    574              {
    575                /* USART_FLAG is reset*/
    576                status = RESET;
   \                     ??USART_GetFlagStatus_1:
   \   000014 4F                    CLR       A
   \   000015 81                    RET
    577              }
    578            }
    579            else
    580            {
    581              if ((USARTx->SR & (uint8_t)USART_FLAG) != (uint8_t)0x00)
   \                     ??USART_GetFlagStatus_0:
   \   000016 909F                  LD        A, YL
   \   000018 F4                    AND       A, (X)
   \   000019 A100                  CP        A, #0x0
   \   00001B 2703                  JREQ      L:??USART_GetFlagStatus_2
    582              {
    583                /* USART_FLAG is set*/
    584                status = SET;
   \   00001D A601                  LD        A, #0x1
   \   00001F 81                    RET
    585              }
    586              else
    587              {
    588                /* USART_FLAG is reset*/
    589                status = RESET;
   \                     ??USART_GetFlagStatus_2:
   \   000020 4F                    CLR       A
    590              }
    591            }
    592            /* Return the USART_FLAG status*/
    593            return status;
   \   000021 81                    RET
    594          }
    595          
    596          /**
    597            * @brief  Clears the USARTx's pending flags.
    598            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    599            * @param  USART_FLAG: specifies the flag to clear.
    600            *         This parameter can be any combination of the following values:
    601            *         USART_FLAG_TC:   Transmission Complete flag.
    602            *         USART_FLAG_RXNE: Receive data register not empty flag.
    603            *
    604            * @Note
    605            *     - PE (Parity error), FE (Framing error), NE (Noise error), OR (OverRun error)
    606            *       and IDLE (Idle line detected) flags are cleared by software sequence: a read
    607            *       operation to USART_SR register (USART_GetFlagStatus())followed by a read
    608            *       operation to USART_DR register(USART_ReceiveData8() or USART_ReceiveData9()).
    609            *
    610            *     - RXNE flag can be also cleared by a read to the USART_DR register
    611            *       (USART_ReceiveData8()or USART_ReceiveData9()).
    612            *
    613            *     - TC flag can be also cleared by software sequence: a read operation to USART_SR
    614            *       register (USART_GetFlagStatus()) followed by a write operation to USART_DR
    615            *       register (USART_SendData8() or USART_SendData9()).
    616            *
    617            *     - TXE flag is cleared only by a write to the USART_DR register
    618            *       (USART_SendData8() or USART_SendData9()).
    619            *
    620            *     - SBK flag is cleared during the stop bit of break.
    621            *
    622            * @retval None
    623            */

   \                                 In section .near_func.text, align 1
    624          void USART_ClearFlag(USART_TypeDef* USARTx, USART_FLAG_TypeDef USART_FLAG)
    625          {
    626            /* Check the parameters */
    627            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
    628            /*< Clear RXNE or TC flags */
    629            USARTx->SR = (uint8_t)((uint16_t)~((uint16_t)USART_FLAG));
   \                     USART_ClearFlag:
   \   000000 909F                  LD        A, YL
   \   000002 43                    CPL       A
   \   000003 F7                    LD        (X), A
    630          }
   \   000004 81                    RET
    631          
    632          /**
    633            * @brief  Checks whether the specified USART interrupt has occurred or not.
    634            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    635            * @param  USART_IT: Specifies the USART interrupt pending bit to check.
    636            *         This parameter can be one of the following values:
    637            *         - USART_IT_TXE: Transmit Data Register empty interrupt
    638            *         - USART_IT_TC: Transmission complete interrupt
    639            *         - USART_IT_RXNE: Receive Data register not empty interrupt
    640            *         - USART_IT_IDLE: Idle line detection interrupt
    641            *         - USART_IT_OR: OverRun Error interrupt
    642            *         - USART_IT_PE: Parity Error interrupt
    643            *         - USART_IT_FE: Frame Error interrupt
    644            *         - USART_IT_NF: Noise Flag Error interrupt
    645            * @retval ITStatus The new state of USART_IT (SET or RESET).
    646            */

   \                                 In section .near_func.text, align 1
    647          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT)
    648          {
   \                     USART_GetITStatus:
   \   000000 BF00                  LDW       S:?w1, X
    649            ITStatus pendingbitstatus = RESET;
   \   000002 3F00                  CLR       S:?b0
    650            uint8_t temp = 0;
   \   000004 3F00                  CLR       S:?b7
    651            uint8_t itpos = 0;
   \   000006 3F00                  CLR       S:?b6
    652            uint8_t itmask1 = 0;
   \   000008 3F00                  CLR       S:?b1
    653            uint8_t itmask2 = 0;
   \   00000A 3F00                  CLR       S:?b5
    654            uint8_t enablestatus = 0;
   \   00000C 3F00                  CLR       S:?b4
    655          
    656            /* Check parameters */
    657            assert_param(IS_USART_GET_IT(USART_IT));
    658          
    659            /* Get the USART IT index */
    660            itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)USART_IT & (uint8_t)0x0F));
   \   00000E 909F                  LD        A, YL
   \   000010 A40F                  AND       A, #0xf
   \   000012 5F                    CLRW      X
   \   000013 5C                    INCW      X
   \   000014 CD0000                CALL      L:?sll16_x_x_a
   \   000017 9F                    LD        A, XL
   \   000018 B700                  LD        S:?b6, A
    661            /* Get the USART IT index */
    662            itmask1 = (uint8_t)((uint8_t)USART_IT >> (uint8_t)4);
   \   00001A 909F                  LD        A, YL
   \   00001C 4E                    SWAP      A
   \   00001D A40F                  AND       A, #0xf
   \   00001F B700                  LD        S:?b1, A
    663            /* Set the IT mask*/
    664            itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \   000021 5F                    CLRW      X
   \   000022 5C                    INCW      X
   \   000023 B600                  LD        A, S:?b1
   \   000025 CD0000                CALL      L:?sll16_x_x_a
   \   000028 9F                    LD        A, XL
   \   000029 B700                  LD        S:?b5, A
    665          
    666            /* Check the status of the specified USART pending bit*/
    667            if (USART_IT == USART_IT_PE)
   \   00002B 90A30100              CPW       Y, #0x100
   \   00002F 2621                  JRNE      L:??USART_GetITStatus_0
    668            {
    669              /* Get the USART_IT enable bit status*/
    670              enablestatus = (uint8_t)((uint8_t)USARTx->CR1 & itmask2);
   \   000031 BE00                  LDW       X, S:?w1
   \   000033 1C0004                ADDW      X, #0x4
   \   000036 B600                  LD        A, S:?b5
   \   000038 F4                    AND       A, (X)
   \   000039 B700                  LD        S:?b4, A
    671              /* Check the status of the specified USART interrupt*/
    672          
    673              if (((USARTx->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   00003B B600                  LD        A, S:?b6
   \   00003D 92C400                AND       A, [S:?w1.w]
   \   000040 A100                  CP        A, #0x0
   \   000042 270A                  JREQ      L:??USART_GetITStatus_1
   \   000044 3D00                  TNZ       S:?b4
   \   000046 2706                  JREQ      L:??USART_GetITStatus_1
    674              {
    675                /* Interrupt occurred*/
    676                pendingbitstatus = SET;
   \   000048 35010000              MOV       S:?b0, #0x1
   \   00004C 2058                  JRA       L:??USART_GetITStatus_2
    677              }
    678              else
    679              {
    680                /* Interrupt not occurred*/
    681                pendingbitstatus = RESET;
   \                     ??USART_GetITStatus_1:
   \   00004E 3F00                  CLR       S:?b0
   \   000050 2054                  JRA       L:??USART_GetITStatus_2
    682              }
    683            }
    684          
    685            else if (USART_IT == USART_IT_OR)
   \                     ??USART_GetITStatus_0:
   \   000052 90A30235              CPW       Y, #0x235
   \   000056 262F                  JRNE      L:??USART_GetITStatus_3
    686            {
    687              /* Get the USART_IT enable bit status*/
    688              enablestatus = (uint8_t)((uint8_t)USARTx->CR2 & itmask2);
   \   000058 BE00                  LDW       X, S:?w1
   \   00005A 1C0005                ADDW      X, #0x5
   \   00005D B600                  LD        A, S:?b5
   \   00005F F4                    AND       A, (X)
   \   000060 B700                  LD        S:?b4, A
    689              /* Check the status of the specified USART interrupt*/
    690          
    691              temp = (uint8_t)(USARTx->CR5 & USART_CR5_EIE);
   \   000062 BE00                  LDW       X, S:?w1
   \   000064 1C0008                ADDW      X, #0x8
   \   000067 F6                    LD        A, (X)
   \   000068 A401                  AND       A, #0x1
   \   00006A B700                  LD        S:?b7, A
    692          
    693              if (( (USARTx->SR & itpos) != 0x00) && ((enablestatus || temp)))
   \   00006C B600                  LD        A, S:?b6
   \   00006E 92C400                AND       A, [S:?w1.w]
   \   000071 A100                  CP        A, #0x0
   \   000073 270E                  JREQ      L:??USART_GetITStatus_4
   \   000075 3D00                  TNZ       S:?b4
   \   000077 2604                  JRNE      L:??USART_GetITStatus_5
   \   000079 3D00                  TNZ       S:?b7
   \   00007B 2706                  JREQ      L:??USART_GetITStatus_4
    694              {
    695                /* Interrupt occurred*/
    696                pendingbitstatus = SET;
   \                     ??USART_GetITStatus_5:
   \   00007D 35010000              MOV       S:?b0, #0x1
   \   000081 2023                  JRA       L:??USART_GetITStatus_2
    697              }
    698              else
    699              {
    700                /* Interrupt not occurred*/
    701                pendingbitstatus = RESET;
   \                     ??USART_GetITStatus_4:
   \   000083 3F00                  CLR       S:?b0
   \   000085 201F                  JRA       L:??USART_GetITStatus_2
    702              }
    703            }
    704          
    705            else
    706            {
    707              /* Get the USART_IT enable bit status*/
    708              enablestatus = (uint8_t)((uint8_t)USARTx->CR2 & itmask2);
   \                     ??USART_GetITStatus_3:
   \   000087 BE00                  LDW       X, S:?w1
   \   000089 1C0005                ADDW      X, #0x5
   \   00008C B600                  LD        A, S:?b5
   \   00008E F4                    AND       A, (X)
   \   00008F B700                  LD        S:?b4, A
    709              /* Check the status of the specified USART interrupt*/
    710              if (((USARTx->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000091 B600                  LD        A, S:?b6
   \   000093 92C400                AND       A, [S:?w1.w]
   \   000096 A100                  CP        A, #0x0
   \   000098 270A                  JREQ      L:??USART_GetITStatus_6
   \   00009A 3D00                  TNZ       S:?b4
   \   00009C 2706                  JREQ      L:??USART_GetITStatus_6
    711              {
    712                /* Interrupt occurred*/
    713                pendingbitstatus = SET;
   \   00009E 35010000              MOV       S:?b0, #0x1
   \   0000A2 2002                  JRA       L:??USART_GetITStatus_2
    714              }
    715              else
    716              {
    717                /* Interrupt not occurred*/
    718                pendingbitstatus = RESET;
   \                     ??USART_GetITStatus_6:
   \   0000A4 3F00                  CLR       S:?b0
    719              }
    720            }
    721          
    722            /* Return the USART_IT status*/
    723            return  pendingbitstatus;
   \                     ??USART_GetITStatus_2:
   \   0000A6 B600                  LD        A, S:?b0
   \   0000A8 81                    RET
    724          }
    725          
    726          /**
    727            * @brief  Clears the USARTx’s interrupt pending bits.
    728            * @param  USARTx : where x can be 1 to select the specified USART peripheral.
    729            * @param  USART_IT: specifies the interrupt pending bit to clear.
    730            *         This parameter can be one of the following values:
    731            *         USART_IT_RXNE: Receive Data register not empty interrupt.
    732            *         USART_IT_TC:   Transmission complete interrupt.
    733            *
    734            * @note
    735            *         - PE (Parity error), FE (Framing error), NE (Noise error),
    736            *         OR (OverRun error) and IDLE (Idle line detected) pending bits are
    737            *         cleared by software sequence: a read operation to USART_SR register
    738            *         (USART_GetITStatus()) followed by a read operation to USART_DR
    739            *         register (USART_ReceiveData8() or USART_ReceiveData9()).
    740            *
    741            *         - RXNE pending bit can be also cleared by a read to the USART_DR register
    742            *         (USART_ReceiveData8() or USART_ReceiveData9()).
    743            *
    744            *         - TC (Transmit complet) pending bit can be also cleared by software
    745            *         sequence: a read operation to USART_SR register (USART_GetITStatus())
    746            *         followed by a write operation to USART_DR register (USART_SendData8()
    747            *         or USART_SendData9()).
    748            *
    749            *         - TXE pending bit is cleared only by a write to the USART_DR register
    750            *         (USART_SendData8() or USART_SendData9()).
    751            *
    752            * @retval None
    753            */

   \                                 In section .near_func.text, align 1
    754          void USART_ClearITPendingBit(USART_TypeDef* USARTx, USART_IT_TypeDef USART_IT)
    755          {
   \                     USART_ClearITPendingBit:
   \   000000 BF00                  LDW       S:?w1, X
    756            uint8_t bitpos = 0x00, itmask = 0x00;
   \   000002 3F00                  CLR       S:?b1
   \   000004 3F00                  CLR       S:?b0
    757            assert_param(IS_USART_CLEAR_IT(USART_IT));
    758            bitpos = (uint8_t)( (uint8_t)((uint8_t)USART_IT & (uint8_t)0xF0) >> 0x04);
   \   000006 909F                  LD        A, YL
   \   000008 4E                    SWAP      A
   \   000009 A40F                  AND       A, #0xf
   \   00000B B700                  LD        S:?b1, A
    759            itmask = (uint8_t)( (uint8_t)0x01 << bitpos);
   \   00000D 5F                    CLRW      X
   \   00000E 5C                    INCW      X
   \   00000F B600                  LD        A, S:?b1
   \   000011 CD0000                CALL      L:?sll16_x_x_a
   \   000014 9F                    LD        A, XL
   \   000015 B700                  LD        S:?b0, A
    760            /*< Clear RXNE or TC pending bit */
    761            USARTx->SR = (uint8_t)~itmask;
   \   000017 3300                  CPL       S:?b0
   \   000019 B600                  LD        A, S:?b0
   \   00001B 92C700                LD        [S:?w1.w], A
    762          }
   \   00001E 81                    RET
    763          
    764          
    765          /**
    766            * @}
    767            */
    768          
    769          /**
    770            * @}
    771            */
    772          
    773          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label          Bytes
     --------------          -----
     USART_DeInit              62
     USART_Init               217
     USART_ClockInit           76
     USART_Cmd                 33
     USART_ITConfig           149
     USART_HalfDuplexCmd       33
     USART_IrDAConfig          33
     USART_IrDACmd             33
     USART_SmartCardCmd        33
     USART_SmartCardNACKCmd    33
     USART_SetGuardTime         5
     USART_SetPrescaler         5
     USART_ReceiveData8         3
     USART_ReceiveData9        43
     USART_ReceiverWakeUpCmd   33
     USART_SendBreak           15
     USART_SendData8            3
     USART_SendData9           41
     USART_SetAddress          35
     USART_WakeUpConfig        35
     USART_DMACmd              31
     USART_GetFlagStatus       34
     USART_ClearFlag            5
     USART_GetITStatus        169
     USART_ClearITPendingBit   31

 
 1 190 bytes in section .near_func.text
 
 1 190 bytes of CODE memory

Errors: none
Warnings: none
